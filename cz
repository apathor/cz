#!/usr/bin/env bash
#
# cz - Line selection abstraction (plus utilities!)
# (C) 2020 by Mike Lalumiere
#
# TODO
#  - Completion hook function?
#  - AWS/s3 plugins
#  - I8n?
#  - Better built-in line selector
#
# shellcheck disable=SC2030,SC2031

if (("${BASH_VERSINFO[0]}" < 4)); then
    printf "%s\n" "$0 requires bash 4!" >&2
    return 255
fi

chuz() {
    # usage
    read -r -d '' use <<EOF
chuz < INPUT > LINE
Select one line from input.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *) printf "%s\n" "$use" >&2
               return 1
               ;;
        esac
    done
    shift $((OPTIND - 1))
    # prepend a number to each line of input
    local ind lines
    mapfile -t lines
    for ((ind=0; ind < "${#lines[@]}"; ind++)); do
        printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
    done < <(printf "%s\n" "${lines[@]}")
    # prompt interactively to select a line number
    shopt -s nocasematch
    while read -p "#? " -r sel < /dev/tty; do
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            # given a non-number perform a string search
            for ((ind=0; ind < "${#lines[@]}"; ind++)); do
                if [[ "${lines[$ind]}" =~ $sel ]]; then
                    printf "% 5d %s\n" "$ind" "${lines[$ind]}" >&2
                fi
            done < <(printf "%s\n" "${lines[@]}")
        else
            # line number must be within boundaries
            if [ "$sel" -lt "${#lines[@]}" ]; then
                break
            fi
        fi
    done
    shopt -u nocasematch
    # failed unless a selection was made
    if [ -z "$sel" ]; then return 2; fi
    # print the selected line
    printf "%s\n" "${lines[$sel]}"
}

hep() {
    read -r -d '' use <<EOF
hep TOGGLE < INPUT > OUTPUT
Print input text if TOGGLE is non-empty, otherwise fail.
Use this function to optionally print help text in other functions.
For example: { hep "\$HELP_TOGGLE" && return; } <<<EOF ...
EOF
    # no option but help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # let input through if given an argument
    if [ -n "$1" ]; then
        printf "%s\n" "$(< /dev/stdin)" >&2
    else
        return 1
    fi
}

hold() {
    read -r -d '' use <<EOF
hold [OPTIONS] [MODE] [ARGUMENTS]
Speed up pipelines with caching!

MODE
 -e         : arguments are evaluated as a command and the output is cached
 -f         : arguments are considered files and their content is cached
 -g         : ignore arguments and only retreive cached content

OPTIONS
 -n NAME    : Set the cache name. By default the name of the calling function is used.
 -p         : Print the contents of the cached file instead of its name.
 -q         : Quiet mode. Do not print cache file name or contents.
 -t SECONDS : Clear cache files older than given number of seconds.
 -x         : Do not load a cached file.

ENVIRONMENT
 HOLD_DIR   : Cache directory. The default is $HOME/.cache/hold

EXAMPLES
 Cache a long running command.
  $ hold -e -n foo -t 60 long running command
 Cache a long running pipeline.
  $ hold -g -n bar -t 30 || hold -f -n bar -x <(long running command)
 Get a cache file by name.
  $ f="\$(hold -g -n foo)"; cat "\$f"
 Retreive cache file contents.
  $ hold -g -p -n foo
 Overwrite a cache.
  $ hold -fx -n bar - <<< "test"
 Accept a file argument or stdin in one command.
  $ hold -fx -n qux "\${1:--}"
EOF
    # help out
    if (( $# == 0 )); then
        printf "Command arguments required.\n%s\n" "$use" >&2
        return 1
    fi
    # get current time
    local now="${EPOCHSECONDS:-$(printf "%(%s)T\n" -1)}"
    # accept options
    local name="${FUNCNAME[1]:-hold}" # string cache name
    local expire=0                    # integer seconds to expire cache
    local new="${HOLD_CLEAR:-0}"      # boolean to clear cache
    local mode='run'                  # program mode: run/file/load
    local out='name'                  # output mode: name/content/quiet
    local opt OPTIND OPTARG
    while getopts ":hefgn:pqt:x" opt; do
        case "$opt" in
            e) # command input mode
                mode='run'
                ;;
            f) # file input mode
                mode='file'
                ;;
            g) # cache read
                mode='load'
                ;;
            n) # cache name
                name="$OPTARG"
                if ! [[ "$name" =~ ^[[:alnum:]_-]+$ ]]; then
                    printf "%s - Invalid cache name '%s'.\n" "$0" "$name" >&2
                    return 1
                fi
                ;;
            t) # cache expiration time
                expire="$OPTARG"
                if ! [[ "$expire" =~ ^[[:digit:]]+$ ]]; then
                    printf "%s - Invalid cache time '%s'.\n" "$0" "$expire" >&2
                    return 1
                fi
                ;;
            p) # print the contents of the file
                out='content'
                ;;
            q) # print nothing
                out='quiet'
                ;;
            x) # force fresh cache
                new=1
                ;;
            h) # help
                printf "%s\n" "$use" >&2
                return 0
                ;;
            \?)
                printf "Invalid option '%s'.\n%s\n" "$OPTARG" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # setup the cache directory
    local tmpd="${HOLD_DIR:-$HOME/.cache/hold}"
    if ! command mkdir -p "$tmpd"; then
        printf "Could not make cache directory '%s'.\n" "$tmpd" >&2
        return 2
    fi
    # scan cached files in glob order
    local hot=()
    shopt -s nullglob
    for file in "$tmpd/$name."*; do
        # skip non-files
        if ! [ -f "$file" ]; then
            continue
        fi
        # get timestamp component of file name
        IFS=. read -r _ ts <<< "${file##*/}"
        if ! [[ "$ts" =~ ^[0-9]+$ ]]; then
            continue
        fi
        # remove files older than the expiration time
        if (( new )) || (( expire )) && (( now - expire > ts )); then
            command rm "$file"
            continue
        fi
        # gather matching files
        hot+=("$file")
    done
    shopt -u nullglob
    # check cache
    local rc=0
    local cache=""
    if ! (( new )) && (( ${#hot} )); then
        # use most recent cached file
        cache="${hot[-1]}"
    else
        # create a new cache file
        cache=$(printf "$tmpd/%s.%d\n" "$name" "$now")
        case "$mode" in
            run) # command mode - eval arguments as a command
                if (( $# == 0 )); then
                    printf "Command arguments required.\n%s\n" "$use" >&2
                    return 1
                fi
                eval "${*@Q}" > "$cache"
                ;;
            file) # file mode - cat arguments
                # requrie arguments
                if (( $# == 0 )); then
                    printf "File arguments required.\n%s\n" "$use" >&2
                    return 1
                fi
                # ensure each file exists
                local each=""
                for each in "$@"; do
                    if ! [ -f "$each" ] && [ "$each" != "-" ]; then
                        printf "File does not exist: '%s'\n%s\n" "$each" "$use" >&2
                        return 1
                    fi
                done
                # dump file contents to cache
                cat -- "$*" > "$cache"
                ;;
            load) # cache miss!
                return 4
                ;;
        esac
    fi
    # output
    case "$out" in
        content) # print content of cache file
            cat "$cache"
            ;;
        name) # print name of cache file
            printf "%s\n" "$cache"
            ;;
    esac
    return "$rc"
}

nth() {
    read -r -d '' use <<EOF
nth [OPTIONS] TEMPLATE [ARG ...]
Generate a string from TEMPLATE replacing variables of the format:
 {X}     : argument X
 {X:}    : arguments X through end of arguments
 {X:Y}   : arguments X through X + Y
 {X,Y,Z} : arguments X, Y, and Z

Append @C, @E, @P, or @Q to transform selected arguments:
 @C - Insert argument literally. This is risky for command strings!
 @E - Replace backslash escape sequences in arguments with bash $'...' quotes.
 @P - Expand arguments for use in prompt strings.
 @Q - Quote arguments for use in command input. This is the default.

OPTIONS
 -c | -e | -p | -q
  Use @C, @E, @P, or @Q transform by default for each variable.

EXAMPLES
 $ nth -p "{2,25}" {A..Z}        = C Z
 $ nth -q "{0:}" foo bar baz     = 'foo' 'bar' 'baz'
 $ nth "{1@Q} {0@P}" "a b" "c d" = 'c d' a b
 $ nth "({2,1})" w x y z         = ('y' 'x')

EOF
    # accept options
    local pto="Q"
    local opt OPTIND OPTARG
    while getopts ":cehpq" opt; do
        case "$opt" in
            c) pto="C" ;; # clear
            e) pto="E" ;; # escaped
            p) pto="P" ;; # prompt
            q) pto="Q" ;; # quoted
            *) # invalid?
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # require template argument
    if ! (( $# )); then
        printf "%s\n" "$use" >&2
        return 1
    fi
    local tmpl="$1"
    shift
    # any remaining arguments are tokens to be inserted into the template
    local toks=("$@")
    # parser appends to this output string
    local out=""
    # parse template string
    local index=0 mode="text"
    local char="" next=""
    local field="" fields=() fmt=""
    while (( index < "${#tmpl}" )); do
        # consider each character
        char="${tmpl:$index:1}"
        next="${tmpl:$(( index + 1 )):1}"
        # switch on parser mode
        if [[ "$mode" == "text" ]]; then
            # parse literal text
            case "$char" in
                '{')
                    # curly brace starts a variable
                    fields=()
                    mode="var"
                    ;;
                *)
                    # accumulate characters
                    out+="$char"
                    ;;
            esac
        elif [[ "$mode" == "var" ]]; then
            # start parsing a variable
            case "$char" in
                '{') # escaped literal curly brace
                    out+="$char"
                    mode="text"
                    ;;
                [[:digit:]:-]) # field specifiers
                    field+="$char"
                    ;;
                [,\}]) # field separator
                    # match and validate the field
                    if ! [[ "$field" =~ ^(-?[[:digit:]]+)(:([[:digit:]]+)?)?$ ]]; then
                        printf "Invalid field string '%s'\n%s\n" "$field" "$use" >&2
                        return 3
                    fi
                    # get regex match groups - field, range,
                    local sel="${BASH_REMATCH[1]}"
                    local len="${BASH_REMATCH[3]:-${BASH_REMATCH[2]}}"
                    if [ -z "$len" ]; then
                        # N - one specific field
                        fields+=("${toks[$sel]}")
                    elif [ "$len" == ":" ]; then
                        # N: - a slice of fields
                        fields+=("${toks[@]:$((sel))}")
                    else
                        # N:X - a range of fields
                        if [[ "$len" -lt 1 ]]; then
                            printf "Invalid range '%s'\n" "$len" >&2
                            return 3
                        fi
                        fields+=("${toks[@]:$((sel)):$((len))}")
                    fi
                    # reset field
                    field=""
                    ;;&
                '}') # end variable
                    mode="text"
                    # add selected fields to output
                    local more=""
                    fmt="${fmt:-$pto}"
                    if [ "$fmt" == "C" ]; then
                        more=$(printf "%s " "${fields[@]}")
                    else
                        more=$(eval "printf \"%s \" \"\${fields[@]@$fmt}\"")
                    fi
                    fmt=""
                    # add selected fields to output
                    out+="${more%${more##*[![:space:]]}}"
                    ;;
                '@') # field transformation string
                    case "$next" in
                        [CEPQ]) # accept transform formats
                            fmt="$next"
                            (( index++ ))
                            ;;
                        *) # anything else is an error
                            printf "Invalid format string '%s'\n%s\n" "$next" "$use" >&2
                            return 3
                            ;;
                    esac
                    ;;
                ',') # field selection continues
                    ;;
                *) # invalid
                    printf "Could not parse character '%s' at index %d.\n\n%s\n" "$char" "$index" "$use" >&2
                    return 3
                    ;;
            esac
        fi
        # next character
        (( index++ ))
    done
    # check if parsing ended cleanly
    if [[ "$mode" == "var" ]]; then
        printf "Unclosed variable delimeter?\n%s\n" "$use"  >&2
        return 3
    fi
    # strip leading and trailing whitespace
    out="${out##*()}"
    out="${out%${out##*[![:space:]]}}"
    # write it
    printf "%s\n" "${out}"
}

req() {
    read -r -d '' use <<EOF
req COMMAND/FILE [...]
Require given files and commands.
Succeed iff each given argument is a known command or readable file.
Use this function to define program requirements in other functions.
For example: req awk /etc/passwd || return 5
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # consider each argument as a file or command
    local mis=0
    local arg=""
    for arg in "$@"; do
        if [ -r "$arg" ]; then continue; fi
        if type "$arg" &>/dev/null; then continue; fi
        ((mis++))
        printf "%s -- %s is required!\n" "${FUNCNAME[1]}" "$arg" >&2
    done
    # fail if any argument is missing
    ! ((mis))
}

rleval() {
    read -r -d '' use <<EOF
rleval [OPTIONS] COMMAND [ARGS ...]
Template given command with tokens from the readline buffer then...
 -i : insert its output into the readline buffer at cursor point.
 -w : replace the word at cursor point with its output.
 -r : run the command attached to the terminal.

This function is intended to be used with the bash builtin 'bind -x'.
The command is templated with the function 'nth'. See 'nth -h'.
The string '{0}' is replaced with the word at cursor point.
The string '{N}' is replaced with the token at numeric index N starting at 1.

EXAMPLES
 Insert the first token from the current readline buffer:
 $ bind -x '"\C-x0":rleval -i echo {1}'

 Insert fortunes on demand:
 $ bind -x '"\C-xf":rleval -i fortune"'

 Replace the current word with a generated password:
 $ bind -x '"\C-xp":rleval -w pwgen 20 1'

 Replace the current word with itself reversed:
 $ bind -x '"\C-xt":rleval -w "rev <<< {0}"'

 Encode and decode base64 strings at cursor point:
 $ bind -x '"\C-xb":rleval -w "base64 <<< {0}"'
 $ bind -x '"\C-xB":rleval -w "base64 -d <<< {0}"'

 Open the man page for the topic at cursor point:
 $ bind -x '"\C-xh":rleval -r man {0}'
EOF
    # accept options
    local mode='insert'
    local opt OPTIND OPTARG
    while getopts ":irwh" opt; do
        case "$opt" in
            i) mode='insert' ;;
            r) mode='run'  ;;
            w) mode='word' ;;
            *)
                printf "%s\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # require command argument
    local args="$*"
    if ! (($#)); then
        printf "%s\n" "$use" >&2
        return 1
    fi
    # require readline context
    local line="$READLINE_LINE" pt="$READLINE_POINT"
    if [ -z "$pt" ]; then
        printf "%s only works with 'bind -x'!\n%s\n" "${FUNCNAME[0]}" "$use" >&2
        return 2
    fi
    # record current readline point
    local before="${line:0:$pt}"
    local after="${line:$pt}"
    # tokenize current readline line
    local toks=()
    read -r -a toks <<< "$line"
    # determine word at point
    local beg=0 end=0 ins=0 word=""
    if [[ "${line:$pt:1}" == ' ' ]]; then
        # insert a word if point is on a space
        beg="$pt"
        end="$pt"
        ins=1
    else
        # replace word at point if on a non-space character
        local x=0
        # find the beginning of the word
        beg=0
        for ((x="$pt"; x>=0; x--)); do
            if [[ "${line:$x:1}" == ' ' ]]; then
                beg=$((x + 1))
                break
            fi
        done
        # find the end of the word
        end="${#line}"
        for ((x="$pt"; x<="${#line}"; x++)); do
            if [[ "${line:$x:1}" == ' ' ]]; then
                end="$x"
                break
            fi
        done
        # grab the word
        word="${line:$beg:$(( end - beg ))}"
    fi
    # tokenize current readline line
    local toks=()
    read -r -a toks <<< "$line"
    # render the command template
    local cmd=""
    if ! cmd=$(nth "$args" "${word/#\~/$HOME}" "${toks[@]/#\~/$HOME}"); then
        return 2
    fi
    # switch on program mode
    case "$mode" in
        insert)
            # run the command capturing output
            local str=""
            if ! str=$(eval -- "$cmd"); then
                return 3
            fi
            # no output? no change
            if [ -z "$str" ]; then
                return 3
            fi
            # update the readline buffer
            READLINE_LINE="${before}${str}${after}"
            ((READLINE_POINT += ${#str}))
            ;;
        run)
            # run command attached to the terminal
            eval -- "$cmd" < /dev/tty
            ;;
        word)
            # run command
            local str=""
            if ! str=$(eval -- "$cmd"); then
                return 3
            fi
            # no change if output empty
            if [ -z "$str" ]; then
                return 3
            fi
            # wrap inserted words in spaces
            if ((ins)); then
                str=" ${str} "
            fi
            # update the readline buffer
            READLINE_LINE="${line:0:$beg}${str}${line:$end}"
            READLINE_POINT=$((beg + ${#str}))
            ;;
    esac
}

###

cz() {
    # version
    local ver="0.6"
    # usage
    local hows="" use=""
    read -r -d '' use <<EOF
cz [OPTIONS] < LINES
Select a line from input interactively.

cz [OPTIONS] [PLUGIN] [ARGS ...]
Run a plugin to select something application specific.

OPTIONS
 These options print some information and exit:
  -h : help     : Print this help text or help text for plugin.
  -H : example  : Print a bunch of example commands.
  -k : tools    : List supported line selection tools.
  -l : plugins  : List detected plugins.
  -v : version  : Print version string.

 These options set the program mode. Select a line then...
  -p : print    : Print the line. This is the default mode.
  -q : quote    : Print fields extracted from the line.
  -r : run      : Run a command templated with fields from the line.
  -s : simulate : Print a string templated with fields from the line.

 General options:
  -c            : Use newly generated input not cached lines.
  -d DELIMITER  : Set field splitting characters for selected line.
  -e TEMPLATE   : Set command template. This option implies mode '-r'.
  -f FIELDS     : Set field template. This option implies mode '-q'.
  -g            : Buffer stdin and pass it to command set with '-e'.
  -i IN-FILE    : Set file from which to read selections instead of stdin.
  -o            : Only print input lines instead of selecting a line.
  -x            : Use a graphical line selection tool.
  -y            : Use a terminal line selection tool.
  -z TOOL       : Use the given line selection tool.
  -0            : Read null terminated lines from input.

TOOLS
 Cz provides a common interface to multiple interactive line selection tools.
 The suported tools are dmenu, fzf, fzy, iselect, pick, pipedial, rofi, selecta,
  sentaku, slmenu, and vis-menu.

TEMPLATES
 Substrings of TEMPLATE in the following formats are replaced with
  one or more fields from a selected line split by DELIM.
     {X}     - field X
     {X:}    - fields X through end of fields
     {X:Y}   - fields X through X + Y
     {X,Y,Z} - fields X, Y, and Z

 Append @C, @E, @P, or @Q to transform selected fields:
  @C - Insert argument directly. This is risky for command strings!
  @E - Replace backslash escape sequences in arguments with bash $'...' quotes.
  @P - Expand arguments for use in prompt strings.
  @Q - Quote arguments for use in command input. This is the default.

 FIELDS consists of one of the above without the enclosing '{}'.

ENVIRONMENT
 CZ_GUI         : preferred interface - 1=graphical 0=terminal
 CZ_BINS_GUI    : list of graphical utilities in order of preference
 CZ_BINS_TTY    : list of terminal utilities in order of preference
 CZ_DMENU_COLOR : Colon separated colors for dmenu (NF:NB:SF:SB)
EOF
    # example commands
    local hows=()
    mapfile -t hows <<EOF
Pick from lines on stdin.:$ printf "%s\n" foo bar qux | cz
Accept null delimited input lines.:$ find . -name '*.yml' -print0 | cz -0
Extract useful fields from selected line.:$ cz -q -f 0,5 -d : < /etc/passwd
Safely handle input strings containing shell characters.:$ cz -e 'echo {0:}' -i <(printf "%s\n" '\$USER' '; false' '\$(fortune)')
Add selection to common commands.:$ cz -r -e 'dig {0} AAAA +short' compgen hostname
Easily define plugins as bash functions.:$ cz_whois() { cz -e 'whois {0}' -f 0 compgen hostname; }; cz whois
Select a password and put it on an xclip clipboard.:$ cz pass | cz xclip in
Jump to any descendant directory.:$ cd \$(cz find dir)
Grab a URL from a paste buffer and open it in a browser.:$ cz xclip out | cz -e 'firefox {0}' uri
Compose plugins to get the contents of any element from any JSON file.:$ cz -e 'cz jq {0}' locate *.json
Compose plugins to get any file under an apparix bookmarked directory.:$ cz -e 'cz -q find file {1}' apparix
Find a file then open it for editing:$ find . -type f -print0 | cz -0 -r -e 'vim {0}' 
EOF
    # supported tools
    read -r -d '' exes <<EOF
dmenu     https://tools.suckless.org/dmenu
fzf       https://github.com/junegunn/fzf
fzy       https://github.com/jhawthorn/fzy
iselect   http://www.ossp.org/pkg/tool/iselect
pick      https://github.com/mptre/pick
pipedial  https://code.reversed.top/user/xaizek/pipedial
rofi      https://github.com/davatorium/rofi
selecta   https://github.com/garybernhardt/selecta
sentaku   https://github.com/rcmdnk/sentaku
slmenu    https://bitbucket.org/rafaelgg/slmenu
vis-menu  https://github.com/martanne/vis
EOF
    # append one random example to usage text
    local des="" exp=""
    IFS=: read -r des exp <<< "${hows[$(( RANDOM % ${#hows[@]} ))]}"
    use+=$(printf "\n\nEXAMPLES\n %s\n %s\n" "$des" "$exp")
    # here are the supporterd line selection tools
    local gbins=() tbins=()
    read -r -a gbins <<< "${CZ_BINS_GUI:-dmenu rofi}"
    read -r -a tbins <<< "${CZ_BINS_TTY:-fzf fzy pick pipedial selecta sentaku iselect slmenu vis-menu}"
    # determine type of interface for line selection tool
    local app="" gfx=""
    IFS=: read -r gfx app _ <<< "${CZ_GUI:-2}"
    if [ -z "$DISPLAY" ]; then gfx=0; fi
    # set options from the environment
    local tpl="${CZ_TEMPLATE}" # string template
    local fld="${CZ_FIELDS}"   # string field selection
    local mode="${CZ_MODE}"    # integer program mode
    local help="${CZ_HELP}"    # string indicator for help requested
    local dlm="${IFS}"         # string delimeter to split selected line
    # set option defaults
    local inp="/dev/stdin"     # string file from which to select a line
    local buf=0                # boolean require buffered stdin for command
    local run=""               # string program mode implied by another option
    local nul=0                # boolean whether to read null separated lines
    local clr=0                # boolean whether to refresh cached input lines
    # accept options
    local opt OPTIND OPTARG
    while getopts ":cd:e:f:ghHi:lkopqrsvxyz:0" opt; do
        case "$opt" in
            c) # clear hold caches
                clr=1
                ;;
            d) # set delimeter string
                dlm="$OPTARG"
                ;;
            e) # set template to format command
                tpl="${tpl:-$OPTARG}"
                run=2
                ;;
            f) # set fields to be extracted
                fld="${fld:-${OPTARG}}"
                run=1
                ;;
            g) # enable buffered stdin for command
                buf=1
                ;;
            h) # enable help mode
                help="YES PLEASE"
                ;;
            H) # list usage examples
                local ind
                for ((ind=0; ind < "${#hows[@]}"; ind++)); do
                    IFS=: read -r des exp <<< "${hows[$ind]}"

                    printf "%s\n%s\n\n" "$des" "$exp"
                done
                return 0
                ;;
            i) # set input file from which to read selections
                inp="$OPTARG"
                if ! [ -r "$inp" ]; then
                    printf "%s\n" "Input file is unreadable!" >&2
                    return 2
                fi
                ;;
            l) # list available plugins
                while read -r f; do
                    if [[ "$f" == cz_* ]]; then
                        printf "%s\n" "${f##cz_}"
                    fi
                done < <(compgen -c) | sort
                return 0
                ;;
            k) # list supported tools
                printf "%s\n" "$exes"
                return 0
                ;;
            o) # just print lines without interactive selection
                mode=-1
                ;;
            p) # print selected line instead of running anything
                mode=0
                ;;
            q) # print string from '-f' templated using fields from the selected line
                mode=1
                ;;
            r) # execute string from '-e' templated using fields from the selected line
                mode=2
                ;;
            s) # print string from '-e' templated using fields from the selected line
                mode=3
                ;;
            0) # handle null separated input
                nul=1
                ;;
            v) # write version
                printf "cz %s\n" "$ver"
                return 0
                ;;
            x) # try to use a graphical tool for line selection
                gfx=1
                ;;
            y) # try to use a terminal tool for line selection
                gfx=0
                ;;
            z) # use a specific line selection tool
                app="$OPTARG"
                if ! [[ " ${gbins[*]} ${tbins[*]} " == *" ${app} "* ]]; then
                    printf "Unknown tool %s\n" "$app" >&2
                    return 2
                fi
                ;;
            \?) # invalid option?
                printf "Bad option: -%s\n%s\n" "$OPTARG" "$use" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # determine an available line selection tool
    local got=""
    if [ -z "$app" ]; then
        # graphical or terminal
        local tools=()
        case "$gfx" in
            0) tools=("${tbins[@]}") ;;
            1) tools=("${gbins[@]}") ;;
            *) tools=("${gbins[@]}" "${tbins[@]}") ;;
        esac
        # use first available tool
        for app in "${tools[@]}"; do
            if type "$app" &>/dev/null; then
                got="$app"
                break
            fi
        done
        app="$got"
        # no tools found
        if [ -z "$got" ]; then
            printf "No line selection tools found!\nTry installing one of these:\n" >&2
            printf "%s\n" "${tools[@]}" | sort >&2
            return 5
        fi
    fi
    # program mode might have been implied
    mode="${mode:-$run}"
    # plugins - any command in the format 'cz_$WORD'
    if [ -n "$*" ]; then
        # determine if a known plugin is given
        local args=("$@") plug="" word=0
        for ((word=${#args[@]}; word>0; word--)); do
            plug="${args[*]:0:$word}"
            plug="cz_${plug// /_}"
            if type "$plug" >&/dev/null; then break; fi
            plug=""
        done
        # bail out for invalid plugins
        if [ -z "$plug" ]; then
            printf "No plugin matching '%s'.\n" "$*" >&2
            return 2
        fi
        shift "$word"
        # run the plugin with override environment variables
        (
            export CZ_GUI="${gfx}:${app}"
            export CZ_HELP="$help"
            export CZ_MODE="$mode"
            export CZ_FIELDS="$fld"
            export CZ_TEMPLATE="$tpl"
            export HOLD_CLEAR="$clr"
            "$plug" "$@"
        )
        echo "$CZ_TEMPLATE"
        return $?
    fi
    # maybe help was requested
    if [ -n "$help" ]; then
        printf "%s\n" "$use" >&2
        return
    fi
    # read selection file
    declare -a lines
    declare -a items
    if ((nul)); then
        mapfile -d '' -t lines < "$inp"
        mapfile -t items < <(printf "%q\n" "${lines[@]}")
    else
        mapfile -t lines < "$inp"
        mapfile -t items < <(printf "%s\n" "${lines[@]}")
    fi

    # require at least one non-empty line
    if ! (("${#lines[@]}")); then
        return 3
    fi
    # buffer stdin if reading selection input from another file
    # this is needed to pass input to templated commands
    declare -a stdin
    if [[ "$inp" != "/dev/stdin" ]] && ! [ -t 0 ]; then
        mapfile -t stdin
        # optionally require actual input lines
        if ((buf)) && ! ((${#stdin})); then return 4; fi
    fi
    # maybe just dump selections
    if (( mode < 0 )); then
        printf "%s\n" "${items[@]}"
        return 0
    fi
    # choose a line using a known program
    local out
    out=$(case "$app" in
              dmenu)
                  local color="${CZ_DMENU_COLOR:-black:gray:white:black}"
                  IFS=':' read -r nf nb sf sb <<< "$color"
                  dmenu -i -l 30 -nf "$nf"  -nb "$nb" -sf "$sf"  -sb "$sb"
                  ;;
              fzf      ) fzf ;;
              fzy      ) fzy ;;
              iselect  ) iselect -a ;;
              pick     ) pick ;;
              rofi     ) rofi -i -dmenu -p "" ;;
              pipedial ) pipedial ;;
              selecta  ) selecta --height=full ;;
              sentaku  ) sentaku -s $'\n' | head -n1 ;;
              slmenu   ) slmenu -i -l 30 ;;
              vis-menu ) vis-menu -i -l 30 ;;
              chuz     ) chuz ;;
              * )
                  printf "Unknown tool %s.\n" "$app" >&2
                  return 2
                  ;;
          esac < <(printf "%s\n" "${items[@]}")
       ) || return 4
    # require that selector succeeded and got a line
    if [ -z "$out" ]; then
        return 4
    fi
    # expand shell quoted line
    if ((nul)); then
        out=$(eval printf "%s" "$out")
    fi
    # tokenize selected line for use in templates
    local cmd=""
    local toks=()
    IFS="$dlm" read -r -a toks <<< "$out"
    # set harmless defaults for template arguments
    tpl="${tpl:-echo {0:\}}"
    fld="${fld:-0:}"
    # do something with the selection depending on mode
    case "${mode:-0}" in
        0) # print selection
            printf "%s\n" "$out"
            ;;
        1) # print some fields extracted from the line
            if ! out="$(nth -p "{${fld}}" "${toks[@]}" 2>/dev/null)"; then
                printf "Failed to parse template: %s\n" "$fld" >&2
                return 5
            fi
            printf "%s\n" "$out"
            ;;
        2) # template the command string then run it
            if ! cmd="$(nth "${tpl}" "${toks[@]}" 2>/dev/null)"; then
                printf "Failed to parse template: %s\n" "$tpl" >&2
                return 5
            fi
            (
                # reset environment for possible nested call
                export CZ_MODE=""
                export CZ_FIELDS=""
                export CZ_TEMPLATE=""
                export CZ_GUI="${gfx}:${app}"
                # eval the command
                if ((${#stdin})); then
                    # maybe pass buffered input
                    eval "$cmd" < <(printf "%s\n" "${stdin[@]}")
                elif [ -n "$PS1" ]; then
                    # if interactive ensure terminal is attached
                    eval "$cmd" < /dev/tty
                else
                    # non-interactive mode has no terminal
                    eval "$cmd"
                fi
            )
            return $?
            ;;
        3) # template the command string and print it
            if ! cmd="$(nth "${tpl}" "${toks[@]}")"; then
                printf "Failed to parse template.\n%s\n" "$tpl" >&2
                return 4
            fi
            printf "%s\n" "$cmd"
            ;;
    esac
}

# cz command completion
function _cz() {
    local reply=()
    # get lists of supported tools and plugins
    local tools=() plugs=()
    mapfile -t tools < <(cz -k)
    mapfile -t plugs < <(cz -l)
    # cz has some options
    local opt="" opts
    declare -A opts
    for opt in -{d,e,f,h,i,l,k,o,p,q,r,s,v,x,y,z,0}; do opts["$opt"]=0; done
    # scan all previous words
    local base="" last="" word="" i=0
    for ((i=1; i < "$COMP_CWORD"; i++)); do
        # step through words
        word="${COMP_WORDS[$i]}"
        last="${COMP_WORDS[$i-1]}"
        # have options ended?
        if [[ "$word" =~ ^-[[:alnum:]]$ ]]; then
            # record options already seen
            unset opts["$word"]
        elif [[ "$word" =~ ^[[:alnum:]]+ ]]; then
            # maybe this is an argument to an option
            if [[ "$last" =~ ^-[defiz]$ ]]; then continue; fi
            opts=()
            # concat plugin prefix
            base="${base}_${word}"
            base="${base##_}"
        fi
    done
    # current and previous words are given
    local curr="${2}" prev="${3}"
    # maybe the previous word is a redirection
    local rd='^[&12]?[><]'
    if [[ "$prev" =~ $rd ]]; then
        mapfile -t reply < <(compgen -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # maybe the previous word is an option that expects an argument
    if [[ "$prev" =~ ^-[defiz]$ ]]; then
        case "$prev" in
            -d) reply=(); ;;
            -e) mapfile -t reply < <(compgen -c -- "$curr") ;;
            -f) mapfile -t reply < <(compgen -W "0 1 2 3 4 5 6 7 8 9" -- "$curr") ;;
            -i) mapfile -t reply < <(compgen -f -- "$curr") ;;
            -z) mapfile -t reply < <(compgen -W "${tools[*]%% *}"  -- "$curr") ;;
        esac
        COMPREPLY=("${reply[@]}")
        return
    fi
    # first complete initial command token and options
    if [ -z "$base" ]; then
        mapfile -t reply < <(compgen -W "${!opts[*]} ${plugs[*]%%_*}" -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # determine next command token
    local next=() pat="^${base}_([[:alnum:]]+)"
    for plug in "${plugs[@]}"; do
        if [[ "$plug" =~ $pat ]]; then
            next+=("${BASH_REMATCH[1]%%_*}")
        fi
    done
    # maybe complete next command token
    if (("${#next[@]}")); then
        mapfile -t reply < <(compgen -W "${next[*]}" -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # TODO maybe complete something specific for a plugin
    case "$base" in
        *) return ;;
    esac
}
complete -F _cz cz

cz_meta() {
    { hep "$CZ_HELP" && return; } <<EOF
cz meta [MODE-OPTION] [PREFIX]
Select a cz plugin and run it in the given mode.
The mode options are -p -q -r -s. The default mode is -p.
This plugin is best used bound to a key, providing a quick
 interface to every other cz plugin.

EXAMPLES
 $ bind -x '"\C-xx":rleval "cz meta -q"' # insert field
 $ bind -x '"\C-xX":rleval "cz meta -p"' # insert line
 $ bind -x '"\C-xz":rleval "cz meta -r"' # insert command output
 $ bind -x '"\C-xZ":rleval "cz meta -s"' # insert command
EOF
    local mode="-p"
    local opt OPTIND OPTARG
    while getopts ":pqrs" opt; do
        case "$opt" in
            [pqrs])
                mode="-$opt"
                ;;
            \?)
                printf "Bad option: -%s\n" "$OPTARG" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    cz -f 0 -e "cz ${mode} {0}" -i <(compgen -W "$(cz -l)" -- "$1")
}

####

cz_argv() {
    { hep "$CZ_HELP" && return; } <<EOF
$ cz argv [ARGS]
Select from given arguments.
EOF
    cz -i <(printf "%s\n" "$@")
}

cz_anagram() {
    { hep "$CZ_HELP" && return; } <<EOF
cz anagram TEXT [WORDS]
Select from anagrams of TEXT.
Optionally limit to a maximum number of WORDS.
EOF
    req an || return 5
    if [ -z "$1" ]; then return 2; fi
    cz -i <(an -l "${2:-3}" "$1")
}

anc() {
    local dir="${1:-$PWD}"
    if ! [ -d "$dir" ]; then return 2; fi;
    local toks=()
    IFS=/ read -ra toks <<< "${dir#/}"
    local seg="" cur="" idx=0
    for ((idx=0; idx<=${#toks[@]}; idx++)); do
        seg="${toks[$idx]}"
        printf "%s\n" "${cur:-/}"
        cur="${cur}/${seg}"
    done
}

cz_ancestor() {
    { hep "$CZ_HELP" && return; } <<EOF
$ cz ancestor [DIRECTORY]
Select from parent directories.
EOF
    local d="${1:-$PWD}"
    if ! [ -d "$d" ]; then return 2; fi;
    cz -d '' -f 0: -i <(anc "$d")
}

cz_ansible_group() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ansible group
Select a group from an ansible inventory then draw a graph of its members.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --graph {0}' \
       -i <(ansible-inventory --list | \
                jq -r '. | keys[] | select(. | test("^_") | not)')
}

cz_ansible_host() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ansible host
Select a host from an ansible inventory then print its variables as JSON.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --host {0}' \
       -i <(ansible-inventory --list | \
                jq -r '[.[] | select(.hosts!=null) | .hosts[]] | flatten | unique[]')
}

cz_ansible_doc() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ansible doc
Select from ansible documentation topics.
EOF
    req ansible-doc || return 5
    cz -f 0 -e "ansible-doc {0}" < <(ansible-doc -l)
}

cz_apparix() {
    { hep "$CZ_HELP" && return; } <<EOF
cz apparix
Select from apparix bookmarks.
EOF
    req apparix awk || return 5
    cz -f 1 -i <(apparix | awk '/^j/ { print $2, $3 }')
}

cz_apparix_file() {
    { hep "$CZ_HELP" && return; } <<EOF
cz apparix file
Select from files within selected apparix bookmark directory.
EOF
    local dir
    dir="$(CZ_MODE="" CZ_FIELDS="" cz -q apparix)"
    if [ -z "$dir" ]; then return 2; fi
    cz find file "$dir"
}

cz_apt_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz apt package [QUERY]
Select from apt package listings matching QUERY.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' \
       -i <(apt-cache search "$qry")
}

cz_apt_installed() {
        { hep "$CZ_HELP" && return; } <<EOF
cz apt installed
Select from installed apt packages.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' \
       -i <(dpkg --get-selections | awk '$2 == "install" { print $1 }')
}

cz_bash_alias() {
        { hep "$CZ_HELP" && return; } <<EOF
cz bash alias
Select from defined bash aliases.
EOF
    cz -i <(alias)
}

cz_bash_bind_function() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash bind function
Select from bash internal readline functions.
EOF
    cz -i <(bind -l)
}

cz_bash_bind_key() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash bind key
Select from bash key bindings.
EOF
    cz -d : -f 0 -i <({ bind -p; bind -X; bind -s; } | grep -v '^#')
}

cz_bash_completion() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash completion
Select from bash completion function configuration.
EOF
    cz -i <(complete -p)
}

cz_bash_help() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash help
Select from bash help topics.
EOF
    mapfile -t m < <(help -s '*')
    cz -f 0 -e 'help {0}' -d : -i <(printf "%s\n" "${m[@]:2}")
}

cz_bash_job() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash job
Select a bash background job and move it to the foreground.
EOF
    cz -d $'\t' -f 1 -e 'fg {1}' -i <(
        while read -r s p q c; do
            [[ "$s" =~ ^\[([0-9]+)\]([+-])?$ ]]
            printf "%s\t%s\t%s\t%s\t%s\n" "${BASH_REMATCH[2]:-.}" "%${BASH_REMATCH[1]}" "$p" "$q" "$c"
        done < <(jobs -l))
}

cz_bash_history() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bash history
Select a command from bash history then run it.
EOF
    req sort || return 5
    cz -f '3:@C' -e "{3:@C}" \
       -i <(HISTTIMEFORMAT="%F %T " history | sort -r -n)
}

cz_bluetooth_device() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bluetooth device
Select from known bluetooth devices.
EOF
    req bluetoothctl || return 5
    cz -f '1@C' -e 'bluetoothctl info {1}' \
       -i <(bluetoothctl devices)
}

cz_bool() {
    { hep "$CZ_HELP" && return; } <<EOF
cz bool
Select a true or false value.
EOF
    cz -e 'let {2}' -f 0 -i <(printf "%s\n" "true yes 1" "false no 0")
}

cz_buku() {
    { hep "$CZ_HELP" && return; } <<EOF
cz buku [QUERY]
Select a buku bookmark then open it in a browser.
EOF
    req buku sed || return 5
    cz -e 'buku -o {0}' -f 1 -i <(buku -p -f 4 | sed '/^[0-9]/!d;y/\t/ /' )
}

declare n=""
while read -r n _; do
    eval "cz_compgen_$n() { \
    { hep \"\$CZ_HELP\" && return; } <<EOF
cz compgen $n [PREFIX]
Select from bash builtin $n completion.
EOF
cz -i <(compgen -A $n -- \"\$1\" | sort);\
}"
done <<EOF
alias
arrayvar
binding
builtin
command
directory
disabled
enabled
export
file
function
group
helptopic
hostname
job
keyword
running
service
setopt
shopt
signal
stopped
user
variable
EOF
unset n

cz_command() {
    { hep "$CZ_HELP" && return; } <<EOF
cz command
Select a command and run it.
EOF
    cz -ge '{0}' -f 0 compgen command
}

cz_descendant() {
    { hep "$CZ_HELP" && return; } <<EOF
$ cz ancestor [DIRECTORY]
Select from parent directories.
EOF
    local d="${1:-$PWD}"
    if ! [ -d "$d" ]; then return 2; fi
    cz find dir
}

cz_dict_strategy() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dict strategy
Select a dict server search strategy.
EOF
    req dict sed || return 5
    cz -f 0 -i <(dict -S | sed 1d)
}

cz_dict_word() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dict word [QUERY]
Select a word from a dict server and print its definition.
EOF
    req dict || return 5
    local qry="${1:-.*}"
    cz -f 3: -e 'dict -- {3:}' -i <(dict -m -f -s re "$qry")
}

cz_dnf_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dnf package
Select a dnf package by name then print info about it.
EOF
    req dnf sed || return 5
    cz -f 0 -e 'dnf info {0}' -i <(dnf list 2>/dev/null | sed 1,2d)
}

cz_dns_rtype() {
    { hep "$CZ_HELP" && return; } <<EOF
cz dnf package
Select a DNS rdata type.
EOF
    local rtypes=(A AAAA AFSDB APL CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME
                  DNSKEY DS HINFO HIO IPSECKEY KEY KX LOC MX NAPTR NS NSEC NSEC3
                  NSEC3PARAM OPENPGPKEY PTR RRSIG RP SIG SMIMEA SOA SRV SSHFP TA
                  TKEY TLSA TSIG TXT URI
                  IXFR AXFR OPT)
    cz -i <(printf "%s\n" "${rtypes[@]}")
}

cz_docker_container() {
    { hep "$CZ_HELP" && return; } <<EOF
cz docker container
Select a docker container.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker inspect {0}' \
       -i <(docker container ls -a | sed 1d)
}

cz_docker_image() {
    { hep "$CZ_HELP" && return; } <<EOF
cz docker image
Select a docker image.
EOF
    req docker sed || return 5
    cz -f 2 -e 'docker inspect {2}' \
       -i <(docker images -a | sed 1d)
}

cz_docker_ps() {
    { hep "$CZ_HELP" && return; } <<EOF
cz docker ps
Select a running docker container process.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker inspect {0}' \
       -i <(docker ps | sed 1d)
}

cz_env() {
    { hep "$CZ_HELP" && return; } <<EOF
cz env
Select an environment variable.
EOF
    req env || return 5
    cz -0 -d '=' -f 0 -e "printf '%s\n' \"\${0}\"" \
       -i <(env -0)
}

cz_fc_font() {
    { hep "$CZ_HELP" && return; } <<EOF
cz fc font
Select a font file known to fontconfig.
EOF
    req fc-list || return 5
    cz -f 0 -d ':' -i <(fc-list)
}

cz_ffmpeg_format() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ffmpeg format
Select from data formats supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -formats | sed 1,4d)
}

cz_ffmpeg_encoder() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ffmpeg encoder
Select from encoders supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -encoders | sed 1,10d)
}

cz_ffmpeg_decoder() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ffmpeg decoder
Select from decoders supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -decoders | sed 1,10d)
}

cz_figlet_font() {
    { hep "$CZ_HELP" && return; } <<EOF
cz figlet font
Select a font file usable by figlet.
EOF
    req figlet || return 5
    local fdir="${FIGLET_FONTDIR:-/usr/share/figlet}"
    cz -f 0 -ge "figlet -t -d $fdir -f {0}" \
       -i <(for f in "$fdir"/*.{flf,tlf}; do
                printf "%s %s\n" "${f##*/}" "${f}"
            done)
}

cz_find_file() {
    { hep "$CZ_HELP" && return; } <<EOF
cz find file [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    req find || return 5
    cz -d '' -0 -f '0@Q' -i <(find -L "${@:-.}" -iwholename "*${2}*" -type f -print0)
}

cz_find_dir() {
    { hep "$CZ_HELP" && return; } <<EOF
cz find dir [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    req find || return 5
    cz -d '' -0 -f '0@Q' -i <(find -L "${@:-.}" -iwholename "*${2}*" -type d -print0)
}

cz_firefox_tab() {
    { hep "$CZ_HELP" && return; } <<EOF
cz firefox tab
Select an open firefox tab.
EOF
    req column firefox jq lz4jsoncat || return 5
    local db=("$HOME"/.mozilla/firefox/*.default/sessionstore-backups/recovery.jsonlz4)
    if [ -z "${db[0]}" ]; then
        return 3
    fi
    cz -f 0 -i <(lz4jsoncat "${db[0]}" | \
                     jq -r '.windows[].tabs[].entries[] |  [.url,.title] | @tsv' | \
                     column -t -s $'\t')
}

cz_flatpak_app() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak app
Select an application installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --app)
}

cz_flatpak_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak package [REMOTE]
Select a package available at the given REMOTE then install it.
EOF
    req flatpak || return 5
    local r="";
    if ! r="${1:-$(cz -f 0 flatpak remote)}"; then
        return 4
    fi
    cz -f 0 -e "flatpak install $r {0}" -i <(flatpak remote-ls "$r")
}

cz_flatpak_remote() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak remote
Select a flatpak remote repository by name.
EOF
    req flatpak || return 5
    cz -i <(flatpak remote-list)
}

cz_flatpak_runtime() {
    { hep "$CZ_HELP" && return; } <<EOF
cz flatpak runtime
Select a runtime installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --runtime)
}

cz_gcloud_auth() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud auth
Select an available google cloud identity.
EOF
    req gcloud jq || return 5
    cz -f 0 -i <(gcloud auth list --format=json | jq -r '.[] | [.account, .status] | @tsv')
}

cz_gcloud_bucket() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bucket
Select a google cloud storage bucket.
EOF
    req gsutil || return 5
    cz -i <(gsutil ls)
}

cz_gcloud_bucket_file() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bucket file [BUCKET]
Select a file from a google cloud storage bucket.
EOF
    req gsutil || return 5
    local b="${1:-$(CZ_FIELDS="" CZ_MODE="" cz -q gcloud bucket)}"
    if [ -z "$b" ]; then return 2; fi
    cz -f 2 -i <(gsutil ls -lr "$b"'**' | sed '$d')
}

cz_gcloud_bq_dataset() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bq dataset [PROJECT]
Select a Google Bigquery dataset from PROJECT and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(CZ_FIELDS="" CZ_MODE="" cz -q gcloud project)}"
    cz -f 0 -i <(bq --format json --project_id "$proj" ls | \
                     jq -r '.[] | [.id, (.datasetReference | (.datasetId, .projectId)), .location] | @tsv')
}

cz_gcloud_bq_table() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud bq table [PROJECT] [DATASET]
Select a Google Bigquery table from DATASET in PROJECT and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then
        return 2
    fi
    local ds="${2:-$(cz -q gcloud bq dataset "$proj")}"
    if [ -z "$ds" ]; then
        return 2
    fi
    cz -f 0 -i <(bq --format json --project_id "$proj" ls "$ds" | \
                     jq -r '.[] | [.id, (.tableReference | (.tableId, .datasetId, .projectId)), .type] | @tsv')
}

cz_gcloud_compute_disk() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute disk [PROJECT]
Select a Google cloud compute disk in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project ${proj@Q} --format=json compute disks describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format=json compute disks list \
                | jq -r '.[] | [.id, .name, .zone, .sizeGb, .status] | @tsv')
}

cz_gcloud_compute_image() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT]
Select a Google cloud compute image in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute images describe {0} " \
       -i <(gcloud --project "$proj" --format json compute images list | \
                jq -r '.[] | [.name, .creationTimestamp ] | @tsv')
}

cz_gcloud_compute_instance() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute instance [PROJECT]
Select a Google cloud compute instance in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project ${proj@Q} --format json compute instances describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format json compute instances list \
                | jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .networkInterfaces[0].networkIP // "-", .accessConfigs[0].natIP // "-", .status] | @tsv')
}

cz_gcloud_compute_network() {
        { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute network [PROJECT]
Select a Google cloud network in PROJECT and describe it in JSON.
EOF
        req gcloud jq || return 5
        local proj="${1:-$(cz -q gcloud project)}"
        if [ -z "$proj" ]; then return 2; fi
        cz -f 0 -e "gcloud --project ${proj@Q} --format json compute networks describe {0}" \
           -i <(gcloud --project "$proj" --format json compute networks list \
                    | jq -r '.[] | [.name, .id, .creationTimestamp] | @tsv')
}

cz_gcloud_compute_region() {
        { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute region
Select a Google cloud region and describe it in JSON.
EOF
        req gcloud jq || return 5
        cz -f 1 -e 'gcloud compute regions describe {1}' \
           -i <(hold -ept 86400 -- gcloud --format=json compute regions list \
                    | jq -r '.[] | [.id, .name, .description] | @tsv')
}

cz_gcloud_compute_snapshot() {
        { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute snapshot
Select a Google cloud disk snapshot and describe it in JSON.
EOF
        req gcloud jq || return 5
        local proj="${1:-$(cz -q gcloud project)}"
        if [ -z "$proj" ]; then return 2; fi
        cz -f 1 -e "gcloud --project ${proj@Q} compute snapshots describe {1}" \
           -i <(gcloud --project "$proj" --format=json compute snapshots list \
                    | jq -r '.[] | [.id, .name, .status] | @tsv')
}

cz_gcloud_compute_subnet() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud subnet [PROJECT]
Select a Google cloud subnet from PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 2 -e "gcloud --project ${proj@Q} --format json compute networks subnets describe {2}" \
       -i <(gcloud --project "$proj" --format json compute networks subnets list \
                | jq -r '.[] | [(.region | split("/") | .[-1]), .name, .id, .gatewayAddress, .ipCidrRange, .purpose] | @tsv')
}

cz_gcloud_compute_zone() {
        { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute zone
Select a Google cloud zone and describe it in JSON.
EOF
        req gcloud jq || return 5
        cz -f 1 -e "gcloud compute zones describe {1}" \
           -i <(hold -ept 86400 -- gcloud --format=json compute zones list \
                    | jq -r '.[] | [.id, .name, .description] | @tsv')
}

cz_gcloud_dns_record() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT] [ZONE]
Select a Google cloud DNS record in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    local zone="${2:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud dns zone)}"
    if [ -z "$proj" ] || [ -z "$zone" ]; then return 2; fi
    cz -f 0,1 \
       -i <(gcloud --project "$proj" --format json dns record-sets list -z "$zone" | \
                jq -r '.[] | [.type, .name, .ttl, .rrdatas[]] | @tsv')
}

cz_gcloud_dns_zone() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud dns zone [PROJECT]
Select a Google cloud DNS zone in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json dns managed-zones describe {0}" \
       -i <(gcloud --project "$proj" --format json dns managed-zones list | \
                jq -r '.[] | [.name, .dnsName, .visibility, .description] | @tsv')
}

cz_gcloud_organization() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud organization
Select a Google cloud organization and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f 1 -e 'gcloud organizations describe {1} --format=json' \
       -i <(gcloud organizations list  --format=json | \
                jq -r '.[0] | [.creationTime, .name, .displayName, .lifecycleState ] | @tsv')
}

cz_gcloud_log() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud log [PROJECT]
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -i <(gcloud --format=json --project "${proj}" logging logs list | jq -r '.[]')
}

cz_gcloud_log_entry() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud log entry [PROJECT]
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    local log="${2:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud log "$proj")}"
    if [ -z "$log" ]; then return 2; fi

}

cz_gcloud_permission() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud permission [RESOURCE]
Select a Google cloud permission and describe it in JSON.
If a RESOURCE URL argument is given only list applicable permissions.
By default list all permissions on the selected organization.
EOF
    req gcloud jq || return 5
    local url="${1}"
    if [ -z "$url" ]; then
        local org=""
        if org=$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud organization); then
            url="//cloudresourcemanager.googleapis.com/$org"
        else
            return 2
        fi
    fi
    cz -f 0 \
       -i <(gcloud iam list-testable-permissions "$url" --format=json | \
                jq -r '.[] | [.name, .stage, .title // "-"] | @tsv')
}

cz_gcloud_pubsub_subscription() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud pubsub subscription [PROJECT]
Select a Google pubsub subscription in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json pubsub subscription describe {0}" \
       -i <(gcloud pubsub subscriptions list --format=json | \
                jq -r '.[] | [(.name | split("/") | .[-1]), (.topic | split("/") | .[-1]) ] | @tsv')
}

cz_gcloud_pubsub_topic() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud pubsub topic [PROJECT]
Select a Google pubsub topic in PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json pubsub topic describe {0}" \
       -i <(gcloud pubsub topics list --format=json | \
                jq -r '.[] | [.name | split("/") | .[-1] ] | @tsv')
}

cz_gcloud_project() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud project
Select a Google cloud project and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f '0@C' -e 'gcloud --format json projects describe {0}' \
       -i <(gcloud --format json projects list | jq -r '.[] | [.projectId, .projectNumber, .name] | @tsv')
}

cz_gcloud_role() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud role [PROJECT]
Select a Google cloud IAM role from PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json iam roles describe {0}" \
       -i <(gcloud --project "$proj" --format json iam roles list | \
                jq -r '.[] | [.name, .description] | @tsv')
}

cz_gcloud_serviceaccount() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gcloud serviceaccount [PROJECT]
Select a Google cloud service account from PROJECT and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(cz -q gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json iam service-accounts describe {0}" \
       -i <(gcloud --project "$proj" --format json iam service-accounts list | \
                jq -r '.[] | [.email, .displayName, .email] | @tsv')
}

cz_gh_gist() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gh gist
Select a Github gist and view it.
EOF
    req gh || return 5
    cz -e 'gh gist view {0}' -f 0 -i <(gh gist list)
}

cz_gh_issue() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gh issue
Select a Github issue and view it.
EOF
    req gh || return 5
    cz -e 'gh issue view {0}' -f 0 -i <(gh issue list)
}

cz_gh_pr() {
    { hep "$CZ_HELP" && return; } <<EOF
cz gh pr
Select a Github pull request and view it.
EOF
    req gh awk || return 5
    cz -e 'gh pr view {1}' -f 2 \
       -i <(gh pr list --limit 100 | awk -F $'\t' '{ print $4, $1, $3, $2 }' )
}

cz_git() {
    cz git status "$@"
}

cz_git_config() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git config [LOCATION]
Select from git configuration items.
Given a location list only items from the matching config.
Locations: global, local, worktree, system, and all - the default
EOF
    req git || return 5
    local scope="${1:-all}" type="${2}"
    local args=()
    case "$scope" in
        'all') : ;;
        'global') args+=('--global') ;;
        'local') args+=('--local') ;;
        'worktree') args+=('--worktree') ;;
        'system') args+=('--system') ;;
        *) printf "Unknown config location: %s\n" "$scope" >&2; return 2 ;;
    esac

    cz -d '=' -f 0 -e "git config ${args[*]} --get {0}" \
       -i <(git config "${args[*]}" -l)
}

cz_git_diff() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git diff [DIRECTORY] [BRANCH]
Select a file in git repo in the given directory that differs from the given
branch. If unspecified the branch will be selected interactively.
EOF
    req git || return 5
    local repo="${1:-.}"
    local branch="${2:-$(cz -q git branch "$repo")}"
    cz -f 0 -e "git -C '$repo' diff '$branch' -- {0}" \
       -i <(git -C "$repo" diff --name-only "$branch")
}

cz_git_status() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git status [DIRECTORY]
Select a modified file in the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 1 -e "git -C '$repo' diff {1}" \
       -i <(git -C "$repo" status -sbu | grep -v ^#)
}

cz_git_branch() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git branch [DIRECTORY]
Select a branch from the git repository in DIRECTORY.
EOF
    req git sed || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" branch -vv | sed 's/^[* ] //')
}

cz_git_commit() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git commit [DIRECTORY] [FILE]
Select a commit from the history of the git repository in DIRECTORY.
Given FILE, select a commit that modified that file.
EOF
    req git || return 5
}

cz_git_log() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git log [DIRECTORY] [FILE]
Select a commit from the history of the git repository in DIRECTORY.
Given FILE, select a commit that modified that file.
EOF
    req git || return 5
    local repo="${1:-.}"
    local file="${2:-.}"
    cz -f 0 -e "git -C $repo show {0}" \
       -i <(git -C "$repo" log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit -- "$file")
}

cz_git_file()  {
    { hep "$CZ_HELP" && return; } <<EOF
cz git file [DIRECTORY]
Select a file managed by the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 4: -i <(git -C "$repo" ls-tree -rl HEAD)
}

cz_git_remote() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git remote [DIRECTORY]
Select a remote repository known to the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 1 -i <(git -C "$repo" remote -v)
}

cz_git_tag() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git tag [DIRECTORY]
Select a tag from the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" tag)
}

cz_git_worktree() {
    { hep "$CZ_HELP" && return; } <<EOF
cz git worktree [DIRECTORY]
Select a worktree associated with the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" worktree list)
}

cz_grep() {
    { hep "$CZ_HELP" && return; } <<EOF
cz grep [PATTERN] [DIRECTORY]
Select a file matching PATTERN in DIRECTORY.
EOF
    req grep || return 5
    local pat="${1:-.}"
    local dir="${2:-.}"
    cz -d ':' -e "$EDITOR +{1@C} -- {0}" -f 0 \
       -i <(grep -rn -- "$pat" "$dir")
}

cz_help() {
    { hep "$CZ_HELP" && return; } <<EOF
cz help
Select a cz plugin and print its usage text.
EOF
    cz -e 'cz -h {0}' -i <(cz -l)
}

cz_haskell_package() {
    { hep "$CZ_HELP" && return; } <<EOF
cz haskell package
Select a haskell cabal package then show info about it.
EOF
    req cabal || return 5
    cz -e 'cabal info {0}' -f 0 \
       -i <(hold -ept 300 -- cabal list --simple-output)
}

cz_haskell_installed() {
    { hep "$CZ_HELP" && return; } <<EOF
cz haskell installed
Select an installed haskell cabal package then show info about it.
EOF
    req cabal || return 5
    cz -f 0 -e 'cabal info {0}' -f 0 \
       -i <(hold -ept 300 -- cabal list --installed --simple-output)
}

cz_hg_branch() {
    { hep "$CZ_HELP" && return; } <<EOF
cz hg branch [DIRECTORY]
Select a branch in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg -R "${1:-.}" branches)
}

cz_hg_revision() {
    { hep "$CZ_HELP" && return; } <<EOF
cz hg revision [DIRECTORY]
Select a revision in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg log -T '{rev} {branch} {user} {date} {desc|firstline}\n' "${1:-.}")
}

cz_hg_status() {
    { hep "$CZ_HELP" && return; } <<EOF
cz hg status [DIRECTORY]
Select a modified file in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 1 -i <(hg -R "${1:-.}" status)
}

cz_i3_bind() {
    { hep "$CZ_HELP" && return; } <<EOF
cz i3 bind
Select a bindsym from the current i3 configuration.
EOF
    req i3-msg grep sort || return 5
    cz -f 2: -i <(i3-msg -t get_config  | grep ^bindsym | sort)
}

cz_i3_mark() {
    { hep "$CZ_HELP" && return; } <<EOF
cz i3 mark
Select an i3 window mark then move focus to the marked window.
EOF
    req i3-msg jq || return 5
    cz -f 0 -e 'i3-msg "[con_mark={0@C}] focus"' \
       -i <(i3-msg -t get_marks | jq -r '.[]')
}

cz_i3_output() {
    { hep "$CZ_HELP" && return; } <<EOF
cz i3 output
Select an i3 recognized output device.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.[] | select(.active)
    | [ .name,
        "\(.rect.width)x\(.rect.height)",
        "\(.rect.x),\(.rect.y)",
        .current_workspace // "-"
      ] | join(" ")
EOF
    cz -f 0 \
       -i <(i3-msg -t get_outputs | jq -r "$filter")
}

cz_i3_window() {
    { hep "$CZ_HELP" && return; } <<EOF
cz i3 window
Select a i3 window then move focus to that window.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.. | select(.id? and .type == "con" and .nodes == [])
   | [ (.id | tostring), .output, .name] | join(" ")
EOF
    cz -f 0 -e 'i3-msg "[con_id={0@C}] focus"' \
       -i <(i3-msg -t get_tree | jq -r "$filter")
}

cz_i3_workspace() {
    { hep "$CZ_HELP" && return; } <<EOF
cz i3 workspace
Select an i3 workspace then switch to that workspace.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.[] | [ (.num | tostring), .name, .output, if .urgent then "*" else "" end ] | join(" ")
EOF
    cz -f 0 -e 'i3-msg workspace {0}' \
       -i <(i3-msg -t get_workspaces | jq -r "$filter")
}

cz_info()  {
    { hep "$CZ_HELP" && return; } <<EOF
cz info [QUERY]
Select an info page matching QUERY and open it for reading.
EOF
    req info || return 5
    cz -e 'info {0}' -i <(info -k "${1:-.}")
}

cz_ip_addr4() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -4 addr)
}

cz_ip_addr6() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -6 addr)
}

cz_ip_route4() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -4 route)
}

cz_ip_route6() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -6 route)
}

cz_ispell() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ispell < MISPELLED > FIXED
Select options for mispelled words in the input text.
Print text with updated to replace words with selections.
EOF
    req ispell || return 5
    # parse ispell spellcheck output
    mapfile -t lines
    local line="" index=0 fix=""
    while read -r symbol rest; do
        line="${lines[$index]}"
        case "$symbol" in
            '') # next
                (( index++ ))
                continue
                ;;
            '?') # guess
                : ;;
            '&') # miss
                read -r bad _ _ sug   <<< "$rest"
                IFS=', ' read -r -a fixes <<< "$sug"
                fix=$(printf "%s\n" "$bad" "${fixes[@]}" | cz)
                if [ -n "$fix" ]; then
                    lines["$index"]="${line/$bad/$fix}"
                fi
                ;;
            '#') # no guess
                continue
                ;;
            '*') # okay
                continue
                ;;
            '+') # root
                continue
                ;;
        esac
    done < <(printf "%s\n" "${lines[@]}" | ispell -a)
    printf "%s\n" "${lines[@]}"
}

cz_jq() {
    cz jq json "$@"
}

cz_jq_json() {
    { hep "$CZ_HELP" && return; } <<EOF
cz jq json [JSON-FILE] [< JSON-STREAM]
Select from jq path strings for each scalar within the input file or stream
 then use that path to extract the JSON element.
EOF
    req jq || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    read -r -d '' filter <<EOF
. as \$r
| path(..) | . as \$p
| \$r | getpath(\$p) as \$v
| select(\$v | scalars) |
[
 ("." + (\$p | map("[\\(tojson)]") | join(""))),
 (\$v)
] | @tsv
EOF
    cz -d $'\t' -f 0 -e "jq -r {0} $f" < <(jq -r "$filter" "$f")
}

cz_jq_yaml() {
    { hep "$CZ_HELP" && return; } <<EOF
cz jq yaml [YAML-FILE] [< YAML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the YAML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    local y
    if ! y=$(perl -MYAML -MJSON -E 'say encode_json(Load(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq json <<< "$y"
}

cz_jq_toml() {
    { hep "$CZ_HELP" && return; } <<EOF
cz jq toml [TOML-FILE] [< TOML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the TOML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    local t
    if ! t=$(perl -MTOML -MJSON -E 'say encode_json(from_toml(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq scalar <<< "$t"
}

cz_kill() {
    { hep "$CZ_HELP" && return; } <<EOF
cz kill [PID]
Select a running process then select a signal and send it to the selected process.
EOF
    local pid
    if ! pid="${1:-$(cz process)}"; then return 2; fi
    cz -e "kill -s {0} $pid" signal
}

cz_lastpass() {
    { hep "$CZ_HELP" && return; } <<EOF
cz lastpass
Select the ID of a LastPass entry then look up the password component.
EOF
    req lpass || return 5
    local menu=()
    local pat='^(.*[^/]) \[id: ([[:digit:]]+)\]$'
    while read -r item; do
        if [[ "$item" =~ $pat ]]; then
            menu+=("${BASH_REMATCH[2]} ${BASH_REMATCH[1]}")
        fi
    done < <(lpass ls)
    cz -e "lpass show --password {0}" < <(printf "%s\n" "${menu[@]}")
}

cz_line() {
    { hep "$CZ_HELP" && return; } <<EOF
cz line [FILE] [< STREAM]
Select a line number from the input file or stream.
EOF
    req sed || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -e "sed -n {0}p '$f'" -f 0 < <(sed '=' "$f" | sed '/./N;s/\n/ /')
}

cz_locate() {
    { hep "$CZ_HELP" && return; } <<EOF
cz locate [GLOB ...]
Select a file from the locate database matching the given glob strings.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 "${@:-$PWD}")
}

cz_locate_regex() {
    { hep "$CZ_HELP" && return; } <<EOF
cz locate regex [PATTERN ...]
Select a file from the locate database matching the given regular expressions.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 -r "${@:-.}")
}

cz_man() {
    { hep "$CZ_HELP" && return; } <<EOF
cz man [QUERY]
Select a manual page matching the given query and open it for reading.
EOF
    req man sed || return 5
    cz -f 0 -e 'man {0}' -i <(man -k "${1:-.}" | sed 's/ (/./;s/)//')
}

cz_mimetype() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mimetype
Select a mimetype and related file extensions.
EOF
    req grep /etc/mime.types || return 5
    cz -f 0 -i <(grep -v -e '^#' -e '^$' /etc/mime.types)
}

for t in artist album title track name genre date composer performer comment disc filename; do
    eval "
cz_mpd_tag_$t() {
    { hep \"\$CZ_HELP\" && return; } <<EOF
cz mpd $t
Select from available mpd database $t tags.
EOF
    req mpc || return 5
    cz -d '' -f 0 -i <(mpc list $t)
}"
done
unset t

cz_mpd_output() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd output and toggle it between enabled and disabled.
EOF
    req grep mpc || return 5
    cz -e "mpc toggleoutput {1}" -i <(mpc outputs | grep -v '^[[:space:]]')
}

cz_mpd_playlist() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd playlist then load it replacing the current playlist.
EOF
    req mpc || return 5
    cz -e "mpc clear && mpc load {0} && mpc play" -i <(mpc lsplaylists)
}

cz_mpd_find() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd find file [TYPE] [QUERY]
Select an mpd tag of the given kind then select for songs matching that tag.
EOF
    req mpc || return 5
    local kind="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -q mpd type)}"
    if [ -z "$kind" ]; then return 2; fi
    local query="${2:-$(CZ_MODE="" CZ_TEMPLATE="" cz -d '' -q mpd tag "$kind")}"
    if [ -z "$query" ]; then return 2; fi
    cz -d '' -f 0 -i <(mpc search "$kind" "$query")
}

cz_mpd_seek() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd seek
Select a percentage of the current song then seek to that position.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc seek {0}" \
       -i <(printf "%s%%\n" {100..0..5})
}

cz_mpd_track() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd track
Select a track number from the current mpd playlist then play that track.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc play {0}" \
       -i <(hold -ept 30 -- mpc -f '%position% [%artist% - %album% - %title%] --  %file%' playlist)
}

cz_mpd_type() {
    { hep "$CZ_HELP" && return; } <<EOF
cz mpd type
Select an mpd tag typ.
EOF
    req mpc || return 5
    cz argv artist album title track name genre date composer performer comment disc filename
}

cz_notmuch() {
    { hep "$CZ_HELP" && return; } <<EOF
cz notmuch QUERY
Select a message matcing the given query of a notmuch mail index.
EOF
    req getent || return 5
    cz -e 'notmuch show {0}' -f 0 -i <(notmuch search "$@")
}

cz_nss_group() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss group
Select a system group.
EOF
    req getent || return 5
    cz -f 0 -d : -i <(getent group)
}

cz_nss_host() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss host
Select a host from the system host name database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent hosts)
}

cz_nss_network() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss network
Select a network from the system network database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent networks)
}

cz_nss_passwd() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss passwd
Select a system user.
EOF
    req getent || return 5
    cz -f 0 -d ':' -i <(getent passwd)
}

cz_nss_protocol() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss protocol
Select a protocol from the system protocol database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent protocols)
}

cz_nss_service() {
    { hep "$CZ_HELP" && return; } <<EOF
cz nss service
Select a service from the system service database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent services)
}

cz_ruby_gem() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ruby gem
Select an installed ruby gem package by name.
EOF

    req gem ruby || return 5
    cz -f 0 -i <(gem query --local)
}

cz_pass() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pass
Select an entry from a pass directory and print its contents.
EOF
    req pass find sed head || return 5
    local pdir="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
    cz -f 0 -e 'pass show {0} | head -n1' \
       -i <(find "$pdir" -type f -name '*.gpg' | sed "s#\.gpg##; s#$pdir##")
}

cz_pci() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pci
Select a PCI device.
EOF
    req lspci || return 5
    cz -f 0 -i <(lspci)
}

cz_perl_installed() {
    { hep "$CZ_HELP" && return; } <<EOF
cz perl installed
Select an installed perl module.
EOF
    req perl || return 5
    cz -f 0 -i <(perl -MExtUtils::Installed  -E 'say for ExtUtils::Installed->new->modules')
}

cz_perl_doc() {
    { hep "$CZ_HELP" && return; } <<EOF
cz perl doc
Select a perldoc page and open it for reading.
EOF
    req perldoc perldoc-search || return 5
    cz -f 0 -e "perldoc {0}" -i <(perldoc-search . | perl -nE 'say $1 if /([\w:]+) - /')
}

cz_process() {
    { hep "$CZ_HELP" && return; } <<EOF
cz process
Select a system process by PID.
EOF
    req ps || return 5
    local cols index table
    mapfile table < <(ps ux)
    read -r -a cols <<< "${table[0]}"
    for ((index=1; index <= "${#cols[@]}"; index++)) ; do
        if [[ "${cols[$index]}" =~ ^(pid|PID)$ ]]; then break; fi
    done
    cz -f "$index" <<< "${table[@]:1}"
}

cz_pydoc() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pydoc
Select a python document and open it for reading.
EOF
    req pydoc || return 5
    cz -f 0 -e "pydoc {0}" < <(hold -ept 86400 -- pydoc -k .)
}

cz_python_installed() {
    { hep "$CZ_HELP" && return; } <<EOF
cz python installed
Select an installed python package and show info about it.
EOF
    req pip || return 5
    cz -f 0 -e "pip show {0}" < <(pip list)
}

cz_pulseaudio_sink() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pulseaudio sink
Select a pulseaudio sink and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-sink-mute {0} toggle' -i <(pactl list short sinks)
}

cz_pulseaudio_sink_volume() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pulseaudio sink
Select a pulseaudio sink and a percentage to set its volume.
EOF
    req pactl || return 5
    local sink
    if ! sink=$(cz -q pulseaudio sink); then return 2; fi
    cz -f 0 -e "pactl set-sink-volume $sink {0}" -i <(printf "%s%%\n" {100..0..5})
}

cz_pulseaudio_source() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pulseaudio source
Select a pulseaudio source and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-source-mute {0} toggle' -i <(pactl list short sources)
}

cz_pwgen() {
    { hep "$CZ_HELP" && return; } <<EOF
cz pwgen [LENGTH]
Select a generated password of given length.
EOF
    req pwgen || return 5
    cz -f 0 -i <(pwgen -1 -s "${1:-20}" 50)
}

cz_raku_module() {
        { hep "$CZ_HELP" && return; } <<EOF
cz raku installed
Select a generated password of given length.
EOF
    req sed zef || return 5
    cz -f 0 -i <(zef list -i 2>/dev/null | sed 's/:ver/ /')
}

cz_rg() {
    { hep "$CZ_HELP" && return; } <<EOF
cz rg [PATTERN] [DIRECTORY]
Select a file matching PATTERN in DIRECTORY.
EOF
    req rg || return 5
    local pat="${1:-.}"
    local dir="${2:-.}"
    cz -d ':' -e "$EDITOR +{1@C} -- {0}" -f 0 \
       -i <(rg --hidden -n -- "$pat" "$dir")
}

cz_screen_session() {
    { hep "$CZ_HELP" && return; } <<EOF
cz screen session
Select a screen session and attach to it.
EOF
    req screen || return 5
    cz -f 0 -e 'screen -rd {0}' -i <(screen -ls | grep pts)
}

cz_signal() {
    { hep "$CZ_HELP" && return; } <<EOF
cz signal
Select a system signal.
EOF
    local name line signals
    declare -a signals
    for x in {1..64}; do
        name=$(kill -l "$x")
        if [ -z "$name" ]; then continue; fi
        line=$(printf "%02d %s\n" "$x" "$name")
        signals+=("$line")
    done
    cz -f 0 < <(printf "%s\n" "${signals[@]}")
}

cz_ssh() {
    cz ssh host "$@"
}

cz_ssh_host() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ssh host [COMMAND]
Select a host from SSH configuration then connect to that host.
EOF
    req ssh sed || return 5
    cz -f 0 -e "ssh -t {0} -- $*" -i <(sed -E -n 's/^\s*Host\s+(.*)\s*/\1/ip' < "$HOME/.ssh/config")
}

cz_ssh_key() {
    { hep "$CZ_HELP" && return; } <<EOF
cz ssh key
Select a key available to the running ssh-agent.
EOF
    req ssh-add || return 5
    cz -f 2 -i < <(ssh-add -l)
}

cz_stream() {
    { hep "$CZ_HELP" && return; } <<EOF
cz stream
Select a standard stream.
EOF
    cz -f 0 <<EOF
0 /dev/stdin
1 /dev/stdout
2 /dev/stderr
EOF
}

cz_surfraw() {
    { hep "$CZ_HELP" && return; } <<EOF
cz surfraw [QUERY ...]
Select a surfraw elvi then run it with the given query.
EOF
    req surfraw || return 5
    cz -f 0 -e "surfraw {0} $*" < <(surfraw -elvi | sed 1d)
}

cz_sysctl() {
    { hep "$CZ_HELP" && return; } <<EOF
cz sysctl
Select a kernel parameter.
EOF
    req sysctl || return 5
    cz -f 0 -i <(sysctl -a 2>/dev/null)
}

cz_systemd_unit() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd unit [user|system] [TYPE]
Select a systemd system unit then check its status.
EOF
    req systemctl || return 5
    local user=""
    case "$1" in
        system) user=""; shift ;;
        user) user="yes"; shift ;;
    esac
    local type="$1"
    cz -f 0 -e 'systemctl status {0}' \
       -i <(eval systemctl list-units "${user:+--user}" "${type:+--type=$type}" -l -a --plain --no-legend)
}

cz_systemd_unit_file() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd unit-file [user|system] [TYPE]
Select a systemd system unit file then check its status.
EOF
    req systemctl || return 5
    local user=""
    case "$1" in
        system) user=""; shift ;;
        user) user="yes"; shift ;;
    esac
    local type="$1"
    cz -f 0 -e 'systemctl status {0}' \
       -i <(eval systemctl list-unit-files "${user:+--user}" "${type:+--type=$type}" --plain --no-legend)
}

cz_systemd_type() {
    { hep "$CZ_HELP" && return; } <<EOF
cz systemd type
Select a type of systemd unit.
EOF
    req sed systemctl || return 5
    cz -e 'systemctl list-units --type={0}' -f 0 \
       -i <(systemctl -t help | sed 1d)
}

cz_tar() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tar ARCHIVE
Select a file from a tar archive.
EOF
    req tar || return 5
    local tb="$1"
    cz -e "tar -x -f '$tb' -- {0}" -f 0 -d '' \
       -i <(tar -t -f "$tb")
}

cz_terraform_module() {
    { hep "$CZ_HELP" && return; } <<EOF
cz terraform module [DIRECTORY]
Select a terraform module call defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.module_calls | to_entries[]
  | [.key,
     .value.source,
     .value.pos.filename,
     .value.pos.line] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{3@C} -- {2}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_output() {
    { hep "$CZ_HELP" && return; } <<EOF
cz terraform output [DIRECTORY]
Select a terraform output variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.outputs | to_entries[]
 | [.key,
    .value.pos.filename,
    .value.pos.line] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{2@C} -- {1}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_provider() {
    { hep "$CZ_HELP" && return; } <<EOF
cz terraform output [DIRECTORY]
Select a terraform output variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.provider_configs | to_entries[]
 | [.key,
    .value.name,
    .value.alias] | @tsv
EOF
    cz -d $'\t' -f 0 \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_resource() {
    { hep "$CZ_HELP" && return; } <<EOF
cz terraform resource [DIRECTORY]
Select a terraform resource defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}"  filter=""
    read -r -d '' filter <<EOF
.managed_resources | to_entries[]
 | [.value.provider.name,
    .key,
    .value.pos.filename,
    .value.pos.line] | @tsv
EOF
    cz  -d $'\t' -f 1 -e "$EDITOR +{3@C} -- {2}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_variable() {
    { hep "$CZ_HELP" && return; } <<EOF
cz terraform variable [DIRECTORY]
Select a terraform input variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.variables | to_entries[]
 | [.key,
    .value.pos.filename,
    .value.pos.line,
    .value.description] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{2@C} -- {1}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_timezone() {
    { hep "$CZ_HELP" && return; } <<EOF
cz timezone
Select a timezone and print the current time in that region.
EOF
    local p="/usr/share/zoneinfo/posix"
    if req date timedatectl 2>/dev/null; then
        cz -f 0 -e 'TZ={0} date' \
           -i <(timedatectl list-timezones)
    elif req date "$p" sort 2>/dev/null; then
        cz -f 0 -e 'TZ={0} date' \
           -i <(for x in "$p"/*/*; do printf "%s\n" "${x##$p/}"; done | sort)
    else
        req systemd "$p"
    fi
}

cz_tmux_command() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux command
Select a tmux command.
EOF
    req tmux || return 5
    cz -f 0 -i <(tmux list-commands)
}

cz_tmux_key() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux key
Select a tmux key binding.
EOF
    req tmux || return 5
    cz -i <(tmux list-keys)
}

cz_tmux_pane() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux pane
Select a pane in the current tmux session and give it focus.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux select-pane -t {0}' -i <(tmux list-panes)
}

cz_tmux_session() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux session
Select a tmux session then attach to it.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux attach-session -t {0}' -i <(tmux list-sessions)
}

cz_tmux_window() {
    { hep "$CZ_HELP" && return; } <<EOF
cz tmux session
Select a tmux window then switch to it.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux select-window -t {0}' -i <(tmux list-windows)
}

cz_unicode() {
    cz unicode character "$@"
}

cz_unicode_character() {
    { hep "$CZ_HELP" && return; } <<EOF
cz unicode character [SECTION]
Select a unicode character from given character block or script.
Interactively select a block if a section is not given.
EOF
    req perl || return 5
    local part="${1:-$(CZ_MODE="" CZ_FIELDS="" cz -p unicode block)}"
    if [ -z "$part" ]; then return 2; fi
    cz -d ':' -e "printf \$'\U{1@C}'" -f 0  \
       -i <(perl -MUnicode::UCD=charinfo,charscript,charscripts,charblock,charblocks \
                 -E 'use strict; use warnings; use open ":std", ":encoding(UTF-8)";' \
                 -E 'my ($b,$s) = (charblocks(),charscripts());' \
                 -E 'my $g = shift; my $d = $b->{$g} || $s->{$g}; exit 1 unless($d);' \
                 -E 'for ($d->@*) { say join ":", chr hex $_->{code}, $_->{code}, $_->{name} for map { charinfo($_) } ($_->[0] .. $_->[1]); }' \
                 "$part")
}

cz_unicode_block() {
    { hep "$CZ_HELP" && return; } <<EOF
cz unicode block
Select a unicode block by name.
EOF
    req perl || return 5
    cz -f 0: -i <(perl -MUnicode::UCD=charblocks -E 'say for sort keys %{charblocks()}')
}

cz_unicode_script() {
    { hep "$CZ_HELP" && return; } <<EOF
cz unicode script
Select a unicode script by name.
EOF
    req perl || return 5
    cz -f 0: -i <(perl -MUnicode::UCD=charscripts -E 'say for sort keys %{charscripts()}')
}

cz_uri() {
    { hep "$CZ_HELP" && return; } <<EOF
cz uri [FILE] [< STREAM]
Select a URI extracted from the input text.
EOF
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    if type sensible-browser urifind &>/dev/null; then
        cz -e 'sensible-browser {0}' < <(urifind -su < "$f")
    elif type sensible-browser xurls &>/dev/null; then
        cz -e 'sensible-browser {0}' < <(xurls -r < "$f")
    else
        req sensible-browser urifind xurls || return 5
    fi
}

cz_usb() {
    { hep "$CZ_HELP" && return; } <<EOF
cz usb
Select a USB device.
EOF
    req lsusb || return 5
    cz -e 'lsusb -v -d {5}' -f 5 -i <(lsusb)
}

cz_word() {
    { hep "$CZ_HELP" && return; } <<EOF
cz word [FILE] [< STREAM]
Select a word from the given file or stream.
EOF
    req grep sort || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz < <(grep -Eo '([[:alnum:]_-])+' "$f" | sort -u)
}

cz_x11_color() {
    { hep "$CZ_HELP" && return; } <<EOF
cz x11 color
Select a color from a flat database X11 keeps around.
EOF
    req /etc/X11/rgb.txt grep || return 5
    cz -f 0:3 -i <(grep -v '^!' /etc/X11/rgb.txt)
}

cz_x11_window() {
    { hep "$CZ_HELP" && return; } <<EOF
cz x11 window
Select an X11 window.
EOF
    req sort xwininfo || return 5
    local menu=()
    while IFS= read -r l; do
        if [[ "$l" =~ ^[[:space:]]+?(0x[[:alnum:]]+)[[:space:]](.*) ]]; then
            menu+=("${BASH_REMATCH[1]} ${BASH_REMATCH[2]}")
        fi
    done < <(xwininfo -children -root)
    cz -f 0 -i <(printf "%s\n" "${menu[@]}" | sort)
}

xclip_brief() {
    local mod buf lns
    for mod in clipboard primary secondary; do
        buf=$(xclip -o -selection "$mod" 2>/dev/null)
        mapfile lns <<< "$buf"
        printf "%s %s %s\n" "$mod" "${#buf}" "${#lns[@]}"
    done
}

cz_xclip_in() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xclip in
Select a xclip buffer and write the input stream to it.
EOF
    req xclip || return 5
    cz -ge 'xclip -selection {0} -i' -i <(xclip_brief)
}

cz_xclip_out() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xclip out
Select a xclip buffer and print its contents.
EOF
    req xclip || return 5
    cz -e 'xclip -selection {0} -o' -i <(xclip_brief)
}

cz_xml_element() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xml element [FILE] [< STREAM]
Select a XML element by xpath string and print it.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -d '' -f 0 -e "xmlstarlet sel -B -t -c {0} $f" < <(xmlstarlet el -v "$f")
}

cz_xml_value() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xml value [FILE] [< STREAM]
Select a XML element by xpath string and extract its contents.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -d '' -f 0 -e "xmlstarlet sel -B -t -v {0} $f" < <(xmlstarlet el -v "$f")
}

cz_xrandr_monitor() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xrandr monitor
Select a X11 monitor.
EOF
    req xrandr sed || return 5
    cz -f 0 -i <(xrandr --listmonitors | sed '1d')
}

cz_xrandr_provider() {
    { hep "$CZ_HELP" && return; } <<EOF
cz xrandr provider
Select a X11 provider.
EOF
    req xrandr sed || return 5
    cz -f 0 -i <(xrandr --listproviders | sed '1d')
}

###

# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then cz "$@"; fi
