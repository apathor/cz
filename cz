#!/usr/bin/env bash
#
# cz - Line selection abstraction (plus utilities!)
# (C) 2020 by Mike Lalumiere
#
# TODO
#  - Manual page
#  - More help text and examples
#  - Better built-in line selector
#  - AWS/s3 plugins
#  - I8n?

if (("${BASH_VERSINFO[0]}" < 4)); then
    printf '%s1q\n' "$0 requires bash 4!" >&2
    return 255
fi

### UTILITIES

chuz() {
    # usage
    read -r -d '' use <<EOF
chuz < INPUT > LINE
Interactively select one line from input.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *) printf "%s\\n" "$use" >&2
               return 1
               ;;
        esac
    done
    shift $((OPTIND - 1))
    # prepend a number to each line of input
    local ind=0 lines=()
    mapfile -t lines
    for ((ind=0; ind < "${#lines[@]}"; ind++)); do
        printf "% 5d %s\\n" "$ind" "${lines[$ind]}" >&2
    done < <(printf "%s\\n" "${lines[@]}")
    # prompt interactively to select a line number
    shopt -s nocasematch
    while read -p "#? " -r sel < /dev/tty; do
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            # given a non-number perform a string search
            for ((ind=0; ind < "${#lines[@]}"; ind++)); do
                if [[ "${lines[$ind]}" =~ $sel ]]; then
                    printf "% 5d %s\\n" "$ind" "${lines[$ind]}" >&2
                fi
            done < <(printf "%s\\n" "${lines[@]}")
        else
            # line number must be within boundaries
            if [ "$sel" -lt "${#lines[@]}" ]; then
                break
            fi
        fi
    done
    shopt -u nocasematch
    # failed unless a selection was made
    if [ -z "$sel" ]; then return 2; fi
    # print the selected line
    printf "%s\\n" "${lines[$sel]}"
}

hep() {
    read -r -d '' use <<EOF
hep TOGGLE < INPUT > OUTPUT
Print input text if the first argument is non-empty, otherwise fail.
Use this function to optionally print help text in other functions.
For example: { hep "\$HELP_TOGGLE" && return; } <<<EOF ...
EOF
    # no real options
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # print input if given a non-empty argument
    if [ -n "$1" ]; then
        printf "%s\\n" "$(< /dev/stdin)" >&2
    else
        return 1
    fi
}

hold() {
    read -r -d '' use <<EOF
hold [OPTIONS] [MODE] [ARGUMENTS]
Speed up pipelines with caching!

MODE
 -e         : Arguments are evaluated as a command and the output is cached.
 -f         : Arguments are considered files and their content is cached.
 -g         : Ignore arguments and only retreive cached content.
 -d         : Ignore arguments and remove all cached files.

OPTIONS
 -k         : Do not clear old cached files.
 -n NAME    : Set the cache name. By default the name of the calling function is used.
 -p         : Print the contents of the cache file instead of its path.
 -q         : Quiet mode. Do not print cache file name or contents.
 -t SECONDS : Clear cache files older than given number of seconds.
 -x         : Do not load a cached file.

ENVIRONMENT
 HOLD_DIR   : Cache directory. The default is \$HOME/.cache/hold

EXAMPLES
 Cache a long running command.
  $ hold -e -n foo -t 60 bash -c "sleep 3 && date"
 Cache a long running pipeline.
  $ hold -g -n bar -t 30 || hold -f -x -n bar <(sleep 3 && date)
 Get a cache file by name.
  $ f="\$(hold -g -n foo)"; cat "\$f"
 Retreive cache file contents.
  $ hold -g -p -n foo
 Overwrite a cache.
  $ hold -f -x -n bar - <<< "test"
 Accept a file argument or stdin in one command.
  $ hold -f -x -n qux "\${1:--}"
EOF
    # help out
    if (( $# == 0 )); then
        printf "Command arguments required.\\n%s\\n" "$use" >&2
        return 1
    fi
    # get current time
    local now="${EPOCHSECONDS:-$(printf "%(%s)T\\n" -1)}"
    # accept options
    local name="${FUNCNAME[1]:-hold}" # string cache name
    local expire=0                    # integer seconds to expire cache
    local keep=0                      # boolean to not clear expired cache files
    local new="${HOLD_CLEAR:-0}"      # boolean to ignore cache
    local mode='run'                  # program mode: run/file/load/flush
    local out='name'                  # output mode: name/content/quiet
    local opt OPTIND OPTARG
    while getopts ":hdefgkn:pqt:x" opt; do
        case "$opt" in
            d)  # flush cache
                mode='flush'
                ;;
            e) # command input mode
                mode='run'
                ;;
            f) # file input mode
                mode='file'
                ;;
            g) # cache read
                mode='load'
                ;;
            k) # keep old
                keep=1
                ;;
            n) # cache name
                name="$OPTARG"
                if ! [[ "$name" =~ ^[[:alnum:]_-]+$ ]]; then
                    printf "%s - Invalid cache name '%s'.\\n" "${FUNCNAME[0]}" "$name" >&2
                    return 1
                fi
                ;;
            t) # cache expiration time
                expire="$OPTARG"
                if ! [[ "$expire" =~ ^[[:digit:]]+$ ]]; then
                    printf "%s - Invalid cache time '%s'.\\n" "${FUNCNAME[0]}" "$expire" >&2
                    return 1
                fi
                ;;
            p) # print the contents of the file
                out='content'
                ;;
            q) # print nothing
                out='quiet'
                ;;
            x) # force fresh cache
                new=1
                ;;
            h) # help
                printf "%s\\n" "$use" >&2
                return 0
                ;;
            \?)
                printf "Invalid option '%s'.\\n%s\\n" "$OPTARG" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # setup the cache directory
    local tmpd="${HOLD_DIR:-$HOME/.cache/hold}"
    if ! command mkdir -p "$tmpd"; then
        printf "Could not make cache directory '%s'.\\n" "$tmpd" >&2
        return 2
    fi
    # scan cached files in glob order
    local hot=()
    shopt -s nullglob
    for file in "$tmpd/$name."*; do
        # skip non-files
        if ! [ -f "$file" ]; then
            continue
        fi
        # in flush mode remove each cached file
        if [[ "$mode" == 'flush' ]]; then
            command rm "$file"
            continue
        fi
        # get timestamp component of file name
        IFS=. read -r _ ts <<< "${file##*/}"
        if ! [[ "$ts" =~ ^[0-9]+$ ]]; then
            continue
        fi
        # remove files older than the expiration time
        if ! (( keep )) && ( (( new )) || (( expire )) && (( now - expire > ts )) ); then
            command rm "$file"
            continue
        fi
        # gather matching files
        hot+=("$file")
    done
    shopt -u nullglob
    # check cache
    local cache=""
    if ! (( new )) && (( ${#hot} )); then
        # use most recent cached file
        cache="${hot[-1]}"
    else
        # create a new cache file
        cache=$(printf "$tmpd/%s.%d\\n" "$name" "$now")
        case "$mode" in
            run) # command mode - eval arguments as a command
                if (( $# == 0 )); then
                    printf "Command arguments required.\\n%s\\n" "$use" >&2
                    return 1
                fi
                eval "${*@Q}" > "$cache"
                ;;
            file) # file mode - cat arguments
                # requrie arguments
                if (( $# == 0 )); then
                    printf "File arguments required.\\n%s\\n" "$use" >&2
                    return 1
                fi
                # ensure each file exists
                local each=""
                for each in "$@"; do
                    if ! [ -r "$each" ] && [ "$each" != "-" ]; then
                        printf "%s - Could not read input: '%s'\\n" "${FUNCNAME[0]}" "$each" >&2
                        return 1
                    fi
                done
                # dump file contents to cache
                cat -- "$*" > "$cache"
                ;;
            load) # cache miss!
                return 4
                ;;
            flush) # clear mode - nothing to do
                return 0
                ;;
        esac
    fi
    # output
    case "$out" in
        content) # print content of cache file
            cat "$cache"
            ;;
        name) # print name of cache file
            printf "%s\\n" "$cache"
            ;;
    esac
    return 0
}

indirect() {
    read -r -d '' use <<EOF
indirect VARNAME [DEFAULT]
Print the value of the variable with the given name.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    # require variable name argument
    local name="$1"
    if [ -z "$name" ] || (( $# > 2 )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    local alt="$2"
    # dump the variable with given name or the fallback default
    local out="${!name}"
    if [ -z "$out" ]; then
        out="$alt"
    fi
    printf "%s\\n" "$out"
}

insulate() {
    read -r -d '' use <<EOF
insulate PATTERN COMMAND [ARG...]
Run the given command without environment variables matching the given pattern.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    # at least one argument is required
    if (( $# < 2 )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    # accept pattern argument
    local p="$1"
    shift
    (
        # filter environment variables
        while read -r v; do
            if [[ "$v" =~ $p ]]; then
                unset "$v"
            fi
        done < <(compgen -v)
        # run the given command in this modified environment
        eval "${*@Q}"
    )
}

nnow() {
    local now="${EPOCHREALTIME}"
    printf "%(%H:%M:%S)T.%s\\n" "${now%%.*}" "${now##*.}"
}

nth() {
    read -r -d '' use <<EOF
nth [OPTIONS] TEMPLATE [ARG ...]
Format and print a string from a template.

Substrings in the following formats are replaced:
 {X}     : argument with index X
 {X:}    : arguments X through end of arguments
 {X:Y}   : arguments X through X + Y
 {X,Y,Z} : arguments X, Y, and Z

Append @C, @E, @P, or @Q to transform selected arguments:
 @C - Insert argument literally. This is risky for command strings!
 @E - Replace backslash escape sequences in arguments with bash $'...' quotes.
 @P - Expand arguments for use in prompt strings.
 @Q - Quote arguments for use in command input. This is the default.

OPTIONS
 -c | -e | -p | -q
  Use @C, @E, @P, or @Q transform by default for each variable.

EXAMPLES
 $ nth -p "{2,25}" {A..Z}        = C Z
 $ nth -q "{0:}" foo bar baz     = 'foo' 'bar' 'baz'
 $ nth "{1@Q} {0@P}" "a b" "c d" = 'c d' a b
 $ nth "({2,1})" w x y z         = ('y' 'x')

EOF
    # accept options
    local pto="Q"
    local opt OPTIND OPTARG
    while getopts ":cehpq" opt; do
        case "$opt" in
            c) pto="C" ;; # clear
            e) pto="E" ;; # escaped
            p) pto="P" ;; # prompt
            q) pto="Q" ;; # quoted
            *) # invalid?
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # require template argument
    if ! (( $# )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    local tmpl="$1"
    shift
    # any remaining arguments are tokens to be inserted into the template
    local toks=("$@")
    # parser appends to this output string
    local out=""
    # parse template string
    local index=0 mode='text'
    local char="" next=""
    local field="" fields=() fmt=""
    while (( index < "${#tmpl}" )); do
        # consider each character and the character following
        char="${tmpl:$index:1}"
        next="${tmpl:$(( index + 1 )):1}"
        # switch depending on parser mode
        if [[ "$mode" == "text" ]]; then
            # in text mode read literal text
            case "$char" in
                '{')
                    # curly brace starts a variable
                    fields=()
                    mode="var"
                    ;;
                *)
                    # accumulate characters
                    out+="$char"
                    ;;
            esac
        elif [[ "$mode" == "var" ]]; then
            # start parsing a variable
            case "$char" in
                '{') # escaped literal curly brace
                    out+="$char"
                    mode="text"
                    ;;
                [[:digit:]:-]) # field specifiers
                    field+="$char"
                    ;;
                [,\}]) # field separator
                    # match and validate the field
                    if ! [[ "$field" =~ ^(-?[[:digit:]]+)(:([[:digit:]]+)?)?$ ]]; then
                        printf "Invalid field string '%s'\\n%s\\n" "$field" "$use" >&2
                        return 3
                    fi
                    # get regex match groups - field, range
                    local sel="${BASH_REMATCH[1]}"
                    local len="${BASH_REMATCH[3]:-${BASH_REMATCH[2]}}"
                    if [ -z "$len" ]; then
                        # N - one specific field
                        fields+=("${toks[$sel]}")
                    elif [ "$len" == ":" ]; then
                        # N: - a slice of fields
                        fields+=("${toks[@]:$((sel))}")
                    else
                        # N:X - a range of fields
                        if [[ "$len" -lt 1 ]]; then
                            printf "Invalid range '%s'\\n" "$len" >&2
                            return 3
                        fi
                        fields+=("${toks[@]:$((sel)):$((len))}")
                    fi
                    # reset field
                    field=""
                    ;;&
                '}') # end variable
                    mode="text"
                    # reformat field with global or per-variable format
                    local more=""
                    fmt="${fmt:-$pto}"
                    if [ "$fmt" == "C" ]; then
                        more=$(printf "%s " "${fields[@]}")
                    else
                        more=$(eval "printf \"%s \" \"\${fields[@]@$fmt}\"")
                    fi
                    fmt=""
                    # add selected fields to output
                    out+="${more%"${more##*[![:space:]]}"}"
                    ;;
                '@') # field transformation string
                    case "$next" in
                        [CEPQ]) # accept transform formats
                            fmt="$next"
                            (( index++ ))
                            ;;
                        *) # anything else is an error
                            printf "Invalid format string '%s'\\n%s\\n" "$next" "$use" >&2
                            return 3
                            ;;
                    esac
                    ;;
                ',') # field selection continues
                    ;;
                *) # invalid
                    printf "Could not parse character '%s' at index %d.\\n\\n%s\\n" "$char" "$index" "$use" >&2
                    return 3
                    ;;
            esac
        fi
        # next character
        (( index++ ))
    done
    # check if parsing ended cleanly
    if [[ "$mode" == "var" ]]; then
        printf "Unclosed variable delimeter?\\n%s\\n" "$use"  >&2
        return 3
    fi
    # strip leading and trailing whitespace
    out="${out##*()}"
    out="${out%"${out##*[![:space:]]}"}"
    # write out the resulting string
    printf "%s\\n" "${out}"
}

req() {
    read -r -d '' use <<EOF
req COMMAND/FILE [...]
Require given files and commands.
Succeed iff each given argument is a known command or readable file.
Use this function to define program requirements in other functions.
For example: req awk /etc/passwd || return 5
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # check that each argument exists either as a file or as a command
    local mis=0
    local arg=""
    for arg in "$@"; do
        if [ -r "$arg" ]; then continue; fi
        if type "$arg" &>/dev/null; then continue; fi
        ((mis++))
        printf "%s -- %s is required!\\n" "${FUNCNAME[1]}" "$arg" >&2
    done
    # fail if any requirement is missing
    ! ((mis))
}

randline() {
    read -r -d '' use <<EOF
randline
Select a line at random from input and print it.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    # just use shuf if available
    if type shuf &>/dev/null; then
        shuf -n 1
    else
        # read all lines then print one random lin
        local lines=()
        mapfile -t lines
        local pick=$(( RANDOM % ${#lines[@]} ))
        printf "%s\\n" "${lines[$pick]}";
    fi
}

rleval() {
    read -r -d '' use <<EOF
rleval [OPTIONS] COMMAND [ARGS ...]
In bash readline context, evaluate the given command then...
 -i : insert its output at cursor point. This is the default mode.
 -w : replace the word at cursor point with its output.
 -r : change nothing and attach the command to the terminal.

This function is intended to be used with the bash builtin 'bind -x'.
The command is templated with the function 'nth' using tokens from the readline
 buffer. Run 'nth -h' for more information.
The string '{0}' is replaced with the word at cursor point.
The string '{N}' is replaced with the token at index N starting at 1.

EXAMPLES
 Insert the first token from the current readline buffer:
 $ bind -x '"\\C-x0":rleval -i echo {1}'

 Insert fortunes on demand:
 $ bind -x '"\\C-xf":rleval -i fortune"'

 Replace the current word with a generated password:
 $ bind -x '"\\C-xp":rleval -w pwgen 20 1'

 Replace the current word with itself reversed:
 $ bind -x '"\\C-xt":rleval -w "rev <<< {0}"'

 Encode and decode base64 strings at cursor point:
 $ bind -x '"\\C-xb":rleval -w "base64 <<< {0}"'
 $ bind -x '"\\C-xB":rleval -w "base64 -d <<< {0}"'

 Open the man page for the topic at cursor point:
 $ bind -x '"\\C-xh":rleval -r man {0}'
EOF
    # accept options
    local mode='insert'
    local opt OPTIND OPTARG
    while getopts ":irwh" opt; do
        case "$opt" in
            i) mode='insert' ;;
            r) mode='run'  ;;
            w) mode='word' ;;
            h) printf "%s\\n" "$use"; return 0 ;;
            *) printf "%s\\n" "$use" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND - 1))
    # require command argument
    local args=("$@")
    if ! (($#)); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    # require readline context
    local line="$READLINE_LINE" pt="$READLINE_POINT"
    if [ -z "$pt" ]; then
        printf "%s only works with 'bind -x'!\\n%s\\n" "${FUNCNAME[0]}" "$use" >&2
        return 2
    fi
    # record current readline point
    local before="${line:0:$pt}"
    local after="${line:$pt}"
    # tokenize current readline line
    local toks=()
    read -r -a toks <<< "$line"
    # determine word at point
    local beg=0 end=0 ins=0 word=""
    if [[ "${line:$pt:1}" == ' ' ]]; then
        # insert a word if point is on a space
        beg="$pt"
        end="$pt"
        ins=1
    else
        # replace word at point if on a non-space character
        local pos=0
        # find the beginning of the word
        beg=0
        for ((pos="$pt"; pos>=0; pos--)); do
            if [[ "${line:$pos:1}" == ' ' ]]; then
                beg=$((pos + 1))
                break
            fi
        done
        # find the end of the word
        end="${#line}"
        for ((pos="$pt"; pos<="${#line}"; pos++)); do
            if [[ "${line:$pos:1}" == ' ' ]]; then
                end="$x"
                break
            fi
        done
        # grab the word
        word="${line:$beg:$(( end - beg ))}"
    fi
    # render the command template
    local cmd=""
    tmpl="${args[*]}"
    if ! cmd=$(nth "${tmpl}" "${word/#\~/$HOME}" "${toks[@]/#\~/$HOME}"); then
        return 2
    fi
    # switch based on program mode
    case "$mode" in
        insert)
            # run the command, capturing output
            local str=""
            if ! str=$(eval -- "$cmd"); then
                return 3
            fi
            # no output? no change
            if [ -z "$str" ]; then
                return 3
            fi
            # update the readline buffer
            READLINE_LINE="${before}${str}${after}"
            ((READLINE_POINT += ${#str}))
            ;;
        run)
            # run command attached to the terminal
            eval -- "$cmd" < /dev/tty
            ;;
        word)
            # run the command, capturing output
            local str=""
            if ! str=$(eval -- "$cmd"); then
                return 3
            fi
            # no change if the output is empty
            if [ -z "$str" ]; then
                return 3
            fi
            # wrap inserted words in spaces
            if ((ins)); then
                str=" ${str} "
            fi
            # update the readline buffer
            READLINE_LINE="${line:0:$beg}${str}${line:$end}"
            READLINE_POINT=$((beg + ${#str}))
            ;;
    esac
}

### MAIN

cz() {
    # version
    local ver="0.8.9"
    # usage
    local hows="" use=""
    read -r -d '' use <<EOF
cz [OPTIONS] [PLUGIN...] [ARGS ...] [< LINES]
Select a line using an interactive line selection tool.

OPTIONS
 These options print some information then exit:
  -h : help     : Show this help text or help text for plugin.
  -H : example  : List example commands.
  -k : tools    : List supported line selection tools.
  -l : plugins  : List detected plugins.
  -v : version  : Show version string.

 These options set the program mode. Select a line then... :
  -p : print    : Print the line. This is the default mode.
  -q : quote    : Print fields from the line in shell quotes.
  -r : run      : Run a templated command.
  -s : simulate : Print a templated command.
  -t : template : Print a templated string.
  -u : unquote  : Print fields from the line literally.
  -o : output   : Only print input lines instead of selecting a line.

 These options set a template:
  -e TEMPLATE   : Set the command template. This option implies mode '-r'.
  -f FIELDS     : Set the field template. This option implies mode '-q'.

 These options control input and line splitting:
  -c            : Do not use cached input lines.
  -d DELIMITER  : Set the field splitting characters.
  -g            : Buffer stdin and pass it to command set with '-e'.
  -0            : Read null terminated lines from input.
  -i IN-FILE    : Set file from which to read selections instead of stdin.

 These options control how lines are selected:
  -n NUMBER     : Select a line the given number of times.
  -w            : Pick a line at random.
  -x            : Use a graphical line selection tool.
  -y            : Use a terminal line selection tool.
  -z TOOL       : Use the given line selection tool.

 These options control debugging features:
  -m            : Print some debugging information.

TOOLS
 The following interactive line selection tools are supported:
  choose, dmenu, fzf, fzy, gum, iselect, pick, pipedial, rofi, selecta,
  sentaku, slmenu, vis-menu, and zenity.

PLUGINS
 Plugins use cz for an application specific task. Each plugin defines input
  lines, delimiter, and template options.
 Run 'cz -l' to list plugins and 'cz -h PLUGIN' or 'cz help' for help text.
 All commands starting with 'cz_' are considered plugins.

TEMPLATES
 Sub-strings of TEMPLATE in the following formats are replaced with
  one or more fields from a selected line split by DELIMITER.
     {X}     - field X
     {X:}    - fields X through end of fields
     {X:Y}   - fields X through X + Y
     {X,Y,Z} - fields X, Y, and Z

 Append @C, @E, @P, or @Q to transform selected fields:
  {X@C} - Insert argument directly. This is risky for command strings!
  {X@E} - Replace backslash escape sequences in arguments with bash $'...' quotes.
  {X@P} - Expand arguments for use in prompt strings.
  {X@Q} - Quote arguments for use in command input. This is the default.

ENVIRONMENT
 CZ_GUI         : The preferred interface (1=graphical 0=terminal).
 CZ_BINS        : A list of line selection tools in order of preference.
 CZ_DMENU_COLOR : Colon separated colors for dmenu (NF:NB:SF:SB).
 CZ_DMENU_FONT  : The font to use for dmenu.
 CZ_ROFI_THEME  : The theme to use for rofi.
EOF
    # example commands
    local hows=()
    mapfile -t hows <<EOF
Pick from lines on stdin.:$ printf "%s\\n" foo bar qux | cz
Accept null delimited input lines.:$ find . -name '*.yml' -print0 | cz -0
Extract useful fields from selected line.:$ cz -q -f 0,5 -d : < /etc/passwd
Safely handle input strings containing shell characters.:$ cz -e 'echo -- {0:}' -i <(printf "%s\\n" '\$USER' '; false' '\$(fortune)' '-e')
Pick a line randomly instead of interactively.:$ printf "%s\\n" {A..Z} | cz -w
Add selection to common commands.:$ cz -r -e 'dig {0} AAAA +short' compgen hostname
Extend plugins with bash functions.:$ cz_whois() { cz -e 'whois {0}' -f 0 compgen hostname; }; cz whois
Select a password and put it on an xclip clipboard.:$ cz pass | cz xclip in
Jump to any descendant directory.:$ cd \$(cz descendant)
Jump to any ancestor directory.:$ cd \$(cz ancestor)
Grab a URL from a paste buffer and open it in a browser.:$ cz xclip out | cz -r -e 'firefox {0}' uri
Compose plugins to get the contents of any element from any JSON file.:$ cz -e 'cz jq {0}' locate *.json
Compose plugins to get any file under an apparix bookmarked directory.:$ cz -e 'cz find file {1}' apparix
Find a file then open it for editing:$ find . -type f -print0 | cz -0 -r -e 'vim {0}'
Consult the I Ching.:$ cz -u -w -f0,2 -n 10 unicode character 'Yijing Hexagram Symbols'
EOF
    # supported tools
    read -r -d '' exes <<EOF
choose    https://github.com/chipsenkbeil/choose
dmenu     https://tools.suckless.org/dmenu
fzf       https://github.com/junegunn/fzf
fzy       https://github.com/jhawthorn/fzy
gum       https://github.com/charmbracelet/gum
iselect   http://www.ossp.org/pkg/tool/iselect
pick      https://github.com/mptre/pick
pipedial  https://code.reversed.top/user/xaizek/pipedial
rofi      https://github.com/davatorium/rofi
selecta   https://github.com/garybernhardt/selecta
sentaku   https://github.com/rcmdnk/sentaku
sk        https://github.com/lotabout/skim
slmenu    https://bitbucket.org/rafaelgg/slmenu
vis-menu  https://github.com/martanne/vis
EOF
    # append one random example to usage text
    local des="" exp=""
    IFS=: read -r des exp <<< "${hows[$(( RANDOM % ${#hows[@]} ))]}"
    use+=$(printf "\\n\\nEXAMPLE\\n %s\\n %s\\n" "$des" "$exp")
    # here are the supporterd line selection tools
    declare -A gbins tbins
    while read -r -d ' ' x; do gbins["$x"]=1; done <<< "choose dmenu rofi zenity "
    while read -r -d ' ' x; do tbins["$x"]=1; done <<< "fzf fzy pick gum pipedial selecta sentaku sk iselect slmenu vis-menu "
    # determine type of interface for line selection tool
    local app="" gfx=""
    IFS=: read -r gfx app _ <<< "${CZ_GUI:-2}"
    if [ -z "$DISPLAY" ]; then gfx=0; fi
    # set options from the environment
    local tpl="${_CZ_TEMPLATE}"         # string  | command template
    local fld="${_CZ_FIELDS}"           # string  | field selection
    local mode="${_CZ_MODE}"            # string  | indicator for program mode
    local num="${_CZ_NUMBER:-1}"        # integer | number of lines to select
    local help="${_CZ_HELP}"            # string  | indicator for help requested
    local dlm="${_CZ_DELIM:-$IFS}"      # string  | delimeter to split selected line
    local dbg="${CZ_DEBUG:-$_CZ_DEBUG}" # boolean | whether or not write debug info
    # set option defaults
    local inp="/dev/stdin"              # string  | file from which to select a line
    local buf=0                         # boolean | require buffered stdin for command
    local plan=""                       # string  | program mode implied by another option
    local nul=0                         # boolean | whether to read null separated lines
    local clr=0                         # boolean | whether to refresh cached input lines
    # accept options
    printf "OPTS %s\\n" "$(nnow)" | hep "$dbg"
    local opt OPTIND OPTARG
    while getopts ":cd:e:f:ghHi:klmn:opqrstuvwxyz:0" opt; do
        case "$opt" in
            c) # clear hold caches
                clr=1
                ;;
            d) # set delimeter string
                dlm="$OPTARG"
                ;;
            e) # set template to format command
                tpl="${tpl:-$OPTARG}"
                plan='run'
                ;;
            f) # set fields to be extracted
                fld="${fld:-$OPTARG}"
                plan="${plan:-quote}"
                ;;
            g) # enable buffered stdin for command
                buf=1
                ;;
            h) # enable help mode
                help=1
                ;;
            H) # list usage examples
                local ind
                for ((ind=0; ind < "${#hows[@]}"; ind++)); do
                    IFS=: read -r des exp <<< "${hows[$ind]}"
                    printf "%s\\n%s\\n\\n" "$des" "$exp"
                done
                return 0
                ;;
            i) # set input file from which to read selections
                inp="$OPTARG"
                if ! [ -r "$inp" ]; then
                    printf "%s\\n" "Input file is unreadable!" >&2
                    return 2
                fi
                ;;
            k) # list supported tools
                printf "%s\\n" "$exes"
                return 0
                ;;
            l) # list available plugins
                while read -r f; do
                    if [[ "$f" == cz_* ]]; then
                        printf "%s\\n" "${f##cz_}"
                    fi
                done < <(compgen -c) | sort
                return 0
                ;;
            m) # mention some debugging information
                dbg=1
                ;;
            n) # select more than one line
                num="$OPTARG"
                if ! [[ "$num" =~ ^[[:digit:]]+$ ]]; then
                    printf "Invalid number options!\\n" >&2
                    return 1
                fi
                ;;
            o) # just print lines without interactive selection
                mode='output'
                ;;
            p) # print selected line instead of running anything
                mode='print'
                ;;
            q) # print rendered template from '-f' with variables shell-quoted
                mode='quote'
                ;;
            r) # run rendered command template from '-e'
                mode='run'
                ;;
            s) # print string from '-e' as command
                mode='simulate'
                ;;
            t) # print string from '-e' as raw template
                mode='template'
                ;;
            u) # print rendered template from '-f' with variables inserted directly
                mode='unquote'
                ;;
            v) # write version
                printf "cz %s\\n" "$ver"
                return 0
                ;;
            w) # select a random line instead of using an external tool
                app='randline'
                ;;
            x) # try to use a graphical tool for line selection
                gfx=1
                ;;
            y) # try to use a terminal tool for line selection
                gfx=0
                ;;
            z) # use a specific line selection tool
                app="$OPTARG"
                if ! (( gbins["$app"] + tbins["$app"] )) ; then
                    printf "Unknown line selection tool '%s'\\n" "$app" >&2
                    return 2
                fi
                ;;
            0) # handle null separated input
                nul=1
                ;;
            :) # missing argument
                printf "Missing argument for option -%s\\n%s\\n" "$OPTARG" "$use" >&2
                return 2
                ;;
            \?) # invalid option?
                printf "Bad option: -%s\\n%s\\n" "$OPTARG" "$use" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # determine an available line selection tool
    local got=""
    if [ -z "$app" ]; then
        local tools=("${!gbins[@]}" "${!tbins[@]}")
        # filter preferred tools by the desired interface
        local want=()
        while read -d ' ' -r pref; do
            case "$gfx" in
                0) if ! (( tbins["$pref"] )); then continue; fi ;;
                1) if ! (( gbins["$pref"] )); then continue; fi ;;
            esac
            # printf "%s\n" "${pref}"
            want+=("$pref")
        done <<< "${CZ_BINS:-${tools[*]}} ${tools[*]}"
        # use the first available tool
        for app in "${want[@]}"; do
            if type "$app" &>/dev/null; then
                got="$app"
                break
            fi
        done
        app="$got"
        # exit if no appropriate tool was found
        if [ -z "$got" ]; then
            printf "No line selection tools found!\\nTry installing one of these:\\n" >&2
            printf "%s\\n" "${tools[@]}" | sort >&2
            return 5
        fi
    fi
    # plugins - any command in the format 'cz_$WORD'
    if [ -n "$*" ]; then
        # determine if a known plugin is given
        local args=("$@") plug="" word=0
        for ((word=${#args[@]}; word>0; word--)); do
            plug="${args[*]:0:$word}"
            plug="cz_${plug// /_}"
            if type "$plug" >&/dev/null; then break; fi
            plug=""
        done
        # exit for invalid plugins
        if [ -z "$plug" ]; then
            printf "No plugin matching '%s'.\\n" "$*" >&2
            return 2
        fi
        shift "$word"
        printf "PLUG %s %s\\n" "$(nnow)" "$plug" | hep "$dbg"
        # run the plugin with override environment variables
        _CZ_DELIM="$dlm" \
                 _CZ_DEBUG="$dbg" \
                 _CZ_FIELDS="$fld" \
                 CZ_GUI="${gfx}:${app}" \
                 _CZ_HELP="$help" \
                 _CZ_MODE="$mode" \
                 _CZ_NUMBER="$num" \
                 _CZ_TEMPLATE="$tpl" \
                 CZ_DMENU_COLOR=$(indirect "${plug^^}_DMENU_COLOR" "$CZ_DMENU_COLOR") \
                 CZ_DMENU_FONT=$(indirect "${plug^^}_DMENU_FONT" "$CZ_DMENU_FONT") \
                 CZ_ROFI_THEME=$(indirect "${plug^^}_ROFI_THEME" "$CZ_ROFI_THEME") \
                 HOLD_CLEAR="$clr" \
                 "$plug" "$@"
        return "$?"
    fi
    # print usage and exit if help was requested
    if [ -n "$help" ]; then
        printf "%s\\n" "$use" >&2
        return
    fi
    # cache the selection file
    printf "READ %s\\n" "$(nnow)" | hep "$dbg"
    local id="cz_$$" sel=""
    if ((nul)); then
        local lines=()
        mapfile -d '' -t lines < "$inp"
        sel=$(printf "%q\\n" "${lines[@]}" | hold -f -k -x -n "$id" -)
    elif ! [ -f "$inp" ]; then
        sel=$(hold -f -k -x -n "$id" "$inp")
    else
        sel="$inp"
    fi
    if ! [ -f "$sel" ]; then
        return 11
    fi
    # buffer stdin if reading selection input from another file
    # this is needed to pass pipe input to plugin commands
    # optionally require actual input lines
    local stdin=()
    if [[ "$inp" != "/dev/stdin" ]] && ! [ -t 0 ]; then
        printf "STDIN %s\\n" "$(nnow)" | hep "$dbg"
        mapfile -t stdin
        if ((buf)) && ! ((${#stdin})); then return 4; fi
    fi
    # maybe just write selections to stdout
    if [[ "$mode" == "output" ]]; then
        printf "OUTPUT %s\\n" "$(nnow)" | hep "$dbg"
        printf "%s\\n" "$(< "$sel")"
        return 0
    fi
    # politely handle signals
    trap 'return 1' SIGINT SIGTERM
    trap 'hold -d -n ${id}; trap - RETURN SIGINT SIGTERM' RETURN
    # loop for desired number of selections
    local count=0
    while (( num == 0 )) || (( ++count <= num )); do
        # choose a line using a known program
        printf "PICK %s %d/%d %s %s \\n" "$(nnow)" "$count" "$num" "$app" "$sel" | hep "$dbg"
        local out=""
        out=$(case "$app" in
                  choose)
                      choose -n 20
                      ;;
                  dmenu)
                      local color="${CZ_DMENU_COLOR:-black:gray:white:black}"
                      local font="${CZ_DMENU_FONT}"
                      IFS=':' read -r nf nb sf sb <<< "$color"
                      dmenu -i -l 20 -fn "$font" -nf "$nf" -nb "$nb" -sf "$sf" -sb "$sb"
                      ;;
                  fzf)
                      fzf
                      ;;
                  fzy)
                      fzy
                      ;;
                  gum)
                      gum filter
                      ;;
                  iselect)
                      iselect -a
                      ;;
                  pick)
                      pick
                      ;;
                  randline)
                      randline
                      ;;
                  rofi)
                      local theme="${CZ_ROFI_THEME:-Paper}"
                      rofi -theme "$theme" -i -dmenu -p ""
                      ;;
                  pipedial)
                      pipedial
                      ;;
                  selecta)
                      selecta --height=full
                      ;;
                  sentaku)
                      sentaku -s $'\n' | head -n 1
                      ;;
                  sk)
                      sk
                      ;;
                  slmenu)
                      slmenu -i -l 30
                      ;;
                  vis-menu)
                      vis-menu -i -l 30
                      ;;
                  zenity)
                      zenity --width=640 --height=480 --list --column=cz
                      ;;
                  chuz)
                      chuz
                      ;;
                  *)
                      printf "Unknown tool %s.\\n" "$app" >&2
                      return 2
                      ;;
              esac < "$sel"
           ) || return 4
        # require that selector succeeded and got a line
        if [ -z "$out" ]; then
            return 4
        fi
        # expand shell quoted line
        if ((nul)); then
            out=$(eval printf "%s" "$out")
        fi
        printf "> %s\\n" "$out" | hep "$dbg"
        # tokenize selected line for use in templates
        local cmd=""
        local toks=()
        IFS="$dlm" read -r -a toks <<< "$out"
        # set harmless defaults for template arguments
        tpl="${tpl:-echo {0:\}}"
        fld="${fld:-0:}"
        # assume field templates with no variables are simple variables
        if ! [[ "$fld" =~ \{.*\} ]]; then
            fld="{${fld}}"
        fi
        # the program mode might have been implied by other options
        plan="${plan:-print}"
        mode="${mode:-$plan}"
        # do something with the selection depending on mode
        printf "MODE %s %s\\n" "$(nnow)" "$mode" | hep "$dbg"
        case "${mode}" in
            print)
                # print selection
                printf "PRINT %s\\n" "$(nnow)" | hep "$dbg"
                printf "%s\\n" "$out"
                ;;
            quote)
                # print some fields extracted from the line quoted for use in the shell
                if ! out="$(nth -q -- "$fld" "${toks[@]}" 2>/dev/null)"; then
                    printf "Failed to render template: %s\\n" "$fld" >&2
                    return 5
                fi
                printf "QUOTE %s\\n# %s ==> %s\\n" "$(nnow)" "$fld" "$out" | hep "$dbg"
                printf "%s\\n" "$out"
                ;;
            run)
                # template the command string then run it
                if ! cmd="$(nth -q -- "$tpl" "${toks[@]}" 2>/dev/null)"; then
                    printf "Failed to parse template: %s\\n" "$tpl" >&2
                    return 5
                fi
                printf "RUN  %s\\n$ %s\\n" "$(nnow)" "$cmd" | hep "$dbg"
                unset -v _CZ_DELIM _CZ_FIELDS _CZ_HELP _CZ_MODE _CZ_TEMPLATE HOLD_CLEAR
                # eval the command maybe passing through stdin or the terminal
                if ((${#stdin})); then
                    ( CZ_GUI="${gfx}:${app}" eval "$cmd" < <(printf "%s\\n" "${stdin[@]}") & wait )
                elif [ -n "$PS1" ]; then
                    ( CZ_GUI="${gfx}:${app}" eval "$cmd" < /dev/tty & wait)
                else
                    ( CZ_GUI="${gfx}:${app}" eval "$cmd" & wait )
                fi
                ;;
            simulate)
                # render the command string with shell quotes
                if ! cmd="$(nth -q "$tpl" "${toks[@]}")"; then
                    printf "Failed to render template.\\n%s\\n" "$tpl" >&2
                    return 4
                fi
                printf "SIMULATE %s\\n> %s ==> %s\\n" "$(nnow)" "$tpl" "$cmd" | hep "$dbg"
                printf "%s\\n" "$cmd"
                ;;
            template)
                # render the command template directly
                if ! cmd="$(nth -p "$tpl" "${toks[@]}")"; then
                    printf "Failed to render template.\\n%s\\n" "$tpl" >&2
                    return 4
                fi
                printf "TEMPLATE %s\\n> %s ==> %s\\n" "$(nnow)" "$tpl" "$cmd" | hep "$dbg"
                printf "%s\\n" "$cmd"
                ;;
            unquote)
                # print some fields extracted from the line
                if ! out="$(nth -p -- "$fld" "${toks[@]}" 2>/dev/null)"; then
                    printf "Failed to render template: %s\\n" "$fld" >&2
                    return 5
                fi
                printf "UNQUOTE %s\\n> %s ==> %s\\n" "$(nnow)" "$fld" "$out" | hep "$dbg"
                printf "%s\\n" "$out"
                ;;
        esac
    done
    return 0
}

# cz command completion
function _cz() {
    local reply=()
    # get lists of supported tools and plugins
    local tools=() plugs=()
    mapfile -t tools < <(cz -k)
    mapfile -t plugs < <(cz -l)
    # cz has some options
    local opt=""
    declare -A opts
    for opt in -{c,d,e,f,g,h,H,i,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,0}; do
        opts["$opt"]=1
    done
    # current and previous words are given
    local name="${1}" curr="${2}" prev="${3}"
    # scan all previous words to identify already used options
    local last="" word="" i=0
    local rest=()
    for ((i=1; i <= "$COMP_CWORD"; i++)); do
        # step through words
        word="${COMP_WORDS[$i]}"
        last="${COMP_WORDS[$i-1]}"
        # have options ended?
        if [[ "$word" =~ ^-[[:alnum:]]$ ]] && [[ "$word" != "$curr" ]]; then
            # record options already seen
            unset opts["$word"]
        elif [[ "$word" =~ ^[[:alnum:]]+ ]]; then
            # maybe this is an argument to an option
            if [[ "$last" =~ ^-[definz]$ ]]; then continue; fi
            opts=()
            rest=("${COMP_WORDS[@]:$i}")
            break
        fi
    done
    # maybe the previous word is a redirection
    local rd='^[&[:digit:]]?[><]'
    if [[ "$prev" =~ $rd ]]; then
        mapfile -t reply < <(compgen -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
        return
    fi
    # maybe the previous word is an option that expects an argument
    if [[ "$prev" =~ ^-[definz]$ ]]; then
        case "$prev" in
            -d) # delimiter
                reply=();
                ;;
            -e) # command template
                mapfile -t reply < <(compgen -c -- "$curr")
                ;;
            -f) # field selector
                mapfile -t reply < <(compgen -W "0 1 2 3 4 5 6 7 8 9" -- "$curr")
                ;;
            -i) # input file
                mapfile -t reply < <(compgen -f -- "$curr")
                compopt -o filenames
                ;;
            -n) # number of loops
                mapfile -t reply < <(compgen -W "0 1 2 3 4 5 6 7 8 9" -- "$curr")
                ;;
            -z) # selection tool
                mapfile -t reply < <(compgen -W "${tools[*]%% *}"  -- "$curr")
                ;;
        esac
        COMPREPLY=("${reply[@]}")
        return
    fi
    # maybe we're on the first plugin token
    if ! (( "${#rest[@]}" )); then
        mapfile -t reply < <(compgen -W "${!opts[*]} ${plugs[*]%%_*}" -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # consider remaining arguments as plugins
    local idx=0 plugin="" args=()
    for ((idx=$(( ${#rest[@]} - 1 )); idx >= 0; --idx)); do
        # assume tokens are a plugin prefix
        local base="" toks=("${rest[@]:1:$idx}")
        base=$(printf "%s" "${rest[0]}" "${toks[@]/#/_}")
        # remaining tokens are plugin arguments
        args=("${rest[@]:$(( idx + 1 ))}")
        # check plugin completions for this prefix
        local comps=()
        mapfile -t comps < <(compgen -W "${plugs[*]}" -- "${base}")
        if ! (("${#comps[@]}")); then
            continue
        fi
        # exact match means the plugin was found
        if [ -z "$plugin" ] && [[ "$base" == "${comps[0]}" ]]; then
            plugin="$base"
            break
        fi
        # maybe complete the current token
        if [ "${base##*_}" == "$curr" ]; then
            local frags=()
            mapfile -t frags < <(compgen -W "${comps[*]/#${base%_*}_/}" -- "${curr}")
            if (("${#frags[@]}")); then
                reply=("${frags[@]%%_*}")
            else
                reply=("${comps[@]%%_*}")
            fi
        fi
        # maybe reply
        if (("${#reply[@]}")); then
            COMPREPLY=("${reply[@]}")
            return
        fi
    done
    # maybe complete something specific for plugins
    # plugin specific completion functions receive the following arguments:
    # PLUGIN_NAME CURRENT_TOKEN PREVIOUS_TOKEN [WORDS...]
    local func="_cz_${plugin}"
    if [ -n "$plugin" ] && type "$func" &>/dev/null; then
        eval "$func" "cz_${plugin}" "${curr@Q}" "${prev@Q}" "${args[@]@Q}"
    fi
}
complete -F _cz cz

cz_help() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz help
Select a cz plugin and print its usage text.
EOF
    cz -e 'cz -h {0}' -i <(cz -l)
}

cz_meta() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz meta [MODE-OPTION] [PREFIX] [ARGUMENTS]
Select a cz plugin and run it in the given mode.
The mode options are -o -p -q -r -s -t -u. The default mode is -p.
Given a prefix selections are limited to matching plugins.

This plugin is best used bound to a key, providing a quick
 interface to every other cz plugin.

EXAMPLES
 $ bind -x '"\\C-xx":rleval cz meta -q' # insert quoted fields
 $ bind -x '"\\C-xX":rleval cz meta -p' # insert full line
 $ bind -x '"\\C-xz":rleval cz meta -r' # insert command output
 $ bind -x '"\\C-xZ":rleval cz meta -s' # insert command string
EOF
    local mode="-p"
    local opt OPTIND OPTARG
    while getopts ":opqrstu" opt; do
        case "$opt" in
            [opqrstu])
                mode="-$opt"
                ;;
            \?)
                printf "Bad option: -%s\\n" "$OPTARG" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    local prefix="$1"
    shift
    cz -f 0 -e "cz ${mode} {0} ${*@Q}" -i <(compgen -W "$(cz -l)" -- "$prefix")
}

_cz_meta() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        local mopts=( -o -p -q -r -s -t -u )
        mapfile -t reply < <(compgen -W "${mopts[*]}" -- "$curr")
        COMPREPLY=("${reply[@]}")
    elif [[ "$curr" == "${words[1]}" ]]; then
        local pres=()
        mapfile -t pres < <(cz -l | grep _ | while read -r x; do printf "%s\\n" "${x%%_*}"; done | sort -u)
        mapfile -t reply < <(compgen -W "${pres[*]}" -- "$curr")
        COMPREPLY=("${reply[@]}")
    fi
}

cz_mode() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mode [PREFIX] [ARGUMENTS]
Select a cz mode then run a plugin in that mode.
EOF
    cz -e "cz meta {0} -- $*" -f 0 \
       -i <(printf "%07s %s\\n" \
                   -p "print line" \
                   -q "quoted fields" \
                   -r "command output" \
                   -s "command string" \
                   -t "template string" \
                   -u "unquoted fields")
}

cz_tool() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tool
Select a cz supported line selection tool then run a plugin with that tool.
EOF
    cz -e "cz -z {0} meta -- $*" -f 0 -i <(cz -k)
}

### PLUGINS

cz_anagram() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz anagram TEXT [WORDS]
Select from anagrams of TEXT.
Optionally limit to a maximum number of WORDS.
EOF
    req an || return 5
    if [ -z "$1" ]; then return 2; fi
    cz -i <(an -l "${2:-3}" "$1")
}

anc() {
    read -d '' -r use <<EOF
anc [DIRECTORY]
Print the ancestor dirs of the given directory up to the root.
EOF
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            h) printf "%s\\n" "$use" >&2; return 0 ;;
            *) printf "%s\\n" "$use" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND - 1))
    local dir="${1:-$PWD}"
    if ! [ -d "$dir" ]; then return 2; fi;
    local toks=()
    IFS=/ read -ra toks <<< "${dir#/}"
    local seg="" cur="" idx=0
    for ((idx=0; idx<=${#toks[@]}; idx++)); do
        seg="${toks[$idx]}"
        printf "%s\\n" "${cur:-/}"
        cur="${cur}/${seg}"
    done
}

cz_ancestor() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ancestor [DIRECTORY]
Select from parent directories.
EOF
    local d="${1:-$PWD}"
    if ! [ -d "$d" ]; then return 2; fi;
    cz -d '' -e 'cd {0}' -f 0: -i <(anc "$d")
}

_cz_ancestor() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -d -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o dirnames
    fi
}

cz_ansible_doc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ansible doc
Select from ansible documentation topics.
EOF
    req ansible-doc || return 5
    cz -f 0 -e "ansible-doc {0}" < <(ansible-doc -l)
}

cz_ansible_group() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ansible group
Select a group from an ansible inventory then draw a graph of its members.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --graph {0}' \
       -i <(ansible-inventory --list \
                | jq -r '. | keys[] | select(. | test("^_") | not)')
}

cz_ansible_host() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ansible host
Select a host from an ansible inventory then print its variables as JSON.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --host {0}' \
       -i <(ansible-inventory --list \
                | jq -r '[.[] | select(.hosts!=null) | .hosts[]] | flatten | unique[]')
}

cz_apparix() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz apparix
Select from apparix bookmarks.
EOF
    req apparix awk || return 5
    cz -f 1 -i <(apparix | awk '/^j/ { print $2, $3 }')
}

cz_apt() {
    cz apt package "$@"
}

cz_apt_installed() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz apt installed
Select from installed apt packages.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' \
       -i <(dpkg --get-selections | awk '$2 == "install" { print $1 }')
}

cz_apt_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz apt package [QUERY]
Select from apt package listings matching QUERY.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' \
       -i <(if [ "$qry" == "." ]; then
                hold -ept 3600 -- apt-cache search .
            else
                apt-cache search "$qry"
            fi
           )
}

cz_argv() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz argv [ARGS]
Select from given arguments.
EOF
    cz -i <(printf "%s\\n" "$@")
}

cz_asdf_mine() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz asdf mine
Select from installed asdf plugins.
EOF
    req asdf || return 5
    cz -f 0 -e 'asdf plugin update {0}' \
       -i <(asdf plugin list)
}

cz_asdf_plugin() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz asdf plugin
Select from available asdf plugins.
EOF
    req asdf sed || return 5
    cz -f 0 -e 'asdf plugin add {0} {1}' \
       -i <(hold -ept 3600 -- asdf plugin list all 2>/dev/null | sed '/HEAD/d;s/*/ /;')
}

cz_asdf_shim() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz asdf shim
Select from executable shims maintained by asdf.
EOF
    req asdf || return 5
    local dir="$HOME/.asdf/shims"
    cz -f 0 -e "asdf shim-versions {0}" \
       -i <(cd "$dir" && printf "%s\\n" ./*)
}

cz_asdf_version() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz asdf version PLUGIN
Select from available versions of the given asdf plugin.
EOF
    req asdf || return 5
    local plugin="${1:-$(insulate ^_CZ_ cz -u asdf mine)}"
    if [ -z "$plugin" ]; then return 2; fi
    cz -f 0 -e "asdf install ${plugin@Q} {0}" \
       -i <(printf "%s\\n" latest; asdf list all "$plugin";)
}

cz_bash_alias() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz bash alias
Select from defined bash aliases.
EOF
    cz -i <(alias)
}

cz_bash_bind_function() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash bind function
Select from bash internal readline functions.
EOF
    cz -i <(bind -l)
}

cz_bash_bind_key() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash bind key
Select from bash key bindings.
EOF
    cz -d: -f 1 -i <(grep -a -v ^# <( bind -p; bind -X; bind -s; ))
}

cz_bash_completion() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash completion
Select from bash completion function configuration.
EOF
    cz -i <(complete -p)
}

cz_bash_help() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash help
Select from bash help topics.
EOF
   cz -e 'help {0}' -i <(insulate ^_CZ_ cz -o compgen helptopic)
}

cz_bash_history() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash history [PATTERN]
Select a command from bash history then run it.
Given a pattern include only matching commands.
EOF
    req sort || return 5
    local pattern="${1:-.}"
    cz -f '3:@C' -e "{3:@C}" \
       -i <(HISTTIMEFORMAT="%F %T " history | sort -r -n | grep "$pattern")
}

cz_bash_job() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash job
Select a bash background job and move it to the foreground.
EOF
    cz -d $'\t' -f 1 -e 'fg {1}' -i <(
        while read -r s p q c; do
            [[ "$s" =~ ^\[([0-9]+)\]([+-])?$ ]]
            printf "%s\\t%s\\t%s\\t%s\\t%s\\n" "${BASH_REMATCH[2]:-.}" "%${BASH_REMATCH[1]}" "$p" "$q" "$c"
        done < <(jobs -l))
}

cz_bluetooth_controller() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bluetooth controller
Select from known bluetooth controllers.
EOF
    req bluetoothctl || return 5
    cz -f 1 -e 'bluetoothctl select {1}' \
       -i <(bluetoothctl list)
}

cz_bluetooth_device() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bluetooth device [CONTROLLER] ...
Select from known bluetooth devices.
EOF
    req bluetoothctl awk || return 5
    local ctrls=("$@")
    if ! (( ${#ctrls[@]} )); then
        mapfile -t ctrls < <(bluetoothctl list | awk '/^Controller/ { print $2 }')
    fi
    cz -f 1 -e 'printf "select %s\nconnect %s" {0} {1} | bluetoothctl' \
       -i <(while read -r c; do
                printf "%s\\n" "select ${c}" "devices" \
                    | bluetoothctl \
                    | awk -v c="${c}" '/^Device/{ $1=""; print c $0 }'
            done < <(printf "%s\\n" "${ctrls[@]}"))
}

cz_bluetooth_paired() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bluetooth paired [CONTROLLER] ...
Select from paired bluetooth devices.
EOF
    req bluetoothctl awk || return 5
    local ctrls=("$@")
    if ! (( ${#ctrls[@]} )); then
        mapfile -t ctrls < <(bluetoothctl list | awk '/^Controller/ { print $2 }')
    fi
    cz -f 1 -e 'printf "select %s\nconnect %s" {0} {1} | bluetoothctl' \
       -i <(while read -r c; do
                printf "%s\\n" "select ${c}" "paired-devices" \
                    | bluetoothctl \
                    | awk -v c="${c}" '/^Device/{ $1=""; print c $0 }'
            done < <(printf "%s\\n" "${ctrls[@]}"))
}

cz_bool() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bool
Select a true or false value.
EOF
    cz -e 'let {2}' -f 0 -i <(printf "%s\\n" "true yes 1" "false no 0")
}

cz_box() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz box
Select an ascii box style then run boxes as a filter with that style.
EOF
    req boxes grep || return 5;
    cz -f 0 -e 'boxes -d {0}' -i <(boxes -l | grep -E '^[[:alnum:]]+$')
}

cz_browser() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz browser [URL] ...
Select browser in which to open the given URLs.
EOF

local urls=("$@")
local browsers=()
while read -r maybe; do
    if type "${maybe%% *}" &>/dev/null; then
        browsers+=("$maybe")
    fi
done <<EOF
xdg-open
chromium
elinks
firefox
google-chrome
links
links2
lynx
mpv
uzbl-browser
EOF
    cz -e "{0} ${urls@Q}" -f 0 -i <(printf "%s\\n" "${browsers[@]}")
}

cz_buku() {
    cz_buku_bookmark "$@"
}

cz_buku_bookmark() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz buku bookmark [QUERY]
Select a buku bookmark then open it in a browser.
EOF
    req buku sed || return 5
    local query="${1:-.}"
    cz -e 'buku -o {0}' -f 1 \
       -i <(buku -f 4 -r "$query" | sed '/^[0-9]/!d;y/\t/ /' )
}

cz_buku_tag() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz buku tag [QUERY]
Select a buku tag.
EOF
    req buku sed || return 5
    local query="${1:-.}" filter=""
    read -r filter <<EOF
[.[] | .tags | split(",")] | flatten | unique | .[] | gsub(" "; "_")
EOF
    cz -e "buku -j -t {0}" -f 0 \
       -i <(buku -j -r "$query" | jq -r "$filter")
}

cz_chemical_element() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz chemical element
Select an element from the periodic table.
EOF
    req curl jq || return 5
    local filter=""
    local url="https://raw.githubusercontent.com/Bowserinator/Periodic-Table-JSON/master/PeriodicTableJSON.json"
    read -r filter <<EOF
.elements[] | [.number, .period, .name, .symbol, .source] | @tsv
EOF
    cz -f 2 -i <(hold -ep -- curl -sS "$url" | jq -r "$filter")
}

colorblock() {
    local use="usage: colorblock HEXCOLOR\\nGenerate an image of a solid block of the chosen color.\\n"
    local color="$1"
    if (( $# > 1 )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    if ! [[ "$color" =~ ^#[[:xdigit:]]{6}$ ]]; then
        printf "Argument does not look like a hexadecimal color.\\n" >&2
        return 2
    fi
    req convert || return 5
    local out="/tmp/${color###}.png"
    if ! convert -size 100x100 xc:"$color" png:"$out"; then
        return 3
    fi
    printf "%s\\n" "$out"
}

cz_color() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz color
Select a hex color by name from available sources.
EOF
    req sort || return 5
    cz -d $'\t' -e "xdg-open \$(colorblock {0})" -f 0 \
       -i <( (insulate ^_CZ_ cz -o xkcd rgb; insulate ^_CZ_ cz -o x11 rgb;) | sort)
}

declare n=""
while read -r n _; do
    eval "cz_compgen_$n() { \
    { hep \"\$_CZ_HELP\" && return; } <<EOF
cz compgen $n [PREFIX]
Select from bash builtin $n completion.
EOF
cz -d '' -f 0 -i <(compgen -A $n -- \"\$1\" | sort);\
}"
done <<EOF
alias
arrayvar
binding
builtin
command
directory
disabled
enabled
export
file
function
group
helptopic
hostname
job
keyword
running
service
setopt
shopt
signal
stopped
user
variable
EOF
unset n

cz_command() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz command
Select a command and run it.
EOF
    cz -g -e '{0}' -f 0 compgen command
}

cz_cowsay() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz command
Select a cowsay filter.
EOF
    cz -g -e "cowsay -n -f {0} -W \"\$COLUMNS\"" -i <(cowsay -l | sed '1d;s/ /\n/g;')
}

cz_crontab() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz crontab
Select a cron job.
EOF
    cz -f 5: -i <(crontab -l | grep -v -e '^[#]' -e '^[[:space:]]*$')
}

cz_cups_option() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz cups option [PRINTER]
Select a CUPS printer then select an option it supports.
EOF
    req lpoptions perl || return 5
    local printer="${1:-$(insulate ^_CZ_ cz -u cups printer)}"
    cz -f "-o {0}={1}" -f 1 \
       -i <(lpoptions -p "$printer" -l \
                | perl -nE 'if (/^((.*)\/)?.*: (.*)/) { printf "%s %s\n", $2, $_ for split(/ /, $3); };')
}

cz_cups_printer() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz cups printer [FILE] [LP OPTIONS]
Select a CUPS printer to which to print FILE.
Print data from stdin by default and if file is '-'.
EOF
    req lpstat lp sed || return 5
    local inp="${1:--}"
    if [[ "$inp" == "-" && ! -t 0 ]]; then
        inp=$(hold -fx -)
    fi
    shift
    local lpopts=""
    if (($#)); then
        lpopts=$(printf "%q " "$@")
    fi
    cz -e "lp -d {1} $lpopts -- ${inp@Q}" -f 1 \
       -i <(lpstat -p | sed -e :a -e '$!N;s/\n[\t]/ /;ta' -e 'P;D')
}

cz_descendant() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz descendant [DIRECTORY]
Select from parent directories.
EOF
    local d="${1:-$PWD}"
    if ! [ -d "$d" ]; then return 2; fi
    cz -e 'cd {0}' find dir "$d"
}

_cz_descendant() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -d -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o dirnames
    fi
}

cz_dict_database() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dict database [QUERY]
Select a dict server database.
EOF
    req dict sed || return 5
    local qry="$1"
    cz -e "dict -d {0} ${qry@Q}" -f 0 -i <(dict -D | sed 1d)
}

cz_dict_strategy() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dict strategy [QUERY]
Select a dict server search strategy.
EOF
    req dict sed || return 5
    local qry="${1}"
    cz -e "dict -s {0} ${qry@Q}" -f 0 -i <(dict -S | sed 1d)
}

cz_dict_word() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dict word [QUERY]
Select a word from a dict server and print its definition.
EOF
    req dict || return 5
    local qry="${1}"

    cz -f 3: -e 'dict -- "{3:@P}"' \
       -i <( if [ -z "$qry" ]; then hold -ep -t 86400 -- dict -m -f -s re "";
             else printf "%s\\n" "here" >&2; dict -m -f -s re "$qry"; fi)
}

cz_dir() {
    cz find dir "$@"
}

cz_dnf_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dnf package
Select a dnf package by name then print info about it.
EOF
    req dnf sed || return 5
    cz -f 0 -e 'dnf info {0}' -i <(dnf list 2>/dev/null | sed 1,2d)
}

cz_dns() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dns HOST
Select from records associated with given host.
EOF
    req dig grep || return 5
    local host="$1"
    if [ -z "$host" ]; then
        return 3
    fi
    local recs=()
    while read -r rtype; do
        local resp="" rec=""
        if ! resp=$(dig "$rtype" "$host" +short) || [ -z "$resp" ]; then
            continue
        fi
        while read -r rec; do
            recs+=("$(printf "%s %s\\n" "$rtype" "$rec")")
        done <<< "$resp"
    done < <(insulate ^_CZ_ cz -o dns rtype | grep -v XFR)
    cz -f 1: -i <(printf "%s\\n" "${recs[@]}")
}

cz_dns_rtype() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dns rtype
Select a DNS rdata type.
EOF
    local rtypes=(A AAAA AFSDB APL CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME
                  DNSKEY DS HINFO HIP IPSECKEY KEY KX LOC MX NAPTR NS NSEC NSEC3
                  NSEC3PARAM OPENPGPKEY PTR RRSIG RP SIG SMIMEA SOA SRV SSHFP TA
                  TKEY TLSA TSIG TXT URI
                  IXFR AXFR OPT)
    cz -i <(printf "%s\\n" "${rtypes[@]}")
}

cz_dns_scan() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dns scan DOMAIN...
Select a record from a DNS scan of the given domain names.
EOF
    req dig grep sort || return 5
    local rtypes=(A AAAA AFSDB APL CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME
                  DNSKEY DS HINFO HIP IPSECKEY KEY KX LOC MX NAPTR NS NSEC NSEC3
                  NSEC3PARAM OPENPGPKEY PTR RRSIG RP SIG SMIMEA SOA SRV SSHFP TA
                  TKEY TLSA TSIG TXT URI OPT)

    local names=("$@")
    if [ -z "${names[*]}" ]; then
        return 3
    fi

    local output=()
    mapfile -t output < \
            <(for name in "${names[@]}"; do
                  for rtype in "${rtypes[@]}"; do
                      { mapfile -t answer < <(dig "$name" "$rtype" +short)
                        if [ -n "${answer[*]}" ]; then
                            printf "${name}\\t${rtype}\\t%s\\n" "${answer[@]}"
                        fi
                      } &
                  done
              done | sort)
    cz -f 2: -i <(printf "%s\\n" "${output[@]}")
}

cz_dns_tld() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dns tld
Select a DNS top-level-domain as recorded by IANA.
EOF
    req curl grep tr || return 5
    local url="https://data.iana.org/TLD/tlds-alpha-by-domain.txt"
    cz -i <(hold -ep curl -sS "$url" | grep -v '^#' | tr '[:upper:]' '[:lower:]')
}

cz_docker_container() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz docker container
Select a docker container.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker container inspect {0}' \
       -i <(docker container ls -a | sed 1d)
}

cz_docker_image() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz docker image
Select a docker image.
EOF
    req docker sed || return 5
    cz -f 2 -e 'docker image inspect {2}' \
       -i <(docker images -a | sed 1d)
}

cz_docker_ps() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz docker ps
Select a running docker container process.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker inspect {0}' \
       -i <(docker ps | sed 1d)
}

cz_env() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz env
Select an environment variable.
EOF
    req env || return 5
    cz -0 -d '=' -f 0 -e "printf '%s\\n' \"\${0}\"" \
       -i <(env -0)
}

cz_fc_font() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz fc font
Select a font file known to fontconfig.
EOF
    req fc-list || return 5
    cz -f 0 -d ':' -i <(fc-list)
}

cz_ffmpeg_decoder() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ffmpeg decoder
Select from decoders supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -decoders | sed 1,10d)
}

cz_ffmpeg_encoder() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ffmpeg encoder
Select from encoders supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -encoders | sed 1,10d)
}

cz_ffmpeg_format() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ffmpeg format
Select from data formats supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -formats | sed 1,4d)
}

cz_figlet() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz figlet
Select a font file usable by figlet.
EOF
    req figlet || return 5
    local fdir="${FIGLET_FONTDIR:-/usr/share/figlet}"
    local menu=()
    for f in "$fdir"/*.{flf,tlf}; do
        menu+=("$(printf "%s %s\\n" "${f##*/}" "${f}")")
    done

    cz -f 0 -g -e "figlet -t -d $fdir -f {0}" \
       -i <(printf "%s\\n" "${menu[@]}")
}

cz_file() {
    cz find file "$@"
}

_cz_file() {
    _cz_find_file "$@"
}

cz_find_dir() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz find dir [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        printf "Expected directory argument: %s\\n" "$dir" >&2
        return 3
    fi
    if type fd &>/dev/null; then
        cz -d '' -0 -f '0@Q' -i <(fd -HLI0g -t d "*${2}*" "${1:-.}")
    elif type find &>/dev/null; then
        cz -d '' -0 -f '0@Q' -i <(find -L "${1:-.}" -iwholename "*${2}*" -type d -print0)
    else
        printf "Either find or fd is required!\\n" >&2
        return 5
    fi
}

_cz_find_dir() {
    _cz_find_file "$@"
}

cz_find_file() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz find file [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        printf "Expected directory argument: %s\\n" "$dir" >&2
        return 3
    fi
    if type fd &>/dev/null; then
        cz -d '' -0 -e "xdg-open {0}" -f 0 -i <(fd -HIL0g -t f "*${2}*" "${1:-.}")
    elif type find &>/dev/null; then
        cz -d '' -0 -e "xdg-open {0}" -f 0 -i <(find -L "${1:-.}" -iwholename "*${2}*" -type f -print0)
    else
        printf "Either find or fd is required!\\n" >&2
        return 5
    fi
}

_cz_find_file() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -d -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o dirnames
    fi
}

cz_firefox_tab() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz firefox tab
Select an open firefox tab.
EOF
    req firefox jq lz4jsoncat || return 5
    local db=("$HOME"/.mozilla/firefox/*.default/sessionstore-backups/recovery.jsonlz4)
    if [ -z "${db[0]}" ]; then
        return 3
    fi
    cz -f 0 -i <(lz4jsoncat "${db[0]}" \
                     | jq -r '.windows[].tabs[].entries[] |  [.url,.title] | @tsv')
}

cz_flatpak_app() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak app
Select an application installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --app)
}

cz_flatpak_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak package [REMOTE]
Select a package available at the given REMOTE then install it.
EOF
    req flatpak || return 5
    local remote="";
    if ! remote="${1:-$(cz -f 0 flatpak remote)}"; then
        return 4
    fi
    cz -f 0 -e "flatpak install ${remote@Q} {0}" -i <(flatpak remote-ls "$remote")
}

cz_flatpak_remote() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak remote
Select a flatpak remote repository by name.
EOF
    req flatpak || return 5
    cz -i <(flatpak remote-list)
}

cz_flatpak_runtime() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak runtime
Select a runtime installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --runtime)
}

cz_gcloud() {
    cz meta gcloud
}

cz_gcloud_auth() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud auth
Select an available google cloud identity.
EOF
    req gcloud jq || return 5
    cz -f 0 -i <(gcloud auth list --format=json | jq -r '.[] | [.account, .status] | @tsv')
}

cz_gcloud_bq_dataset() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bq dataset [PROJECT]
Select a Google BigQuery dataset and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    cz -f 0 -i <(bq --format json --project_id "$proj" ls \
                    | jq -r '.[] | [.id, (.datasetReference | (.datasetId, .projectId)), .location] | @tsv')
}

cz_gcloud_bq_table() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bq table [PROJECT] [DATASET]
Select a Google BigQuery table from a dataset and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then
        return 2
    fi
    local ds="${2:-$(insulate ^_CZ_ cz -u gcloud bq dataset "${proj@Q}")}"
    if [ -z "$ds" ]; then
        return 2
    fi
    cz -f 0 -i <(bq --format json --project_id "$proj" ls "$ds" \
                    | jq -r '.[] | [.id, (.tableReference | (.tableId, .datasetId, .projectId)), .type] | @tsv')
}

cz_gcloud_bucket() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bucket
Select a google cloud storage bucket.
EOF
    req gsutil || return 5
    cz -i <(gsutil ls)
}

cz_gcloud_bucket_file() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bucket file [BUCKET]
Select a file from a google cloud storage bucket.
EOF
    req gsutil || return 5
    local b="${1:-$(insulate ^_CZ_ cz -u gcloud bucket)}"
    if [ -z "$b" ]; then return 2; fi
    cz -f 2 -i <(gsutil ls -lr "$b"'**' | sed '$d')
}

cz_gcloud_compute_address() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute address [PROJECT]
Select a Google cloud compute address and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format=json compute addresses describe --region {2} {1}" \
       -i <(gcloud --project="$proj" compute addresses list --format=json \
                | jq -r '.[] | [.address, .name, (.region), .status, .description] | @tsv')
}

cz_gcloud_compute_disk() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute disk [PROJECT]
Select a Google cloud compute disk and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project ${proj@Q} --format=json compute disks describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format=json compute disks list \
                | jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .sizeGb, .status] | @tsv')
}

cz_gcloud_compute_image() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT]
Select a Google cloud compute image and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute images describe {0} " \
       -i <(gcloud --project "$proj" --format json compute images list \
                | jq -r '.[] | [.name, .creationTimestamp, .description ] | @tsv')
}

cz_gcloud_compute_instance() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute instance [PROJECT]
Select a Google cloud compute instance and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project ${proj@Q} --format json compute instances describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format json compute instances list \
                | jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .networkInterfaces[0].networkIP // "-", .accessConfigs[0].natIP // "-", .status] | @tsv')
}

cz_gcloud_compute_instance_group() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute instance group [PROJECT]
Select a Google cloud compute instance group and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute instance-groups describe {1}" \
       -i <(gcloud --project "$proj" --format=json compute instance-groups list \
                | jq -r '.[] | [.id, .name, .creationTimestamp] | @tsv')
}

cz_gcloud_compute_instance_template() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute instance template [PROJECT]
Select a Google cloud compute instance template and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute instance-templates describe {0}" \
       -i <(gcloud --project "$proj" --format=json compute instance-templates list \
                | jq -r ".[] | [.name, .creationTimestamp, .description ] | @tsv")
}

cz_gcloud_compute_machine_type() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute machine type [PROJECT] [ZONE]
Select a Google cloud compute instance type.
EOF
    req gcloud jq sort || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    local zone="${2:-$(insulate ^_CZ_ cz -u gcloud compute zone )}"
    if [ -z "$zone" ]; then return 2; fi
    cz -f 1 \
       -i <(gcloud --project="$proj" --format=json compute machine-types list --filter=zone="$zone" \
                | jq -r '.[] | [.id, .name, .description] | @tsv' | sort)
}

cz_gcloud_compute_mig() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute instance group [PROJECT]
Select a Google cloud compute managed instance group and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute instance-groups managed describe {1}" \
       -i <(gcloud --project "$proj" --format=json compute instance-groups managed list \
                | jq -r '.[] | [.id, .name, .creationTimestamp] | @tsv')
}

cz_gcloud_compute_network() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute network [PROJECT]
Select a Google cloud network and describe it in JSON.
EOF
        req gcloud jq || return 5
        local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
        if [ -z "$proj" ]; then return 2; fi
        cz -f 0 -e "gcloud --project ${proj@Q} --format json compute networks describe {0}" \
           -i <(gcloud --project "$proj" --format json compute networks list \
                    | jq -r '.[] | [.name, .id, .creationTimestamp] | @tsv')
}

cz_gcloud_compute_region() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute region
Select a Google cloud region and describe it in JSON.
EOF
        req gcloud jq || return 5
        cz -f 1 -e 'gcloud compute regions describe {1}' \
           -i <(hold -ept 86400 -- gcloud --format=json compute regions list \
                    | jq -r '.[] | [.id, .name, .description] | @tsv')
}

cz_gcloud_compute_snapshot() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute snapshot
Select a Google cloud disk snapshot and describe it in JSON.
EOF
        req gcloud jq || return 5
        local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
        if [ -z "${proj@Q}" ]; then return 2; fi
        cz -f 1 -e "gcloud --project ${proj@Q} compute snapshots describe {1}" \
           -i <(gcloud --project "$proj" --format=json compute snapshots list \
                    | jq -r '.[] | [.id, .name, .status] | @tsv')
}

cz_gcloud_compute_subnet() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud subnet [PROJECT]
Select a Google cloud subnet and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 2 -e "gcloud --project ${proj@Q} --format json compute networks subnets describe {2}" \
       -i <(gcloud --project "$proj" --format json compute networks subnets list \
                | jq -r '.[] | [(.region | split("/") | .[-1]), .name, .id, .gatewayAddress, .ipCidrRange, .purpose] | @tsv')
}

cz_gcloud_compute_zone() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute zone
Select a Google cloud zone and describe it in JSON.
EOF
        req gcloud jq || return 5
        cz -f 1 -e "gcloud compute zones describe {1}" \
           -i <(hold -ept 86400 -- gcloud --format=json compute zones list \
                    | jq -r '.[] | [.id, .name, .description] | @tsv')
}

cz_gcloud_dns_record() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT] [ZONE]
Select a Google cloud DNS record and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    local zone="${2:-$(insulate ^_CZ_ cz -u gcloud dns zone "$proj")}"
    if [ -z "$proj" ] || [ -z "$zone" ]; then return 2; fi
    cz -f 0,1 \
       -i <(gcloud --project "$proj" --format json dns record-sets list -z "$zone" \
                | jq -r '.[] | [.type, .name, .ttl, .rrdatas[]] | @tsv')
}

cz_gcloud_dns_zone() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud dns zone [PROJECT]
Select a Google cloud DNS zone and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json dns managed-zones describe {0}" \
       -i <(gcloud --project "$proj" --format json dns managed-zones list \
                | jq -r '.[] | [.name, .dnsName, .visibility, .description] | @tsv')
}

cz_gcloud_log() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud log [PROJECT]
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud logging read 'logName : {0}' --project=${proj@Q} --limit 10 --format=json" \
       -i <(gcloud --format=json --project "$proj" logging logs list | jq -r '.[]')
}

cz_gcloud_organization() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud organization
Select a Google cloud organization and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f 1 -e 'gcloud organizations describe {1} --format=json' \
       -i <(gcloud organizations list  --format=json \
                | jq -r '.[0] | [.creationTime, .name, .displayName, .lifecycleState ] | @tsv')
}

cz_gcloud_permission() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud permission [RESOURCE]
Select a Google cloud permission and describe it in JSON.
If a resource URL argument is given only list applicable permissions.
By default list all permissions on the selected organization.
EOF
    req gcloud jq || return 5
    local url="${1}"
    if [ -z "$url" ]; then
        local org=""
        if org=$(insulate ^_CZ_ cz -u gcloud organization); then
            url="//cloudresourcemanager.googleapis.com/$org"
        else
            return 2
        fi
    fi
    cz -f 0 \
       -i <(gcloud iam list-testable-permissions "$url" --format=json \
                | jq -r '.[] | [.name, .stage, .title // "-"] | @tsv')
}

cz_gcloud_project() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud project
Select a Google cloud project and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f '0@C' -e 'gcloud --format json projects describe {0}' \
       -i <(gcloud --format json projects list \
                | jq -r '.[] | [.projectId, .projectNumber, .name] | @tsv')

}

cz_gcloud_pubsub_subscription() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud pubsub subscription [PROJECT]
Select a Google pubsub subscription and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json pubsub subscriptions describe {0}" \
       -i <(gcloud --project "$proj" pubsub subscriptions list --format=json \
                | jq -r '.[] | [(.name | split("/") | .[-1]), (.topic | split("/") | .[-1]) ] | @tsv')
}

cz_gcloud_pubsub_topic() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud pubsub topic [PROJECT]
Select a Google pubsub topic and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json pubsub topics describe {0}" \
       -i <(gcloud --project "$proj" pubsub topics list --format=json \
                | jq -r '.[] | [.name | split("/") | .[-1] ] | @tsv')
}

cz_gcloud_role() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud role [PROJECT]
Select a Google cloud IAM role and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json iam roles describe {0}" \
       -i <(gcloud --project "$proj" --format json iam roles list \
                | jq -r '.[] | [.name, .description] | @tsv')
}

cz_gcloud_sd_endpoint() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud sd endpoint [SERVICE]
Select a Google cloud service directory endpoint associated with the given service.
EOF
    local svc="${1:-$(insulate ^_CZ_ cz -u gcloud sd service)}"
    cz -f 0 -e 'gcloud service-directory endpoints describe --format=json {2}' \
       -i <(gcloud service-directory endpoints list --format=json --service "$svc" \
                | jq -r '.[] | [.address, .port, .name] | @tsv')
}

cz_gcloud_sd_namespace() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud sd namespace [PROJECT] [REGION]
Select a Google cloud service directory namespace.
EOF
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    local region="${2:-$(insulate ^_CZ_ cz -u gcloud compute region)}"
    cz -f 0 -i <(gcloud service-directory namespaces list --project="$proj" --format=json --location="$region" \
                     | jq -r '.[].name')
}

cz_gcloud_sd_service() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud sd service [NAMESPACE]
Select a Google cloud service directory service from the given namespace.
EOF
    local ns="${1:-$(insulate ^_CZ_ cz -u gcloud sd namespace)}"
    cz -f 0 -e 'gcloud service-directory services resolve {0}' \
       -i <(gcloud service-directory services list --format=json --namespace "$ns" \
                | jq -r '.[].name')
}

cz_gcloud_serviceaccount() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud serviceaccount [PROJECT]
Select a Google cloud service account and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json iam service-accounts describe {0}" \
       -i <(gcloud --project "$proj" --format json iam service-accounts list \
                | jq -r '.[] | [.email, .displayName, .email] | @tsv')
}

cz_gh_gist() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh gist
Select a Github gist and view it.
EOF
    req gh || return 5
    cz -e 'gh gist view {0}' -f 0 -i <(gh gist list)
}

cz_gh_issue() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh issue
Select a Github issue and view it.
EOF
    req gh || return 5
    cz -e 'gh issue view {0}' -f 0 -i <(gh issue list)
}

cz_gh_pr() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh pr
Select a Github pull request and view it.
EOF
    req gh awk || return 5
    cz -e 'gh pr view {1}' -f 2 \
       -i <(gh pr list --limit 100 | awk -F $'\t' '{ print $4, $1, $3, $2 }' )
}

cz_gh_release() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh release
Select a Github release and view it.
EOF
    req gh || return 5
    cz -e 'gh release view {0}' -f 1 -i <(gh release list)
}

cz_git_branch() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git branch [DIRECTORY]
Select a branch from the git repository in DIRECTORY.
EOF
    req git sed || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" branch -avv | sed 's/^[* ] //')
}

cz_git_commit() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git commit [DIRECTORY] [FILE]
Select a commit from the history of the git repository in DIRECTORY.
Given FILE, select a commit that modified that file.
EOF
    req git || return 5
    local repo="${1:-.}"
    local file="${2:-.}"
    cz -f 0 -e "git -C ${repo@Q} show {0}" \
       -i <(git -C "$repo" log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit -- "$file")
}

cz_git_config() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git config [LOCATION]
Select from git configuration items.
Given a location list only items from the matching config.
Locations: global, local, worktree, system, and all - the default
EOF
    req git || return 5
    local scope="${1:-all}" type="${2}"
    local args=()
    case "$scope" in
        'all') : ;;
        'global') args+=('--global') ;;
        'local') args+=('--local') ;;
        'system') args+=('--system') ;;
        'worktree') args+=('--worktree') ;;
        *) printf "Unknown config location: %s\\n" "$scope" >&2; return 2 ;;
    esac
    cz -d '=' -f 0 -e "git config ${args[*]} --get {0}" \
       -i <(eval git config "${args[*]}" -l)
}

_cz_git_config() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if (("${#words[@]}" < 2)); then
        if [[ "$curr" == "${words[0]}" ]]; then
            compgen -W all global local system worktree -- "$curr"
        fi
    fi
}

cz_git_diff() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git diff [DIRECTORY] [BRANCH]
Select a file in git repo in the given directory that differs from the given
branch. If unspecified the branch will be selected interactively.
EOF
    req git || return 5
    local repo="${1:-.}"
    local branch="${2:-$(insulate ^_CZ_ cz -u -f 0 git branch "$repo")}"
    if [ -z "$branch" ]; then return 2; fi
    cz -f 0 -e "git -C ${repo@Q} diff ${branch@Q} -- {0}" \
       -i <(git -C "$repo" diff --name-only "$branch")
}

cz_git_file()  {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git file [DIRECTORY]
Select a file managed by the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 4: -i <(git -C "$repo" ls-tree -rl HEAD)
}

cz_git_pickaxe() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git pickaxe [DIRECTORY] [TERM]
Select a commit from the history of the git repository in DIRECTORY.
EOF
        req git || return 5
        local repo="${1:-.}"
        local term="${2:-.}"
        cz -f 0 -e "git -C ${repo@Q} show {0}" \
                -i <(git -C "$repo" log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit -S "$term")
}

cz_git_remote() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git remote [DIRECTORY]
Select a remote repository known to the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 1 -i <(git -C "$repo" remote -v)
}

cz_git_status() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git status [DIRECTORY]
Select a modified file in the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 1 -e "git -C ${repo@Q} diff {1}" \
       -i <(git -C "$repo" status -sbu | grep -v ^#)
}

cz_git_tag() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git tag [DIRECTORY]
Select a tag from the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" tag)
}

cz_git_worktree() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git worktree [DIRECTORY]
Select a worktree associated with the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" worktree list)
}

cz_gpg_decrypt() {
    cz -e 'gpg -d -a -r {0}' gpg seckey
}

cz_gpg_encrypt() {
    cz -e 'gpg -e -a -r {0}' gpg pubkey
}

cz_gpg_pubkey() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gpg key
Select a gpg public key from the default keyring.
EOF
    req gpg awk sort || return 5
    local format=""
    read -r -d '' format <<EOF
/^pub/ { t=\$2; s=\$3; (\$6 != "") ? e=\$6 : e="-"; u=""; };
/^ +[0-9A-F]+/{ k=\$2; };
/^uid/ { \$1=\$2=""; u=u\$0 };
/^sub/ { print k, t, s, e, u; };
EOF
    cz -g -e 'gpg -e -a -r {0}' -f 0 -i <(gpg -k | awk -F"[][[:space:]]+" "$format" | sort -u)
}

cz_gpg_seckey() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gpg seckey
Select a gpg secret key from the default keyring.
EOF
    req gpg awk sort || return 5
    local format=""
    read -r -d '' format <<EOF
/^sec/ { t=\$2; s=\$3; (\$6 != "") ? e=\$6 : e="-"; u=""; };
/^ +[0-9A-F]+/{ k=\$2; };
/^uid/ { \$1=\$2=""; u=u\$0 };
/^ssb/ { print k, t, s, e, u; };
EOF
    cz -g -e 'gpg -d -a -r {0}' -f 0 -i <(gpg -K | awk -F"[][[:space:]]+" "$format" | sort -u)
}

cz_grep() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz grep PATTERN [TARGET]
Select a file and line matching grep results for PATTERN in TARGET.
If TARGET is a directory search it recursively.
EOF
    local pattern="${1}"
    if [[ -z "$pattern" ]]; then
       return 2
    fi
    shift
    local targets=("${@:-.}")
    local matches=""
    if type rg &>/dev/null; then
        matches=$(rg --hidden -Hn -- "$pattern" "${targets[@]}")
    elif type grep &>/dev/null; then
        matches=$(grep -r -Hn -- "$pattern" "${targets[@]}")
    else
        printf "Either grep or rg is required!\\n" >&2
        return 5
    fi
    cz -d ':' -f "0,1" -e "${EDITOR@Q} +{1} -- {0}" \
       -i <(printf "%s\\n" "$matches")
}

_cz_grep() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -W "." -- "$curr")
        COMPREPLY=("${reply[@]}")
    else
        mapfile -t reply < <(compgen -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
    fi
}

cz_haskell_installed() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz haskell installed
Select an installed haskell cabal package then show info about it.
EOF
    req cabal || return 5
    cz -f 0 -e 'cabal info {0}' -f 0 \
       -i <(hold -ept 300 -- cabal list --installed --simple-output)
}

cz_haskell_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz haskell package
Select a haskell cabal package then show info about it.
EOF
    req cabal || return 5
    cz -e 'cabal info {0}' -f 0 \
       -i <(hold -ept 300 -- cabal list --simple-output)
}

cz_hg_branch() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz hg branch [DIRECTORY]
Select a branch in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg -R "${1:-.}" branches)
}

cz_hg_revision() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz hg revision [DIRECTORY]
Select a revision in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg log -T '{rev} {branch} {user} {date} {desc|firstline}\n' "${1:-.}")
}

cz_hg_status() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz hg status [DIRECTORY]
Select a modified file in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 1 -i <(hg -R "${1:-.}" status)
}

cz_html_element() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz html element [HTML-FILE] [< HTML-STREAM]
Select a HTML element by xpath string and print it.
EOF
    req xmllint || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    xmllint --html --xmlout "$f" 2>/dev/null | cz xml element
}

cz_html_value() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz html value [FILE] [< STREAM]
Select a HTML element by xpath string and extract its contents.
EOF
    req xmllint || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    xmllint --html --xmlout "$f" 2>/dev/null | cz xml value
}

cz_http_status() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz http status
Select an HTTP status code.
EOF
    req awk curl tr || return 5
    local url="https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv"
    cz -d, -f1 -i <(hold -ep curl -fsS "$url" | tr -d $'\r' | awk 'NR == 1{ }; NR != 1 { print $0; }')
}

cz_i3_bind() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 bind
Select a bindsym from the current i3 configuration.
EOF
    req i3-msg grep sort || return 5
    cz -f 2: -i <(i3-msg -t get_config | grep ^bindsym | sort)
}

cz_i3_mark() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 mark
Select an i3 window mark then move focus to the marked window.
EOF
    req i3-msg jq || return 5
    cz -f 0 -e 'i3-msg "[con_mark={0@C}] focus"' \
       -i <(i3-msg -t get_marks | jq -r '.[]')
}

cz_i3_output() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 output
Select an i3 recognized output device.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.[] | select(.active)
    | [ .name,
        "\\(.rect.width)x\\(.rect.height)",
        "\\(.rect.x),\\(.rect.y)",
        .current_workspace // "-"
      ] | join(" ")
EOF
    cz -f 0 \
       -i <(i3-msg -t get_outputs | jq -r "$filter")
}

cz_i3_window() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 window
Select a i3 window then move focus to that window.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.. | select(.id? and .type == "con" and .nodes == [])
   | [ (.id | tostring), .output, .name] | join(" ")
EOF
    cz -f 0 -e 'i3-msg "[con_id={0@C}] focus"' \
       -i <(i3-msg -t get_tree | jq -r "$filter")
}

cz_i3_workspace() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 workspace
Select an i3 workspace then switch to that workspace.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.[] | [ (.num | tostring), .name, .output, if .urgent then "*" else "" end ] | join(" ")
EOF
    cz -f 0 -e 'i3-msg workspace {0}' \
       -i <(i3-msg -t get_workspaces | jq -r "$filter")
}

cz_info()  {
    { hep "$_CZ_HELP" && return; } <<EOF
cz info [QUERY]
Select an info page matching QUERY and open it for reading.
EOF
    req info || return 5
    cz -e 'info {0}' -i <(info -k "${1:-.}")
}

cz_ip_addr4() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -4 addr)
}

cz_ip_addr6() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -6 addr)
}

cz_ip_route4() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -4 route)
}

cz_ip_route6() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -6 route)
}

cz_iso_country() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz iso country
Select from ISO 3166-2 country names.
EOF
    req isoquery sed || return 5
    cz -d $'\t' -f 3 -i <(isoquery -i 3166-1 | sed ':1;s/\t\t/\t_\t/g;t1;')
}

unicode_flag() {
    local code="$1"
    # cz -o unicode character 'Enclosed Alphanumeric Supplement' | awk -F: '/REGIONAL INDICATOR/{ print $1 }'
    local ris=(🇦 🇧 🇨 🇩 🇪 🇫 🇬 🇭 🇮 🇯 🇰 🇱 🇲 🇳 🇴 🇵 🇶 🇷 🇸 🇹 🇺 🇻 🇼 🇽 🇾 🇿)
    local char="" ord=""
    while read -r -n1 char; do
        ord=$(LC_CTYPE=C printf '%d' "'$char")
        if ! ((ord)); then continue; fi
        printf "%s" "${ris[ord - 65]}"
    done <<< "$code"
}

cz_iso_language() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz iso country
Select from ISO 639-2 language names.
EOF
    req isoquery sed || return 5
    cz -d $'\t' -f 3 -i <(isoquery -i 639-2 | sed ':1;s/\t\t/\t_\t/g;t1;')
}

cz_iso_state() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz iso state
Select from ISO 3166-2 country subdivision names.
EOF
    req isoquery sed || return 5
    cz -d $'\t' -f 2 -i <(isoquery -i 3166-2 | sed ':1;s/\t\t/\t_\t/g;t1;')
}

cz_ispell() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ispell < MISPELLED > FIXED
Select options for mispelled words in the input text.
Print text with updated to replace words with selections.
EOF
    req ispell || return 5
    # parse ispell spellcheck output
    mapfile -t lines
    local line="" index=0 fix=""
    while read -r symbol rest; do
        line="${lines[$index]}"
        case "$symbol" in
            '') # next
                (( index++ ))
                continue
                ;;
            '?') # guess
                : ;;
            '&') # miss
                read -r bad _ _ sug   <<< "$rest"
                IFS=', ' read -r -a fixes <<< "$sug"
                fix=$(printf "%s\\n" "$bad" "${fixes[@]}" | cz)
                if [ -n "$fix" ]; then
                    lines["$index"]="${line/$bad/$fix}"
                fi
                ;;
            '#') # no guess
                continue
                ;;
            '*') # okay
                continue
                ;;
            '+') # root
                continue
                ;;
        esac
    done < <(printf "%s\\n" "${lines[@]}" | ispell -a)
    printf "%s\\n" "${lines[@]}"
}

cz_jq() {
    cz jq json "$@"
}

_cz_jq() {
    _cz_jq_json "$@"
}

cz_jq_json() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz jq json [JSON-FILE] [< JSON-STREAM]
Select from jq path strings for each scalar within the input file or stream
 then use that path to extract the JSON element.
EOF
    req jq || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    read -r -d '' filter <<EOF
. as \$r
| path(..) | . as \$p
| \$r | getpath(\$p) as \$v
| select(\$v | scalars) |
[
 ("." + (\$p | map("[\\(tojson)]") | join(""))),
 (\$v)
] | @tsv
EOF
    cz -d $'\t' -f 0 -e "jq -r {0} ${f@Q}" < <(jq -r "$filter" "$f")
}

_cz_jq_json() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -W "-" -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
    fi
}

cz_jq_toml() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz jq toml [TOML-FILE] [< TOML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the TOML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    local t
    if ! t=$(perl -MTOML -MJSON -E 'say encode_json(from_toml(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq scalar <<< "$t"
}

_cz_jq_toml() {
    _cz_jq_json "$@"
}

cz_jq_yaml() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz jq yaml [YAML-FILE] [< YAML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the YAML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    local y
    if ! y=$(perl -MYAML -MJSON -E 'say encode_json(Load(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq json <<< "$y"
}

_cz_jq_yaml() {
    _cz_jq_json "$@"
}

cz_kill() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz kill [PID]
Select a running process then select a signal and send it to the selected process.
EOF
    local pid=""
    if ! pid="${1:-$(insulate ^_CZ_ cz -u process)}"; then
        return 2
    fi
    cz -e "kill -s {0} ${pid@Q}" signal
}

cz_lastpass() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz lastpass
Select the ID of a LastPass entry then look up the password component.
EOF
    req lpass || return 5
    local lpmenu=()
    local pat='^(.*[^/]) \[id: ([[:digit:]]+)\]$'
    while read -r item; do
        if [[ "$item" =~ $pat ]]; then
            lpmenu+=("${BASH_REMATCH[2]} ${BASH_REMATCH[1]}")
        fi
    done < <(lpass ls)
    cz -e "lpass show --password {0}" < <(printf "%s\\n" "${lpmenu[@]}")
}

cz_line() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz line [FILE] [< STREAM]
Select a line number from the input file or stream.
EOF
    req sed || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -e "sed -n {0}p ${f@Q}" -f 0 < <(sed '=' "$f" | sed '/./N;s/\n/ /')
}

_cz_line() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -W "-" -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
    fi
}

cz_locate() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz locate [GLOB ...]
Select a file from the locate database matching the given glob strings.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 "${@:-$PWD}")
}

cz_locate_regex() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz locate regex [PATTERN ...]
Select a file from the locate database matching the given regular expressions.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 -r "${@:-.}")
}

cz_man() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz man [QUERY]
Select a manual page matching the given query and open it for reading.
EOF
    req man sed || return 5
    cz -f 0 -e 'man {0}' -i <(man -k "${1:-.}" | sed 's/ (/./;s/)//')
}

cz_mimetype() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mimetype
Select a mimetype and related file extensions.
EOF
    req grep /etc/mime.types || return 5
    cz -f 0 -i <(grep -v -e '^#' -e '^$' /etc/mime.types)
}

cz_mount() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mount
Select a mountpoint.
EOF
    req mount || return 5
    cz -f 2 -i <(mount)
}

cz_mpd_find() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd find [TYPE] [QUERY]
Select an mpd tag of the given kind then select for songs matching that tag.
EOF
    req mpc || return 5
    local kind="${1:-$(insulate ^_CZ_ cz -u mpd type)}"
    if [ -z "$kind" ]; then return 2; fi
    local query="${2:-$(insulate ^_CZ_ cz -u mpd tag "$kind")}"
    if [ -z "$query" ]; then return 2; fi
    cz -d '' -e 'mpc add {0:}' -f 0 -i <(mpc search "$kind" "$query")
}

cz_mpd_output() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd output and toggle it between enabled and disabled.
EOF
    req grep mpc || return 5
    cz -e "mpc toggleoutput {1}" -i <(mpc outputs | grep -v '^[[:space:]]')
}

cz_mpd_playlist() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd playlist then load it replacing the current playlist.
EOF
    req mpc || return 5
    cz -e "mpc clear && mpc load {0} && mpc play" -i <(mpc lsplaylists)
}

cz_mpd_seek() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd seek
Select a percentage of the current song then seek to that position.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc seek {0}" \
       -i <(printf "%s%%\\n" {100..0..5})
}

# generate MPD tag related functions
for t in artist album title track name genre date composer performer comment disc filename; do
    eval "
cz_mpd_tag_$t() {
    { hep \"\$_CZ_HELP\" && return; } <<EOF
cz mpd $t
Select from available mpd database $t tags.
EOF
    req mpc || return 5
    cz -d '' -f 0 -i <(mpc list $t)
}"
done
unset t

cz_mpd_track() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd track
Select a track number from the current mpd playlist then play that track.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc play {0}" \
       -i <(hold -ept 30 -- mpc -f '%position% [%artist% - %album% - %title%] --  %file%' playlist)
}

cz_mpd_type() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd type
Select an mpd tag type.
EOF
    req mpc || return 5
    cz argv artist album title track name genre date composer performer comment disc filename
}

scryfalldata() {
    req curl jq || return 5
    local bulk=""
    if ! bulk=$(hold -e -n scryfallbulk -t 604800 -- \
                     curl -sS https://api.scryfall.com/bulk-data); then
        return 2
    fi
    local url=""
    if ! url=$(hold -p -e -n scryfallurl -t 604600 -- \
                    jq -r '.data[] | select(.type == "oracle_cards") | .download_uri' < "$bulk"); then
        return 2
    fi
    hold -e -p -n scryfalldata -t 604800 -- curl -sS "$url"
}

cz_mtg_card() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mtg card
Select an MTG card by name using data from scryfall.com.
EOF
    req curl jq sort || return 5
    local filter='.[] | [.set,  .name, (.scryfall_uri | split("?"))[0]] | @tsv'
    local cards=""
    if ! cards=$(hold -g -t 3600 || hold -f <(scryfalldata | jq -r "$filter" | sort -u)); then
        return 2
    fi
    cz -d $'\t' -e 'xdg-open {2}' -f 2 -i "$cards"
}

cz_mtg_set() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mtg set
Select an MTG set by name using data from scryfall.com.
EOF
    req curl sort || return 5
    local url=""
    if ! sets=$(hold -pe -n scryfallsets -t 86400 -- curl -sS https://api.scryfall.com/sets \
                    | jq -r '.data[] | [.released_at, .code, .name ] | @tsv'); then
        return 2
    fi
    cz -d $'\t' -e 'xdg-open https://scryfall.com/sets/{1}' -f 1 -i <(sort -u <<< "${sets[@]}")
}

cz_notmuch() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz notmuch QUERY
Select a message matcing the given query of a notmuch mail index.
EOF
    req getent || return 5
    cz -e 'notmuch show {0}' -f 0 -i <(notmuch search "$@")
}

cz_nss_group() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss group
Select a system group.
EOF
    req getent || return 5
    cz -f 0 -d : -i <(getent group)
}

cz_nss_host() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss host
Select a host from the system host name database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent hosts)
}

cz_nss_network() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss network
Select a network from the system network database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent networks)
}

cz_nss_passwd() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss passwd
Select a system user from the system user database.
EOF
    req getent || return 5
    cz -f 0 -d ':' -i <(getent passwd)
}

cz_nss_protocol() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss protocol
Select a protocol from the system protocol database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent protocols)
}

cz_nss_service() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss service
Select a service from the system service database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent services)
}

# TODO maybe write a function to accept only the given options from given arguments.
# mapfile -t opts < <(cleanopts "a:bcd:" "$@")
# Format the strings so they can be appended into a command array.
cz_oaf_format() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz oaf format [LANGUAGE] < STREAM
Quote given input into the selected document quote format.
See https://metacpan.org/pod/App::oaf for installation.
EOF
    req oaf perl || return 5
    local lang="${1:-text}"
    cz -f 0 -e "oaf -l ${lang@Q} -f {0}" -g -i <(oaf -p)
}

cz_pandoc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pandoc [FILE]
Select a pandoc output format then convert the given file into that format.
If the file argument is omitted input is read from stdin.
EOF
    req pandoc || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -g -f 0 -e "pandoc -t {0} -o - ${f@Q}" -i <(pandoc --list-output-formats)
}

_cz_pandoc() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -W "-" -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
    fi
}

cz_pass() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pass
Select an entry from a pass directory and print its contents.
EOF
    req pass find sed || return 5
    local pdir="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
    cz -f 0 -e 'pass show {0} | sed -n 1p' \
       -i <(find "$pdir" -type f -name '*.gpg' | sed "s#\\.gpg##; s#$pdir##")
}

cz_pci() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pci
Select a PCI device.
EOF
    req lspci || return 5
    cz -f 0 -i <(lspci)
}

cz_perl_doc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz perl module
Select a perl internal document.
EOF
    req perl || return 5
    cz -e 'perldoc {0}' -f 0 \
       -i <(perldoc perl | sed -n '/-/d;/^[ ]*perl/{ s/^[ ]*//; p};')
}

cz_perl_module() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz perl module
Select an installed perl module.
EOF
    req perl || return 5
    cz -e 'perldoc {0}' -f 0 -i <(perl -MExtUtils::Installed  -E 'say for ExtUtils::Installed->new->modules')
}

cz_pokemon() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pokemon
Select a pokemon by name or ID.
EOF
    req curl jq || return 5
    local url="https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json"
    read -r -d '' filter <<EOF
.[] | [.id, (.name.english | sub(" "; "_")), (.type | join(","))] | @tsv
EOF
    cz -d $'\t' -e 'xdg-open https://bulbapedia.bulbagarden.net/wiki/{1}' -f 1 \
       -i <(hold -g -p -t 604800 || hold -f -p -x <(curl -sS "$url" | jq -r "$filter"))
}

cz_process() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz process
Select a system process by PID.
EOF
    req ps || return 5
    local idx=0 cols=() table=()
    mapfile table < <(ps ux)
    read -r -a cols <<< "${table[0]}"
    for ((idx=1; idx <= "${#cols[@]}"; idx++)) ; do
        if [[ "${cols[$idx]}" =~ ^(pid|PID)$ ]]; then break; fi
    done
    cz -f "$idx" <<< "${table[@]:1}"
}

cz_pulseaudio_input() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio input
Select a pulseaudio sink input.
EOF
    req pactl perl || return 5
    read -r -d '' filter <<EOF
BEGIN { use strict; use warnings; my (%d, \$i); };
if (/^\\w.*#(\\d+)/) { \$i = \$1; };
if (/Sink: (\\d+)/) {\$d{\$i}->{sink} = \$1;};
if (/application.process.binary = "(.+)"/) {\$d{\$i}->{name} = \$1;};
END { say join "\\t", \$_, \$d{\$_}->{sink}, \$d{\$_}->{name} for (keys %d) };
EOF
    cz -f 0 -e 'cz -e "pactl move-sink-input {0} {{0}" pulseaudio sink' \
       -i <(pactl list sink-inputs | perl -nE "$filter")
}

cz_pulseaudio_sink() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio sink
Select a pulseaudio sink and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-sink-mute {0} toggle' -i <(pactl list short sinks)
}

cz_pulseaudio_sink_volume() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio sink volume
Select a pulseaudio sink and a percentage to set its volume.
EOF
    req pactl || return 5
    local sink
    if ! sink=$(cz -u pulseaudio sink); then return 2; fi
    cz -f 0 -e "pactl set-sink-volume ${sink@Q} {0}" -i <(printf "%s%%\\n" {100..0..5})
}

cz_pulseaudio_source() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio source
Select a pulseaudio source and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-source-mute {0} toggle' \
       -i <(pactl list short sources)
}

cz_pwgen() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pwgen [LENGTH]
Select a generated password of given length.
EOF
    req pwgen || return 5
    local len="${1:-20}"
    cz -f 0 -i <(pwgen -1 -s "$len" 50)
}

cz_pydoc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pydoc
Select a python document and open it for reading.
EOF
    req pydoc || return 5
    cz -f 0 -e "pydoc {0}" -i <(hold -ept 86400 -- pydoc -k .)
}

cz_python_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz python installed
Select an installed python package and show info about it.
EOF
    req pip || return 5
    cz -f 0 -e "pip show {0}" \
       -i <(pip list --format=json | jq -r '.[] | [.name, .version] | @tsv')
}

cz_radio_station() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz radio station
Select a radio station stream and open it to play.
EOF
    req curl || return 5
    local pat="${1:-.}"
    local json="" url="http://all.api.radio-browser.info/json/stations"
    if ! json=$(hold -n radio_browser_all -e -t 604800 -- curl -sS "$url"); then
        return 2
    fi
    read -r -d '' filter <<EOF
.[] | [
 if .countrycode == "" then "_" else .countrycode end,
 if .state == "" then "_" else .state end,
 .name,
 .url
] | @tsv
EOF
    cz -d $'\t' -e 'mpv {3}' -f 3 \
       -i <(hold -p -e -- jq -r "$filter" "$json" | grep "$pat" | sort)
}

cz_raku_installed() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz raku installed
Select an install raku modules.
EOF
    req sed zef || return 5
    cz -f 0 -e 'zef info {0}' -i <(zef list -i)
}

cz_raku_module() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz raku module
Select an available raku module.
EOF
    req sed zef || return 5
    if (("$#")); then
        cz -f 0 -e 'zef install {0}' \
           -i <(zef search "$@" | awk -F'|' '/^[[:digit:]]/{ print $3, $4 }')
    else
        cz -f 0 -e 'zef install {0}' \
           -i <(hold -ept 86400 -- zef list)
    fi
}

cz_rfc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz rfc
Select an internet RFC and open it for reading.
EOF
    read -r -d '' filter <<EOF
BEGIN { my (\$x, \$n); };
if (/^[[:digit:]].*/) { \$n++; say \$x if \$x; \$F[0] =~ s/^0+//; \$x = join " ", @F[0..\$#F]; }
else { if (\$n) { s/^\\s+//; \$x .= \$_ }; };
END { say \$x if \$x; };
EOF
    cz -e 'xdg-open https://www.rfc-editor.org/rfc/rfc{0@C}.txt' -f 0 \
       -i <(hold -ep curl -sS https://www.rfc-editor.org/rfc-index.txt | perl -lanE "$filter")
}

cz_rofi_theme() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz rofi theme
Select a rofi theme file.
EOF
    local dir="/usr/share/rofi/themes"
    req rofi "$dir" || return 5
    cz -z rofi -e 'printf "%s\n" {0}; CZ_ROFI_THEME={0} cz rofi theme' file "$dir" '*.rasi'
}

cz_ruby_gem() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ruby gem
Select an installed ruby gem package by name.
EOF
    req gem ruby || return 5
    cz -f 0 -e 'gem info {0}' -i <(gem query --local)
}

cz_screen_session() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz screen session
Select a screen session and attach to it.
EOF
    req screen || return 5
    cz -f 0 -e 'screen -rd {0}' -i <(screen -ls | grep pts)
}

cz_signal() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz signal
Select a system signal.
EOF
    local name line signals
    declare -a signals
    for x in {1..64}; do
        name=$(kill -l "$x")
        if [ -z "$name" ]; then continue; fi
        line=$(printf "%02d %s\\n" "$x" "$name")
        signals+=("$line")
    done
    cz -f 0 < <(printf "%s\\n" "${signals[@]}")
}

cz_smbc_comic() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz smbc comic
Select from SMBC comics and open for viewing.
EOF
    req curl perl || return 5
    local url="https://www.smbc-comics.com/comic/archive"
    if ! html=$(hold -e -t 604800 -- curl -sS "$url"); then
        return 2
    fi
    read -r -d '' filter <<EOF
my @m = \$_ =~ /<option value="(.*?)">(.*?)<\\/option>/g;
say join "\\t", "https://www.smbc-comics.com/" . \$_->[0], \$_->[1] for pairs @m;
EOF
    cz -d $'\t' -e 'xdg-open {0}' -f 0 \
       -i <(perl -MList::Util=pairs -nE "$filter" < "$html")
}

cz_ssh() {
    cz ssh host "$@"
}

cz_ssh_host() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ssh host [COMMAND]
Select a host from SSH configuration then connect to that host.
EOF
    req ssh sed || return 5
    cz -f 0 -e "ssh -t {0} -- $*" \
       -i <(sed -E -n '/\*/!s/^\s*Host\s+(.*)\s*/\1/ip' < "$HOME/.ssh/config")
}

cz_ssh_key() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ssh key
Select a key available to the running ssh-agent.
EOF
    req ssh-add || return 5
    cz -f 2 -i <(ssh-add -l)
}

cz_stream() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz stream
Select a standard stream.
EOF
    cz -f 0 <<EOF
0 /dev/stdin
1 /dev/stdout
2 /dev/stderr
EOF
}

cz_surfraw() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz surfraw [QUERY ...]
Select a surfraw elvi then run it with the given query.
EOF
    req surfraw || return 5
    cz -f 0 -e "surfraw {0} ${*@Q}" < <(surfraw -elvi | sed 1d)
}

cz_sysctl() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz sysctl
Select a kernel parameter.
EOF
    req sysctl || return 5
    cz -f 0 -i <(sysctl -a 2>/dev/null)
}

# generate systemd unit type related functions
for c in user system; do
    for t in automount device mount path scope service slice socket swap target timer; do
        eval "
cz_systemd_${c}_${t}() {
    { hep \"\$_CZ_HELP\" && return; } <<EOF
cz mpd $t
Select from ${c}-level systemd ${t} units.
EOF
    req mpc || return 5
    cz -e 'systemctl --${c} status {0}' systemd unit ${c} ${t}
}"
    done
done
unset t c

cz_systemd_file() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz systemd file [user|system] [TYPE]
Select a systemd system unit file then check its status.
EOF
    req systemctl || return 5
    local user=""
    case "$1" in
        system) user=""; shift ;;
        user) user="yes"; shift ;;
    esac
    local type="$1"
    cz -f 0 -e 'systemctl status {0}' \
       -i <(eval systemctl list-unit-files "${user:+--user}" "${type:+--type=$type}" --plain --no-legend)
}

cz_systemd_type() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz systemd type
Select a type of systemd unit.
EOF
    req sed systemctl || return 5
    cz -e 'systemctl list-units --type={0}' -f 0 \
       -i <(systemctl -t help | sed 1d)
}

cz_systemd_unit() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz systemd unit [user|system] [TYPE]
Select a systemd system unit then check its status.
EOF
    req systemctl || return 5
    local user=""
    case "$1" in
        system) user=""; shift ;;
        user) user="yes"; shift ;;
    esac
    local type="$1"
    cz -f 0 -e 'systemctl status {0}' \
       -i <(eval systemctl list-units "${user:+--user}" "${type:+--type=$type}" -l -a --plain --no-legend)
}

cz_tar() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tar ARCHIVE
Select a file from a tar archive.
EOF
    req tar || return 5
    local tb="$1"
    cz -e "tar -x -f '$tb' -- {0}" -f 0 -d '' \
       -i <(tar -t -f "$tb")
}

_cz_tar() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -f file -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
    fi
}

cz_task() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz task [FILTER]
Select a taskwarrior task matching the given filter.
EOF
    req sed task || return 5
    cz -f 0 -i <(task list "$@" | sed '1,3d;$d;/^$/d;')
}

cz_terraform_module() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform module [DIRECTORY]
Select a terraform module call defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.module_calls | to_entries[]
  | ["module\\(.key)",
     .value.source,
     .value.pos.filename,
     .value.pos.line] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{3@C} -- {2}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_output() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform output [DIRECTORY]
Select a terraform output variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.outputs | to_entries[]
 | [.key,
    .value.pos.filename,
    .value.pos.line] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{2@C} -- {1}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_provider() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform output [DIRECTORY]
Select a terraform output variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.provider_configs | to_entries[]
 | [.key,
    .value.name,
    .value.alias] | @tsv
EOF
    cz -d $'\t' -f 0 \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_resource() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform resource [DIRECTORY]
Select a terraform resource defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}"  filter=""
    read -r -d '' filter <<EOF
.managed_resources | to_entries[]
 | [.value.provider.name,
    .key,
    .value.pos.filename,
    .value.pos.line] | @tsv
EOF
    cz  -d $'\t' -f 1 -e "$EDITOR +{3@C} -- {2}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_variable() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform variable [DIRECTORY]
Select a terraform input variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.variables | to_entries[]
 | [.key,
    .value.pos.filename,
    .value.pos.line,
    .value.description] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{2@C} -- {1}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_timezone() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz timezone
Select a timezone and print the current time in that region.
EOF
    local p="/usr/share/zoneinfo/posix"
    if req date timedatectl 2>/dev/null; then
        cz -f 0 -e 'TZ={0} date' \
           -i <(timedatectl list-timezones)
    elif req date "$p" sort 2>/dev/null; then
        cz -f 0 -e 'TZ={0} fate' \
           -i <(for x in "$p"/*/*; do printf "%s\\n" "${x##"$p"/}"; done | sort)
    else
        req systemd "$p"
    fi
}

cz_tmux_command() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux command
Select a tmux command.
EOF
    req tmux || return 5
    cz -f 0 -i <(tmux list-commands)
}

cz_tmux_key() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux key
Select a tmux key binding.
EOF
    req tmux || return 5
    cz -i <(tmux list-keys)
}

cz_tmux_pane() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux pane
Select a pane in the current tmux session and give it focus.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux select-pane -t {0}' -i <(tmux list-panes)
}

cz_tmux_session() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux session
Select a tmux session then attach to it.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux attach-session -t {0}' -i <(tmux list-sessions)
}

cz_tmux_window() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux window
Select a tmux window then switch to it.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux select-window -t {0}' -i <(tmux list-windows)
}

cz_unicode() {
    cz unicode character "$@"
}

cz_unicode_block() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode block
Select a unicode block by name.
EOF
    req perl || return 5
    cz -d '' -f 0 -i <(perl -MUnicode::UCD=charblocks -E 'say for sort keys %{charblocks()}')
}

cz_unicode_character() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode character [SECTION]
Select a unicode character from given character block or script.
Interactively select a block if a section is not given.
EOF
    req perl || return 5
    declare -a parts
    if (($#)); then
        parts=("$@")
    else
        parts=("$(_CZ_MODE="" _CZ_FIELDS="" cz -p unicode block)")
    fi
    if [ -z "${parts[*]}" ]; then return 2; fi
    read -d '' -r util <<EOF
use strict;
use warnings;
use open ":std", ":encoding(UTF-8)";
use Unicode::UCD qw/charinfo charscript charscripts charblock charblocks/;
my (\$blocks,\$scripts) = (charblocks(),charscripts());
for (@ARGV) {
    my \$section = \$blocks->{\$_} || \$scripts->{\$_};
    exit 1 unless(\$section);
    for my \$range (\$section->@*) {
        for (grep { defined } map { charinfo(\$_) } (\$range->[0] .. \$range->[1])) {
            say join ":", chr hex \$_->{code}, \$_->{code}, \$_->{name};
        }
    }
}
EOF
    cz -d ':' -e "printf \$'\\U{1@C}'" -f 0  \
       -i <(perl -E "$util" "${parts[@]}")
}

_cz_unicode_character() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    local blocks=() maybe=() reply=()
    mapfile -t blocks < <(insulate ^_CZ_ cz -o unicode block)
    mapfile -t maybe < <(compgen -W "${blocks[*]@Q}"--- "$curr")
    mapfile -t reply < <(printf "%q\\n" "${maybe[@]}")
    COMPREPLY=("${reply[@]}")
}

cz_unicode_flag() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz iso flag
Select an ISO standard Unicode country flag.
EOF
    req isoquery sed || return 5
    cz -f 0 \
       -i <(hold -g -p \
                || hold -f -x -p \
                        <(while read -r code _ _ name; do
                              local flag=""; flag=$(unicode_flag "$code")
                              printf "%s %s %s\\n" "$flag" "$code" "$name";
                          done < <(insulate ^_CZ_ cz -o iso country)))
}

cz_unicode_script() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode script
Select a unicode script by name.
EOF
    req perl || return 5
    cz -d '' -f 0 -i <(perl -MUnicode::UCD=charscripts -E 'say for sort keys %{charscripts()}')
}

cz_unicode_symbol() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode symbol
Select a unicode character by name from symboloc blocks.
EOF
    req perl || return 5
    local blocks=()
    mapfile -t blocks <<EOF
Alchemical Symbols
Ancient Symbols
Arrows
Block Elements
Box Drawing
Chess Symbols
Currency Symbols
Dingbats
Domino Tiles
Emoticons
Geometric Shapes
Geometric Shapes Extended
Ideographic Symbols and Punctuation
Letterlike Symbols
Mathematical Alphanumeric Symbols
Miscellaneous Mathematical Symbols-A
Miscellaneous Mathematical Symbols-B
Miscellaneous Symbols
Miscellaneous Symbols and Arrows
Miscellaneous Symbols and Pictographs
Miscellaneous Technical
Musical Symbols
Supplemental Symbols and Pictographs
Symbols and Pictographs Extended-A
Symbols for Legacy Computing
Transport and Map Symbols
Yijing Hexagram Symbols
EOF

    cz -d ':' -e "printf \$'\\U{1@C}'" -f 0 -i \
       <(hold -gp -t 604800 || \
             hold -fpx <(insulate ^_CZ_ cz -o unicode character "${blocks[@]}"))
}

# TODO cz_unicode_plane

cz_uri() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz uri [FILE] [< STREAM]
Select a URI extracted from the input text.
URIs are extracted with xurls or urifind.
EOF
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    if type urifind &>/dev/null; then
        cz -e 'xdg-open {0}' < <(urifind -su < "$f")
    elif type xurls &>/dev/null; then
        cz -e 'xdg-open {0}' < <(xurls -r < "$f")
    else
        req urifind xurls || return 5
    fi
}

cz_usb() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz usb
Select a USB device.
EOF
    req lsusb || return 5
    cz -e 'lsusb -v -d {5}' -f 5 -i <(lsusb)
}

cz_v4l_device() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz v4l device
Select a video4linux device.
EOF
    req v4l2-ctl || return 5
    cz -d$'\t' -f 1 -i <(v4l2-ctl --list-devices | awk '/:$/{n=$0};/^\t\//{ print n"\t"$0 };')
}

cz_wal_theme() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz wal theme
EOF
    req sed sort wal || return 5
    cz -f 0 -e 'wal -f {0}' -i <(wal --theme | sed '/^ - /!d;/^ - /s/ - //;' | sort -u)
}

whence() {
    read -d '' -r use <<EOF
whence [COMMAND...] [< COMMANDS]
Print the files that define the given commands.
EOF
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            h) printf "%s\\n" "$use" >&2; return 0 ;;
            ?) printf "%s\\n" "$use" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    local commands=("$@")
    if ! [ -t 0 ]; then
        mapfile -t lines
        commands+=("${lines[@]}")
    fi
    local idx=0
    for ((idx=0; idx<="${#commands[@]}"; idx++)); do
        local that="${commands[$idx]}"
        local kind=""
        if ! kind=$(type -t -- "$that"); then
            continue
        fi
        local where=""
        case "$kind" in
            'function')
                shopt -s extdebug
                read -r _ _ where < <(declare -F -- "$that")
                shopt -u extdebug
                ;;
            'file')
                where=$(type -P "$that")
                ;;
            *)
                continue
                ;;
        esac
        printf "%s %s\\n" "$that" "$where"
    done
}

cz_whence() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz whence [COMMANDS...]
Select from commands by the path that defines them.
EOF
    if (("$#")) && [[ -n "$*" ]];  then
        cz -f 1 -i <(whence "$@")
    else
        cz -f 1 -i < <(hold -gp -t 86400 || hold -fpx <(compgen -c | whence))
    fi
}

cz_word() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz word [FILE] [< STREAM]
Select a word from the given file or stream.
EOF
    req grep sort || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz < <(grep -Eo '([[:alnum:]_-])+' "$f" | sort -u)
}

_cz_word() {
    local name="$1" curr="$2" prev="$3" words=("${@:4}")
    if [[ "$curr" == "${words[0]}" ]]; then
        mapfile -t reply < <(compgen -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        compopt -o filenames
    fi
}

cz_x11_rgb() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz x11 rgb
Select a color by name from the X11 flat file database.
EOF
    local rgb="/etc/X11/rgb.txt"
    req "$rgb" perl sort || return 5
    read -r -d '' tweak <<EOF
next if /^!/;
printf "#%02x%02x%02x\\t%s\\n", @F[0..2], join(" ", @F[3..\$#F])
EOF
    cz -d $'\t' -f 1 \
       -i <(hold -pe -- perl -lanE "$tweak" "$rgb" | sort)
}

cz_x11_window() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz x11 window
Select an X11 window.
EOF
    req sort xwininfo || return 5
    local menu=()
    while IFS= read -r l; do
        if [[ "$l" =~ ^[[:space:]]+?(0x[[:alnum:]]+)[[:space:]](.*) ]]; then
            menu+=("${BASH_REMATCH[1]} ${BASH_REMATCH[2]}")
        fi
    done < <(xwininfo -children -root)
    cz -f 0 -i <(printf "%s\\n" "${menu[@]}" | sort)
}

xclip_brief() {
    local mod="" buf="" lns=""
    for mod in clipboard primary secondary; do
        buf=$(xclip -o -selection "$mod" 2>/dev/null)
        mapfile -t lns <<< "$buf"
        printf "%09s %s %s:%s\\n" "$mod" "${#buf}" "${#lns[@]}" "${lns[0]}"
    done
}

cz_xclip_in() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xclip in
Select a xclip buffer and write the input stream to it.
EOF
    req xclip || return 5
    cz -g -e 'xclip -selection {0} -i' -i <(xclip_brief)
}

cz_xclip_out() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xclip out
Select a xclip buffer and print its contents.
EOF
    req xclip || return 5
    cz -e 'xclip -selection {0} -o' -i <(xclip_brief)
}

cz_xinput_device() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xinput device
Select an X11 device and print its name.
EOF
    req xinput sort || return 5
    mapfile -t lines < <(while read -r id; do
                             printf "%s:%s\\n" "$id" "$(xinput list --name-only "$id")";
                         done < <(xinput list --id-only) | sort -nk1)
    cz -d ':' -f 1 -i <(printf "%s\\n" "${lines[@]}")
}

cz_xinput_prop() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xinput prop [DEVICE]
Select a property associated with the given X11 device.
EOF
    req xinput sed || return 5
    local dev="${1:-$(insulate ^_CZ_ cz -u -f 0 xinput device)}"
    cz -d ':' -f 1 \
       -i <(xinput list-props "$dev" \
                | sed -n '/^[[:space:]]/!d; s/[[:space:]]*//; s/ ([0-9]*)//; p;')
}

cz_xkcd() {
    cz_xkcd_comic "$@"
}

cz_xkcd_comic() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xkcd comic
Select an XKCD comic by identifier, date, and title.
EOF
    req curl perl || return 5
    local html=""
    if ! html=$(hold -e -t 1209600 -- curl -sS https://xkcd.com/archive/); then
        return 2
    fi
    read -r -d '' filter <<EOF
/^<a href="\\/(\\d+)\\/" title="(.+)">(.*)<\\/a>/ && say join "\\t", \$1, \$2, \$3
EOF
    cz -d $'\t' -f 0 -e 'xdg-open https://xkcd.com/{0@C}' \
       -i <(perl -nE "$filter" < "$html")
}

cz_xkcd_rgb() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xkcd rgb
Select a hex color by name from XKCD's public flat file database.
See https://xkcd.com/color/rgb.txt.
EOF
    req curl perl sort || return 5
    local url="${RGB_URL:-https://xkcd.com/color/rgb.txt}"
    read -r -d '' tweak <<EOF
next if /^#/;
printf "%s\\t%s\\n", \$F[-1], join(" ", @F[0..\$#F-1])
EOF
    cz -d $'\t' -f 1 -i <(hold -ep -- curl -sS "$url" | perl -lanE "$tweak" | sort)
}

cz_xml_element() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xml element [FILE] [< STREAM]
Select a XML element by xpath string and print it.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -d '' -f 0 -e "xmlstarlet sel -B -t -c {0} ${f@Q}" < <(xmlstarlet el -v "$f")
}

cz_xml_value() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xml value [FILE] [< STREAM]
Select a XML element by xpath string and extract its contents.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -d '' -f 0 -e "xmlstarlet sel -B -t -v {0} ${f@Q}" < <(xmlstarlet el -v "$f")
}

cz_xrandr_monitor() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xrandr monitor
Select a X11 monitor.
EOF
    req xrandr sed || return 5
    cz -d: -f 1 -i <(xrandr --listmonitors | sed 1d)
}

cz_xrandr_provider() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xrandr provider
Select a X11 provider.
EOF
    req xrandr sed || return 5
    cz -f 0 -i <(xrandr --listproviders | sed 1d)
}

cz_xrdb_resource() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xrdb resource
Select a X11 resource.
EOF
    req xrdb || return 5
    cz -d : -f 0 -i <(xrdb -query)
}

cz_zellij_session() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz zellij session
Select a zellij session and attach to it.
EOF
    req zellij || return 5
    cz -f 0 -e 'zellij attach {0}' -i <(zellij list-sessions -n)
}

###

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then cz "$@"; fi
