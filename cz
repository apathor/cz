#!/usr/bin/env bash
#
# cz - Line selection abstraction (plus utilities!)
# (C) 2020 by Mike Lalumiere
#
# TODO
#  - Completion hook function?
#  - AWS/s3 plugins
#  - I8n?
#  - Better built-in line selector

if (("${BASH_VERSINFO[0]}" < 4)); then
    printf '%s1q\n' "$0 requires bash 4!" >&2
    return 255
fi

chuz() {
    # usage
    read -r -d '' use <<EOF
chuz < INPUT > LINE
Interactively select one line from input.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *) printf "%s\\n" "$use" >&2
               return 1
               ;;
        esac
    done
    shift $((OPTIND - 1))
    # prepend a number to each line of input
    local ind lines
    mapfile -t lines
    for ((ind=0; ind < "${#lines[@]}"; ind++)); do
        printf "% 5d %s\\n" "$ind" "${lines[$ind]}" >&2
    done < <(printf "%s\\n" "${lines[@]}")
    # prompt interactively to select a line number
    shopt -s nocasematch
    while read -p "#? " -r sel < /dev/tty; do
        if ! [[ "$sel" =~ ^[0-9]+$ ]]; then
            # given a non-number perform a string search
            for ((ind=0; ind < "${#lines[@]}"; ind++)); do
                if [[ "${lines[$ind]}" =~ $sel ]]; then
                    printf "% 5d %s\\n" "$ind" "${lines[$ind]}" >&2
                fi
            done < <(printf "%s\\n" "${lines[@]}")
        else
            # line number must be within boundaries
            if [ "$sel" -lt "${#lines[@]}" ]; then
                break
            fi
        fi
    done
    shopt -u nocasematch
    # failed unless a selection was made
    if [ -z "$sel" ]; then return 2; fi
    # print the selected line
    printf "%s\\n" "${lines[$sel]}"
}

hep() {
    read -r -d '' use <<EOF
hep TOGGLE < INPUT > OUTPUT
Print input text if the first argument is non-empty, otherwise fail.
Use this function to optionally print help text in other functions.
For example: { hep "\$HELP_TOGGLE" && return; } <<<EOF ...
EOF
    # no real options
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # print input if given a non-empty argument
    if [ -n "$1" ]; then
        printf "%s\\n" "$(< /dev/stdin)" >&2
    else
        return 1
    fi
}

hold() {
    read -r -d '' use <<EOF
hold [OPTIONS] [MODE] [ARGUMENTS]
Speed up pipelines with caching!

MODE
 -e         : Arguments are evaluated as a command and the output is cached.
 -f         : Arguments are considered files and their content is cached.
 -g         : Ignore arguments and only retreive cached content.

OPTIONS
 -n NAME    : Set the cache name. By default the name of the calling function is used.
 -p         : Print the contents of the cache file instead of its path.
 -q         : Quiet mode. Do not print cache file name or contents.
 -t SECONDS : Clear cache files older than given number of seconds.
 -x         : Do not load a cached file.

ENVIRONMENT
 HOLD_DIR   : Cache directory. The default is $HOME/.cache/hold

EXAMPLES
 Cache a long running command.
  $ hold -e -n foo -t 60 long running command
 Cache a long running pipeline.
  $ hold -g -n bar -t 30 || hold -f -n bar < <(long running command)
 Get a cache file by name.
  $ f="\$(hold -g -n foo)"; cat "\$f"
 Retreive cache file contents.
  $ hold -g -p -n foo
 Overwrite a cache.
  $ hold -fx -n bar - <<< "test"
 Accept a file argument or stdin in one command.
  $ hold -fx -n qux "\${1:--}"
EOF
    # help out
    if (( $# == 0 )); then
        printf "Command arguments required.\\n%s\\n" "$use" >&2
        return 1
    fi
    # get current time
    local now="${EPOCHSECONDS:-$(printf "%(%s)T\\n" -1)}"
    # accept options
    local name="${FUNCNAME[1]:-hold}" # string cache name
    local expire=0                    # integer seconds to expire cache
    local new="${HOLD_CLEAR:-0}"      # boolean to clear cache
    local mode='run'                  # program mode: run/file/load
    local out='name'                  # output mode: name/content/quiet
    local opt OPTIND OPTARG
    while getopts ":hefgn:pqt:x" opt; do
        case "$opt" in
            e) # command input mode
                mode='run'
                ;;
            f) # file input mode
                mode='file'
                ;;
            g) # cache read
                mode='load'
                ;;
            n) # cache name
                name="$OPTARG"
                if ! [[ "$name" =~ ^[[:alnum:]_-]+$ ]]; then
                    printf "%s - Invalid cache name '%s'.\\n" "${FUNCNAME[0]}" "$name" >&2
                    return 1
                fi
                ;;
            t) # cache expiration time
                expire="$OPTARG"
                if ! [[ "$expire" =~ ^[[:digit:]]+$ ]]; then
                    printf "%s - Invalid cache time '%s'.\\n" "${FUNCNAME[0]}" "$expire" >&2
                    return 1
                fi
                ;;
            p) # print the contents of the file
                out='content'
                ;;
            q) # print nothing
                out='quiet'
                ;;
            x) # force fresh cache
                new=1
                ;;
            h) # help
                printf "%s\\n" "$use" >&2
                return 0
                ;;
            \?)
                printf "Invalid option '%s'.\\n%s\\n" "$OPTARG" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # setup the cache directory
    local tmpd="${HOLD_DIR:-$HOME/.cache/hold}"
    if ! command mkdir -p "$tmpd"; then
        printf "Could not make cache directory '%s'.\\n" "$tmpd" >&2
        return 2
    fi
    # scan cached files in glob order
    local hot=()
    shopt -s nullglob
    for file in "$tmpd/$name."*; do
        # skip non-files
        if ! [ -f "$file" ]; then
            continue
        fi
        # get timestamp component of file name
        IFS=. read -r _ ts <<< "${file##*/}"
        if ! [[ "$ts" =~ ^[0-9]+$ ]]; then
            continue
        fi
        # remove files older than the expiration time
        if (( new )) || (( expire )) && (( now - expire > ts )); then
            command rm "$file"
            continue
        fi
        # gather matching files
        hot+=("$file")
    done
    shopt -u nullglob
    # check cache
    local rc=0
    local cache=""
    if ! (( new )) && (( ${#hot} )); then
        # use most recent cached file
        cache="${hot[-1]}"
    else
        # create a new cache file
        cache=$(printf "$tmpd/%s.%d\\n" "$name" "$now")
        case "$mode" in
            run) # command mode - eval arguments as a command
                if (( $# == 0 )); then
                    printf "Command arguments required.\\n%s\\n" "$use" >&2
                    return 1
                fi
                eval "${*@Q}" > "$cache"
                ;;
            file) # file mode - cat arguments
                # requrie arguments
                if (( $# == 0 )); then
                    printf "File arguments required.\\n%s\\n" "$use" >&2
                    return 1
                fi
                # ensure each file exists
                local each=""
                for each in "$@"; do
                    if ! [ -r "$each" ] && [ "$each" != "-" ]; then
                        printf "%s - Could not read input: '%s'\\n" "${FUNCNAME[0]}" "$each" >&2
                        return 1
                    fi
                done
                # dump file contents to cache
                cat -- "$*" > "$cache"
                ;;
            load) # cache miss!
                return 4
                ;;
        esac
    fi
    # output
    case "$out" in
        content) # print content of cache file
            cat "$cache"
            ;;
        name) # print name of cache file
            printf "%s\\n" "$cache"
            ;;
    esac
    return "$rc"
}

indirect() {
    read -r -d '' use <<EOF
indirect VARNAME [DEFAULT]
Print the value of the variable with the given name.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    # require variable name argument
    local name="$1"
    if [ -z "$name" ] || (( $# > 2 )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    local alt="$2"
    # dump the variable with given name or the fallback default
    local out="${!name}"
    if [ -z "$out" ]; then
        out="$alt"
    fi
    printf "%s\\n" "$out"
}

insulate() {
    read -r -d '' use <<EOF
insulate PATTERN COMMAND [ARG...]
Run the given command without environment variables matching the given pattern.
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    # at least one argument is required
    if (($# < 2 )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    # accept pattern argument
    local p="$1"
    shift
    (
        # filter environment variables
        while read -r v; do
            if [[ "$v" =~ $p ]]; then
                unset "$v"
            fi
        done < <(compgen -v)
        # run the given command in this modified environment
        eval "${*@Q}"
    )
}

nth() {
    read -r -d '' use <<EOF
nth [OPTIONS] TEMPLATE [ARG ...]
Format and print a string from a template using  arguments.
Substrings in the following formats are replaced:
 {X}     : argument with index X
 {X:}    : arguments X through end of arguments
 {X:Y}   : arguments X through X + Y
 {X,Y,Z} : arguments X, Y, and Z

Append @C, @E, @P, or @Q to transform selected arguments:
 @C - Insert argument literally. This is risky for command strings!
 @E - Replace backslash escape sequences in arguments with bash $'...' quotes.
 @P - Expand arguments for use in prompt strings.
 @Q - Quote arguments for use in command input. This is the default.

OPTIONS
 -c | -e | -p | -q
  Use @C, @E, @P, or @Q transform by default for each variable.

EXAMPLES
 $ nth -p "{2,25}" {A..Z}        = C Z
 $ nth -q "{0:}" foo bar baz     = 'foo' 'bar' 'baz'
 $ nth "{1@Q} {0@P}" "a b" "c d" = 'c d' a b
 $ nth "({2,1})" w x y z         = ('y' 'x')

EOF
    # accept options
    local pto="Q"
    local opt OPTIND OPTARG
    while getopts ":cehpq" opt; do
        case "$opt" in
            c) pto="C" ;; # clear
            e) pto="E" ;; # escaped
            p) pto="P" ;; # prompt
            q) pto="Q" ;; # quoted
            *) # invalid?
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # require template argument
    if ! (( $# )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    local tmpl="$1"
    shift
    # any remaining arguments are tokens to be inserted into the template
    local toks=("$@")
    # parser appends to this output string
    local out=""
    # parse template string
    local index=0 mode="text"
    local char="" next=""
    local field="" fields=() fmt=""
    while (( index < "${#tmpl}" )); do
        # consider each character and the character following
        char="${tmpl:$index:1}"
        next="${tmpl:$(( index + 1 )):1}"
        # switch depending on parser mode
        if [[ "$mode" == "text" ]]; then
            # in text mode read literal text
            case "$char" in
                '{')
                    # curly brace starts a variable
                    fields=()
                    mode="var"
                    ;;
                *)
                    # accumulate characters
                    out+="$char"
                    ;;
            esac
        elif [[ "$mode" == "var" ]]; then
            # start parsing a variable
            case "$char" in
                '{') # escaped literal curly brace
                    out+="$char"
                    mode="text"
                    ;;
                [[:digit:]:-]) # field specifiers
                    field+="$char"
                    ;;
                [,\}]) # field separator
                    # match and validate the field
                    if ! [[ "$field" =~ ^(-?[[:digit:]]+)(:([[:digit:]]+)?)?$ ]]; then
                        printf "Invalid field string '%s'\\n%s\\n" "$field" "$use" >&2
                        return 3
                    fi
                    # get regex match groups - field, range
                    local sel="${BASH_REMATCH[1]}"
                    local len="${BASH_REMATCH[3]:-${BASH_REMATCH[2]}}"
                    if [ -z "$len" ]; then
                        # N - one specific field
                        fields+=("${toks[$sel]}")
                    elif [ "$len" == ":" ]; then
                        # N: - a slice of fields
                        fields+=("${toks[@]:$((sel))}")
                    else
                        # N:X - a range of fields
                        if [[ "$len" -lt 1 ]]; then
                            printf "Invalid range '%s'\\n" "$len" >&2
                            return 3
                        fi
                        fields+=("${toks[@]:$((sel)):$((len))}")
                    fi
                    # reset field
                    field=""
                    ;;&
                '}') # end variable
                    mode="text"
                    # reformat field with global or per-variable format
                    local more=""
                    fmt="${fmt:-$pto}"
                    if [ "$fmt" == "C" ]; then
                        more=$(printf "%s " "${fields[@]}")
                    else
                        more=$(eval "printf \"%s \" \"\${fields[@]@$fmt}\"")
                    fi
                    fmt=""
                    # add selected fields to output
                    out+="${more%"${more##*[![:space:]]}"}"
                    ;;
                '@') # field transformation string
                    case "$next" in
                        [CEPQ]) # accept transform formats
                            fmt="$next"
                            (( index++ ))
                            ;;
                        *) # anything else is an error
                            printf "Invalid format string '%s'\\n%s\\n" "$next" "$use" >&2
                            return 3
                            ;;
                    esac
                    ;;
                ',') # field selection continues
                    ;;
                *) # invalid
                    printf "Could not parse character '%s' at index %d.\\n\\n%s\\n" "$char" "$index" "$use" >&2
                    return 3
                    ;;
            esac
        fi
        # next character
        (( index++ ))
    done
    # check if parsing ended cleanly
    if [[ "$mode" == "var" ]]; then
        printf "Unclosed variable delimeter?\\n%s\\n" "$use"  >&2
        return 3
    fi
    # strip leading and trailing whitespace
    out="${out##*()}"
    out="${out%"${out##*[![:space:]]}"}"
    # write out the resulting string
    printf "%s\\n" "${out}"
}

req() {
    read -r -d '' use <<EOF
req COMMAND/FILE [...]
Require given files and commands.
Succeed iff each given argument is a known command or readable file.
Use this function to define program requirements in other functions.
For example: req awk /etc/passwd || return 5
EOF
    # no options just help
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            *)
                printf "%s\\n" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # check that each argument exists either as a file or as a command
    local mis=0
    local arg=""
    for arg in "$@"; do
        if [ -r "$arg" ]; then continue; fi
        if type "$arg" &>/dev/null; then continue; fi
        ((mis++))
        printf "%s -- %s is required!\\n" "${FUNCNAME[1]}" "$arg" >&2
    done
    # fail if any requirement is missing
    ! ((mis))
}

rleval() {
    read -r -d '' use <<EOF
rleval [OPTIONS] COMMAND [ARGS ...]
In bash readline context, evaluate the given command then...
 -i : insert its output at cursor point. This is the default mode.
 -w : replace the word at cursor point with its output.
 -r : change nothing and attach the command to the terminal.

This function is intended to be used with the bash builtin 'bind -x'.
The command is templated with the function 'nth' using tokens from the readline
 buffer. Run 'nth -h' for more information.
The string '{0}' is replaced with the word at cursor point.
The string '{N}' is replaced with the token at numeric index N starting at 1.

EXAMPLES
 Insert the first token from the current readline buffer:
 $ bind -x '"\\C-x0":rleval -i echo {1}'

 Insert fortunes on demand:
 $ bind -x '"\\C-xf":rleval -i fortune"'

 Replace the current word with a generated password:
 $ bind -x '"\\C-xp":rleval -w pwgen 20 1'

 Replace the current word with itself reversed:
 $ bind -x '"\\C-xt":rleval -w "rev <<< {0}"'

 Encode and decode base64 strings at cursor point:
 $ bind -x '"\\C-xb":rleval -w "base64 <<< {0}"'
 $ bind -x '"\\C-xB":rleval -w "base64 -d <<< {0}"'

 Open the man page for the topic at cursor point:
 $ bind -x '"\\C-xh":rleval -r man {0}'
EOF
    # accept options
    local mode='insert'
    local opt OPTIND OPTARG
    while getopts ":irwh" opt; do
        case "$opt" in
            i) mode='insert' ;;
            r) mode='run'  ;;
            w) mode='word' ;;
            h) printf "%s\\n" "$use"; return 0 ;;
            *) printf "%s\\n" "$use" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND - 1))
    # require command argument
    local args=("$@")
    if ! (($#)); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    # require readline context
    local line="$READLINE_LINE" pt="$READLINE_POINT"
    if [ -z "$pt" ]; then
        printf "%s only works with 'bind -x'!\\n%s\\n" "${FUNCNAME[0]}" "$use" >&2
        return 2
    fi
    # record current readline point
    local before="${line:0:$pt}"
    local after="${line:$pt}"
    # tokenize current readline line
    local toks=()
    read -r -a toks <<< "$line"
    # determine word at point
    local beg=0 end=0 ins=0 word=""
    if [[ "${line:$pt:1}" == ' ' ]]; then
        # insert a word if point is on a space
        beg="$pt"
        end="$pt"
        ins=1
    else
        # replace word at point if on a non-space character
        local pos=0
        # find the beginning of the word
        beg=0
        for ((pos="$pt"; pos>=0; pos--)); do
            if [[ "${line:$pos:1}" == ' ' ]]; then
                beg=$((pos + 1))
                break
            fi
        done
        # find the end of the word
        end="${#line}"
        for ((pos="$pt"; pos<="${#line}"; pos++)); do
            if [[ "${line:$pos:1}" == ' ' ]]; then
                end="$x"
                break
            fi
        done
        # grab the word
        word="${line:$beg:$(( end - beg ))}"
    fi
    # render the command template
    local cmd=""
    tmpl="${args[*]}"
    if ! cmd=$(nth "${tmpl}" "${word/#\~/$HOME}" "${toks[@]/#\~/$HOME}"); then
        return 2
    fi
    # switch based on program mode
    case "$mode" in
        insert)
            # run the command, capturing output
            local str=""
            if ! str=$(eval -- "$cmd"); then
                return 3
            fi
            # no output? no change
            if [ -z "$str" ]; then
                return 3
            fi
            # update the readline buffer
            READLINE_LINE="${before}${str}${after}"
            ((READLINE_POINT += ${#str}))
            ;;
        run)
            # run command attached to the terminal
            eval -- "$cmd" < /dev/tty
            ;;
        word)
            # run the command, capturing output
            local str=""
            if ! str=$(eval -- "$cmd"); then
                return 3
            fi
            # no change if the output is empty
            if [ -z "$str" ]; then
                return 3
            fi
            # wrap inserted words in spaces
            if ((ins)); then
                str=" ${str} "
            fi
            # update the readline buffer
            READLINE_LINE="${line:0:$beg}${str}${line:$end}"
            READLINE_POINT=$((beg + ${#str}))
            ;;
    esac
}

###

cz() {
    # version
    local ver="0.8.5"
    # usage
    local hows="" use=""
    read -r -d '' use <<EOF
cz [OPTIONS] [PLUGIN...] [ARGS ...] [< LINES]
Select a line using your preferred interactive line selection tool.

OPTIONS
 These options print some information then exit:
  -h : help     : Show this help text or help text for plugin.
  -H : example  : List example commands.
  -k : tools    : List supported line selection tools.
  -l : plugins  : List detected plugins.
  -v : version  : Show version string.

 These options set the program mode. Select a line then... :
  -p : print    : Print the line. This is the default mode.
  -q : quoted   : Print fields from the line in shell quotes.
  -r : run      : Run a templated command.
  -s : simulate : Print a templated command.
  -t : template : Print a templated string.
  -u : unquoted : Print fields from the line literally.
  -o :          : Only print input lines instead of selecting a line.

 These options set a template:
  -e TEMPLATE   : Set the command template. This option implies mode '-r'.
  -f FIELDS     : Set the field template. This option implies mode '-q'.

 These options control input and line splitting:
  -c            : Do not use cached input lines.
  -d DELIMITER  : Set the field splitting characters.
  -g            : Buffer stdin and pass it to command set with '-e'.
  -0            : Read null terminated lines from input.
  -i IN-FILE    : Set file from which to read selections instead of stdin.

 These options control which line selection utility is used:
  -x            : Use a graphical line selection tool.
  -y            : Use a terminal line selection tool.
  -z TOOL       : Use the given line selection tool.

 These options control debugging features:
  -m            : Print some debygging information.

TOOLS
 The following interactive line selection tools are supported:
  choose, dmenu, fzf, fzy, iselect, pick, pipedial, rofi, selecta, sentaku,
  slmenu, vis-menu, and zenity.

PLUGINS
 Plugins use cz for an application specific task. Each plugin defines input
  lines, delimiter, and template options.
 Run 'cz -l' to list plugins and 'cz -h PLUGIN' or 'cz help' for help text.
 All commands starting with 'cz_' are considered plugins.

TEMPLATES
 Sub-strings of TEMPLATE in the following formats are replaced with
  one or more fields from a selected line split by DELIMITER.
     {X}     - field X
     {X:}    - fields X through end of fields
     {X:Y}   - fields X through X + Y
     {X,Y,Z} - fields X, Y, and Z

 Append @C, @E, @P, or @Q to transform selected fields:
  {X@C} - Insert argument directly. This is risky for command strings!
  {X@E} - Replace backslash escape sequences in arguments with bash $'...' quotes.
  {X@P} - Expand arguments for use in prompt strings.
  {X@Q} - Quote arguments for use in command input. This is the default.

ENVIRONMENT
 CZ_GUI         : The preferred interface (1=graphical 0=terminal).
 CZ_BINS        : A list of line selection tools in order of preference.
 CZ_DMENU_COLOR : Colon separated colors for dmenu (NF:NB:SF:SB).
 CZ_DMENU_FONT  : The font to use for dmenu.
 CZ_ROFI_THEME  : The theme to use for rofi.
EOF
    # example commands
    local hows=()
    mapfile -t hows <<EOF
Pick from lines on stdin.:$ printf "%s\\n" foo bar qux | cz
Accept null delimited input lines.:$ find . -name '*.yml' -print0 | cz -0
Extract useful fields from selected line.:$ cz -q -f 0,5 -d : < /etc/passwd
Safely handle input strings containing shell characters.:$ cz -e 'echo -- {0:}' -i <(printf "%s\\n" '\$USER' '; false' '\$(fortune)' '-e')
Add selection to common commands.:$ cz -r -e 'dig {0} AAAA +short' compgen hostname
Easily define plugins as bash functions.:$ cz_whois() { cz -e 'whois {0}' -f 0 compgen hostname; }; cz whois
Select a password and put it on an xclip clipboard.:$ cz pass | cz xclip in
Jump to any descendant directory.:$ cd \$(cz descendant)
Jump to any ancestor directory.:$ cd \$(cz ancestor)
Grab a URL from a paste buffer and open it in a browser.:$ cz xclip out | cz -e 'firefox {0}' uri
Compose plugins to get the contents of any element from any JSON file.:$ cz -e 'cz jq {0}' locate *.json
Compose plugins to get any file under an apparix bookmarked directory.:$ cz -e 'cz find file {1}' apparix
Find a file then open it for editing:$ find . -type f -print0 | cz -0 -r -e 'vim {0}'
Consult the I Ching.:cz -z shuf -uf0,2 unicode character 'Yijing Hexagram Symbols' | sed 's/HEXAGRAM FOR//'
EOF
    # supported tools
    read -r -d '' exes <<EOF
choose    https://github.com/chipsenkbeil/choose
dmenu     https://tools.suckless.org/dmenu
fzf       https://github.com/junegunn/fzf
fzy       https://github.com/jhawthorn/fzy
iselect   http://www.ossp.org/pkg/tool/iselect
pick      https://github.com/mptre/pick
pipedial  https://code.reversed.top/user/xaizek/pipedial
rofi      https://github.com/davatorium/rofi
selecta   https://github.com/garybernhardt/selecta
sentaku   https://github.com/rcmdnk/sentaku
shuf      https://www.gnu.org/software/coreutils
sk        https://github.com/lotabout/skim
slmenu    https://bitbucket.org/rafaelgg/slmenu
vis-menu  https://github.com/martanne/vis
EOF
    # append one random example to usage text
    local des="" exp=""
    IFS=: read -r des exp <<< "${hows[$(( RANDOM % ${#hows[@]} ))]}"
    use+=$(printf "\\n\\nEXAMPLE\\n %s\\n %s\\n" "$des" "$exp")
    # here are the supporterd line selection tools
    declare -A gbins tbins
    while read -r -d ' ' x; do gbins["$x"]=1; done <<< "choose dmenu rofi "
    while read -r -d ' ' x; do tbins["$x"]=1; done <<< "fzf fzy pick pipedial selecta sentaku shuf sk iselect slmenu vis-menu zenity "
    # determine type of interface for line selection tool
    local app="" gfx=""
    IFS=: read -r gfx app _ <<< "${CZ_GUI:-2}"
    if [ -z "$DISPLAY" ]; then gfx=0; fi
    # set options from the environment
    local tpl="${_CZ_TEMPLATE}"    # string | command template
    local fld="${_CZ_FIELDS}"      # string | field selection
    local mode="${_CZ_MODE}"       # string | indicator for program mode
    local help="${_CZ_HELP}"       # string | indicator for help requested
    local dlm="${_CZ_DELIM:-$IFS}" # string | delimeter to split selected line
    local dbg="${_CZ_DEBUG}"       # boolean | whether or not write debug info
    # set option defaults
    local inp="/dev/stdin"         # string  | file from which to select a line
    local buf=0                    # boolean | require buffered stdin for command
    local run=""                   # string  | program mode implied by another option
    local nul=0                    # boolean | whether to read null separated lines
    local clr=0                    # boolean | whether to refresh cached input lines
    # accept options
    local opt OPTIND OPTARG
    while getopts ":cd:e:f:ghHi:klmopqrstuvxyz:0" opt; do
        case "$opt" in
            c) # clear hold caches
                clr=1
                ;;
            d) # set delimeter string
                dlm="$OPTARG"
                ;;
            e) # set template to format command
                tpl="${tpl:-$OPTARG}"
                run=2
                ;;
            f) # set fields to be extracted
                fld="${fld:-$OPTARG}"
                run=5
                ;;
            g) # enable buffered stdin for command
                buf=1
                ;;
            h) # enable help mode
                help=1
                ;;
            H) # list usage examples
                local ind
                for ((ind=0; ind < "${#hows[@]}"; ind++)); do
                    IFS=: read -r des exp <<< "${hows[$ind]}"
                    printf "%s\\n%s\\n\\n" "$des" "$exp"
                done
                return 0
                ;;
            i) # set input file from which to read selections
                inp="$OPTARG"
                if ! [ -r "$inp" ]; then
                    printf "%s\\n" "Input file is unreadable!" >&2
                    return 2
                fi
                ;;
            k) # list supported tools
                printf "%s\\n" "$exes"
                return 0
                ;;
            l) # list available plugins
                while read -r f; do
                    if [[ "$f" == cz_* ]]; then
                        printf "%s\\n" "${f##cz_}"
                    fi
                done < <(compgen -c) | sort
                return 0
                ;;
            m) # mention some debugging information
                dbg=1
                ;;
            o) # just print lines without interactive selection
                mode=-1
                ;;
            p) # print selected line instead of running anything
                mode=0
                ;;
            q) # print rendered template from '-f' with variables shell-quoted
                mode=1
                ;;
            r) # execute rendered template from '-e'
                mode=2
                ;;
            s) # print string from '-e' as command
                mode=3
                ;;
            t) # print string from '-e' as raw template
                mode=4
                ;;
            u) # print rendered template from '-f' with variables inserted directly
                mode=5
                ;;
            0) # handle null separated input
                nul=1
                ;;
            v) # write version
                printf "cz %s\\n" "$ver"
                return 0
                ;;
            x) # try to use a graphical tool for line selection
                gfx=1
                ;;
            y) # try to use a terminal tool for line selection
                gfx=0
                ;;
            z) # use a specific line selection tool
                app="$OPTARG"
                if ! (( gbins["$app"] + tbins["$app"] )) ; then
                    printf "Unknown line selection tool '%s'\\n" "$app" >&2
                    return 2
                fi
                ;;
            \?) # invalid option?
                printf "Bad option: -%s\\n%s\\n" "$OPTARG" "$use" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # determine an available line selection tool
    local got=""
    if [ -z "$app" ]; then
        local tools=("${!gbins[@]}" "${!tbins[@]}")
        # filter preferred tools by the desired interface
        local want=()
        while read -d ' ' -r pref; do
            case "$gfx" in
                0) if ! (( tbins["$pref"] )); then continue; fi ;;
                1) if ! (( gbins["$pref"] )); then continue; fi ;;
            esac
            # printf "%s\n" "${pref}"
            want+=("$pref")
        done <<< "${CZ_BINS:-${tools[*]}} ${tools[*]}"
        # use the first available tool
        for app in "${want[@]}"; do
            if type "$app" &>/dev/null; then
                got="$app"
                break
            fi
        done
        app="$got"
        # exit if no appropriate tool was found
        if [ -z "$got" ]; then
            printf "No line selection tools found!\\nTry installing one of these:\\n" >&2
            printf "%s\\n" "${tools[@]}" | sort >&2
            return 5
        fi
    fi
    # the program mode might have been implied by other options
    mode="${mode:-$run}"
    # plugins - any command in the format 'cz_$WORD'
    if [ -n "$*" ]; then
        # determine if a known plugin is given
        local args=("$@") plug="" word=0
        for ((word=${#args[@]}; word>0; word--)); do
            plug="${args[*]:0:$word}"
            plug="cz_${plug// /_}"
            if type "$plug" >&/dev/null; then break; fi
            plug=""
        done
        # exit for invalid plugins
        if [ -z "$plug" ]; then
            printf "No plugin matching '%s'.\\n" "$*" >&2
            return 2
        fi
        shift "$word"
        # run the plugin with override environment variables
        _CZ_DELIM="$dlm" \
                 _CZ_DEBUG="$dbg" \
                 _CZ_FIELDS="$fld" \
                 CZ_GUI="${gfx}:${app}" \
                 _CZ_HELP="$help" \
                 _CZ_MODE="$mode" \
                 _CZ_TEMPLATE="$tpl" \
                 CZ_DMENU_COLOR=$(indirect "${plug^^}_DMENU_COLOR" "$CZ_DMENU_COLOR") \
                 CZ_DMENU_FONT=$(indirect "${plug^^}_DMENU_FONT" "$CZ_DMENU_FONT") \
                 CZ_ROFI_THEME=$(indirect "${plug^^}_ROFI_THEME" "$CZ_ROFI_THEME") \
                 HOLD_CLEAR="$clr" \
                 "$plug" "$@"
        return $?
    fi
    # print usage and exit if help was requested
    if [ -n "$help" ]; then
        printf "%s\\n" "$use" >&2
        return
    fi
    # read the selection file
    local items=() lines=()
    if ((nul)); then
        mapfile -d '' -t lines < "$inp"
        mapfile -t items < <(printf "%q\\n" "${lines[@]}")
    else
        mapfile -t lines < "$inp"
        mapfile -t items < <(printf "%s\\n" "${lines[@]}")
    fi
    # require at least one non-empty line
    if (("${#items[@]}" < 2)) && \
           { [ -z "${items[0]}" ] || [ "${items[0]}" == "''" ]; }; then
        return 12
    fi
    # buffer stdin if reading selection input from another file
    # this is needed to pass pipe input to plugin commands
    declare -a stdin
    if [[ "$inp" != "/dev/stdin" ]] && ! [ -t 0 ]; then
        mapfile -t stdin
        # optionally require actual input lines
        if ((buf)) && ! ((${#stdin})); then return 4; fi
    fi
    # maybe just write selections to stdout
    if (( mode < 0 )); then
        printf "%s\\n" "${items[@]}"
        return 0
    fi
    # choose a line using a known program
    local out
    out=$(case "$app" in
              choose)
                  choose -n 20
                  ;;
              dmenu)
                  local color="${CZ_DMENU_COLOR:-black:gray:white:black}"
                  local font="${CZ_DMENU_FONT}"
                  IFS=':' read -r nf nb sf sb <<< "$color"
                  dmenu -i -l 20 -fn "$font" -nf "$nf" -nb "$nb" -sf "$sf" -sb "$sb"
                  ;;
              fzf)
                  fzf
                  ;;
              fzy)
                  fzy
                  ;;
              iselect)
                  iselect -a
                  ;;
              pick)
                  pick
                  ;;
              rofi)
                  local theme="${CZ_ROFI_THEME:-Paper}"
                  rofi -theme "$theme" -i -dmenu -p ""
                  ;;
              pipedial)
                  pipedial
                  ;;
              selecta)
                  selecta --height=full
                  ;;
              sentaku)
                  sentaku -s $'\n' | head -n 1
                  ;;
              shuf)
                  shuf -n 1
                  ;;
              sk)
                  sk
                  ;;
              slmenu)
                  slmenu -i -l 30
                  ;;
              vis-menu)
                  vis-menu -i -l 30
                  ;;
              zenity)
                  zenity --width=640 --height=480 --list --column=cz
                  ;;
              chuz)
                  chuz
                  ;;
              *)
                  printf "Unknown tool %s.\\n" "$app" >&2
                  return 2
                  ;;
          esac < <(printf "%s\\n" "${items[@]}")
       ) || return 4
    # require that selector succeeded and got a line
    if [ -z "$out" ]; then
        return 4
    fi
    # expand shell quoted line
    if ((nul)); then
        out=$(eval printf "%s" "$out")
    fi
    # maybe print the selection
    if ((dbg)); then
        printf "> %s\\n" "$out" >&2
    fi
    # tokenize selected line for use in templates
    local cmd=""
    local toks=()
    IFS="$dlm" read -r -a toks <<< "$out"
    # set harmless defaults for template arguments
    tpl="${tpl:-echo {0:\}}"
    fld="${fld:-0:}"
    # assume field templates with no variables are simple variables
    if ! [[ "$fld" =~ \{.*\} ]]; then
        fld="{${fld}}"
    fi
    # do something with the selection depending on mode
    case "${mode:-0}" in
        0) # print selection
            printf "%s\\n" "$out"
            ;;
        1) # print some fields extracted from the line quoted for use in the shell
            if ! out="$(nth -q -- "$fld" "${toks[@]}" 2>/dev/null)"; then
                printf "Failed to render template: %s\\n" "$fld" >&2
                return 5
            fi
            if ((dbg)); then
                printf "# %s ==> %s\\n" "$fld" "$out" >&2
            fi
            printf "%s\\n" "$out"
            ;;
        5) # print some fields extracted from the line
            if ! out="$(nth -p -- "$fld" "${toks[@]}" 2>/dev/null)"; then
                printf "Failed to render template: %s\\n" "$fld" >&2
                return 5
            fi
            if ((dbg)); then
                printf "# %s ==> %s\\n" "$fld" "$out" >&2
            fi
            printf "%s\\n" "$out"
            ;;
        2) # template the command string then run it
            if ! cmd="$(nth -q -- "$tpl" "${toks[@]}" 2>/dev/null)"; then
                printf "Failed to parse template: %s\\n" "$tpl" >&2
                return 5
            fi
            if ((dbg)); then
                printf "# %s\\n" "$cmd" >&2
            fi
            unset -v _CZ_DELIM _CZ_FIELDS _CZ_HELP _CZ_MODE _CZ_TEMPLATE HOLD_CLEAR
            # eval the command maybe passing through stdin or the terminal
            if ((${#stdin})); then
                CZ_GUI="${gfx}:${app}" eval "$cmd" < <(printf "%s\\n" "${stdin[@]}")
            elif [ -n "$PS1" ]; then
                CZ_GUI="${gfx}:${app}" eval "$cmd" < /dev/tty
            else
                CZ_GUI="${gfx}:${app}" eval "$cmd"
            fi
            ;;
        3) # render the command string with shell quotes
            if ! cmd="$(nth -q "$tpl" "${toks[@]}")"; then
                printf "Failed to render template.\\n%s\\n" "$tpl" >&2
                return 4
            fi
            if ((dbg)); then
                printf "# %s ==> %s\\n" "$fld" "$out" >&2
            fi
            printf "%s\\n" "$cmd"
            ;;
        4) # render the command template unquoted
            if ! cmd="$(nth -p "$tpl" "${toks[@]}")"; then
                printf "Failed to render template.\\n%s\\n" "$tpl" >&2
                return 4
            fi
            if ((dbg)); then
                printf "# %s ==> %s\\n" "$fld" "$out" >&2
            fi
            printf "%s\\n" "$cmd"
            ;;
    esac
}

# cz command completion
function _cz() {
    local reply=()
    # get lists of supported tools and plugins
    local tools=() plugs=()
    mapfile -t tools < <(cz -k)
    mapfile -t plugs < <(cz -l)
    # cz has some options
    local opt="" opts
    declare -A opts
    for opt in -{d,e,f,h,i,l,k,m,o,p,q,r,s,t,u,v,x,y,z,0}; do opts["$opt"]=0; done
    # scan all previous words
    local base="" last="" word="" i=0
    for ((i=1; i < "$COMP_CWORD"; i++)); do
        # step through words
        word="${COMP_WORDS[$i]}"
        last="${COMP_WORDS[$i-1]}"
        # have options ended?
        if [[ "$word" =~ ^-[[:alnum:]]$ ]]; then
            # record options already seen
            unset "opts[$word]"
        elif [[ "$word" =~ ^[[:alnum:]]+ ]]; then
            # maybe this is an argument to an option
            if [[ "$last" =~ ^-[defiz]$ ]]; then continue; fi
            opts=()
            # concat plugin prefix
            base="${base}_${word}"
            base="${base##_}"
        fi
    done
    # current and previous words are given
    local curr="${2}" prev="${3}"
    # maybe the previous word is a redirection
    local rd='^[&12]?[><]'
    if [[ "$prev" =~ $rd ]]; then
        mapfile -t reply < <(compgen -f -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # maybe the previous word is an option that expects an argument
    if [[ "$prev" =~ ^-[defiz]$ ]]; then
        case "$prev" in
            -d) reply=(); ;;
            -e) mapfile -t reply < <(compgen -c -- "$curr") ;;
            -f) mapfile -t reply < <(compgen -W "0 1 2 3 4 5 6 7 8 9" -- "$curr") ;;
            -i) mapfile -t reply < <(compgen -f -- "$curr") ;;
            -z) mapfile -t reply < <(compgen -W "${tools[*]%% *}"  -- "$curr") ;;
        esac
        COMPREPLY=("${reply[@]}")
        return
    fi
    # first complete initial command token and options
    if [ -z "$base" ]; then
        mapfile -t reply < <(compgen -W "${!opts[*]} ${plugs[*]%%_*}" -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # determine next command token
    local next=() pat="^${base}_([[:alnum:]]+)"
    for plug in "${plugs[@]}"; do
        if [[ "$plug" =~ $pat ]]; then
            next+=("${BASH_REMATCH[1]%%_*}")
        fi
    done
    # maybe complete next command token
    if (("${#next[@]}")); then
        mapfile -t reply < <(compgen -W "${next[*]}" -- "$curr")
        COMPREPLY=("${reply[@]}")
        return
    fi
    # TODO maybe complete something specific for a plugin
    case "$base" in
        *) return ;;
    esac
}
complete -F _cz cz

cz_meta() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz meta [MODE-OPTION] [PREFIX] [ARGUMENTS]
Select a cz plugin and run it in the given mode.
The mode options are -o -p -q -r -s -t -u. The default mode is -p.
Given a prefix selections are limited to matching plugins.

This plugin is best used bound to a key, providing a quick
 interface to every other cz plugin.

EXAMPLES
 $ bind -x '"\\C-xx":rleval cz meta -q' # insert quoted fields
 $ bind -x '"\\C-xX":rleval cz meta -p' # insert full line
 $ bind -x '"\\C-xz":rleval cz meta -r' # insert command output
 $ bind -x '"\\C-xZ":rleval cz meta -s' # insert command string
EOF
    local mode="-p"
    local opt OPTIND OPTARG
    while getopts ":opqrstu" opt; do
        case "$opt" in
            [opqrstu])
                mode="-$opt"
                ;;
            \?)
                printf "Bad option: -%s\\n" "$OPTARG" >&2
                return 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    local prefix="$1"
    shift
    cz -f 0 -e "cz ${mode} {0} ${*@Q}" -i <(compgen -W "$(cz -l)" -- "$prefix")
}

cz_mode() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mode [PREFIX] [ARGUMENTS]
Select a cz mode then run a plugin in that mode.
EOF
    cz -e "cz meta {0} -- $*" -f 0 \
       -i <(printf "%07s %s\\n" -p "print line" -q "quoted fields" -r "command output" -s "command string" -t "template" -u "unquoted fields")
}

####

cz_argv() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz argv [ARGS]
Select from given arguments.
EOF
    cz -i <(printf "%s\\n" "$@")
}

cz_anagram() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz anagram TEXT [WORDS]
Select from anagrams of TEXT.
Optionally limit to a maximum number of WORDS.
EOF
    req an || return 5
    if [ -z "$1" ]; then return 2; fi
    cz -i <(an -l "${2:-3}" "$1")
}

anc() {
    read -d '' -r use <<EOF
anc [DIRECTORY]
Print the ancestor dirs of the given directory up to the root.
EOF
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            h) printf "%s\\n" "$use" >&2; return 0 ;;
            *) printf "%s\\n" "$use" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    local dir="${1:-$PWD}"
    if ! [ -d "$dir" ]; then return 2; fi;
    local toks=()
    IFS=/ read -ra toks <<< "${dir#/}"
    local seg="" cur="" idx=0
    for ((idx=0; idx<=${#toks[@]}; idx++)); do
        seg="${toks[$idx]}"
        printf "%s\\n" "${cur:-/}"
        cur="${cur}/${seg}"
    done
}

cz_ancestor() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ancestor [DIRECTORY]
Select from parent directories.
EOF
    local d="${1:-$PWD}"
    if ! [ -d "$d" ]; then return 2; fi;
    cz -d '' -e 'cd {0}' -f 0: -i <(anc "$d")
}

cz_ansible_group() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ansible group
Select a group from an ansible inventory then draw a graph of its members.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --graph {0}' \
       -i <(ansible-inventory --list \
                | jq -r '. | keys[] | select(. | test("^_") | not)')
}

cz_ansible_host() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ansible host
Select a host from an ansible inventory then print its variables as JSON.
See ANSIBLE_INVENTORY and ANSIBLE_CONFIG environment variables.
EOF
    req ansible-inventory jq || return 5
    cz -f 0 -e 'ansible-inventory --host {0}' \
       -i <(ansible-inventory --list \
                | jq -r '[.[] | select(.hosts!=null) | .hosts[]] | flatten | unique[]')
}

cz_ansible_doc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ansible doc
Select from ansible documentation topics.
EOF
    req ansible-doc || return 5
    cz -f 0 -e "ansible-doc {0}" < <(ansible-doc -l)
}

cz_apparix() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz apparix
Select from apparix bookmarks.
EOF
    req apparix awk || return 5
    cz -f 1 -i <(apparix | awk '/^j/ { print $2, $3 }')
}

cz_apt() {
    cz apt package "$@"
}

cz_apt_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz apt package [QUERY]
Select from apt package listings matching QUERY.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' \
       -i <(if [ "$qry" == "." ]; then
                hold -ept 3600 -- apt-cache search .
            else
                apt-cache search "$qry"
            fi
           )
}

cz_apt_installed() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz apt installed
Select from installed apt packages.
EOF
    req apt-cache || return 5
    local qry="${*:-.}"
    cz -f 0 -e 'apt-cache show {0}' \
       -i <(dpkg --get-selections | awk '$2 == "install" { print $1 }')
}

cz_asdf_plugin() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz asdf plugin
Select from available asdf plugins.
EOF
    req asdf sed || return 5
    # TODO prevent asdf git messages appearing in the selection
    cz -f 0 -e 'asdf plugin add {0} {1}' \
       -i <(hold -ept 3600 -- asdf plugin list all 2>/dev/null | sed 's/*/ /;')
}

cz_asdf_mine() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz asdf mine
Select from installed asdf plugins.
EOF
    req asdf || return 5
    cz -f 0 -e 'asdf plugin update {0}' \
       -i <(asdf plugin list)
}

cz_asdf_shim() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz asdf shim
Select from executable shims maintained by asdf.
EOF
    req asdf || return 5
    local dir="$HOME/.asdf/shims"
    cz -f 0 -e "asdf shim-versions {0}" \
       -i <(cd "$dir" && printf "%s\\n" ./*)
}

cz_asdf_version() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz asdf version PLUGIN
Select from available versions of the given asdf plugin.
EOF
    req asdf || return 5
    local plugin="${1:-$(insulate ^_CZ_ cz -u asdf mine)}"
    if [ -z "$plugin" ]; then return 2; fi
    cz -f 0 -e "asdf install ${plugin@Q} {0}" \
       -i <(printf "%s\\n" latest; asdf list all "$plugin";)
}

cz_bash_alias() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz bash alias
Select from defined bash aliases.
EOF
    cz -i <(alias)
}

cz_bash_bind_function() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash bind function
Select from bash internal readline functions.
EOF
    cz -i <(bind -l)
}

cz_bash_bind_key() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash bind key
Select from bash key bindings.
EOF
    cz -d: -f 1 -i <(grep -a -v ^# <( bind -p; bind -X; bind -s; ))
}

cz_bash_completion() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash completion
Select from bash completion function configuration.
EOF
    cz -i <(complete -p)
}

cz_bash_help() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash help
Select from bash help topics.
EOF
   cz -e 'help {0}' -i <(insulate ^_CZ_ cz -o compgen helptopic)
}

cz_bash_job() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash job
Select a bash background job and move it to the foreground.
EOF
    cz -d $'\t' -f 1 -e 'fg {1}' -i <(
        while read -r s p q c; do
            [[ "$s" =~ ^\[([0-9]+)\]([+-])?$ ]]
            printf "%s\\t%s\\t%s\\t%s\\t%s\\n" "${BASH_REMATCH[2]:-.}" "%${BASH_REMATCH[1]}" "$p" "$q" "$c"
        done < <(jobs -l))
}

cz_bash_history() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bash history [PATTERN]
Select a command from bash history then run it.
Given a pattern include only matching commands.
EOF
    req sort || return 5

    local pattern="${1:-.}"
    cz -f '3:@C' -e "{3:@C}" \
       -i <(HISTTIMEFORMAT="%F %T " history | sort -r -n | grep "$pattern")
}

cz_bluetooth_device() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bluetooth device
Select from known bluetooth devices.
EOF
    req bluetoothctl || return 5
    cz -f '1@C' -e 'bluetoothctl connect {1}' \
       -i <(bluetoothctl devices)
}

cz_bool() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz bool
Select a true or false value.
EOF
    cz -e 'let {2}' -f 0 -i <(printf "%s\\n" "true yes 1" "false no 0")
}

cz_box() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz box
Select an ascii box style then run boxes as a filter with that style.
EOF
    req boxes grep || return 5;
    cz -f 0 -e 'boxes -d {0}' -i <(boxes -l | grep -E '^[[:alnum:]]+$')
}

cz_buku() {
    cz_buku_bookmark "$@"
}

cz_buku_bookmark() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz buku bookmark [QUERY]
Select a buku bookmark then open it in a browser.
EOF
    req buku sed || return 5
    local query="${1:-.}"
    cz -e 'buku -o {0}' -f 1 \
       -i <(buku -f 4 -r "$query" | sed '/^[0-9]/!d;y/\t/ /' )
}

cz_buku_tag() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz buku tag [QUERY]
Select a buku tag.
EOF
    req buku sed || return 5
    local query="${1:-.}" filter=""
    read -r filter <<EOF
[.[] | .tags | split(",")] | flatten | unique | .[] | gsub(" "; "_")
EOF
    cz -e "buku -j -t {0}" -f 0 \
       -i <(buku -j -r "$query" | jq -r "$filter")
}

cz_chemical_element() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz chemical element
Select an element from the periodic table.
EOF
    req curl jq || return 5
    local filter="" url="https://raw.githubusercontent.com/Bowserinator/Periodic-Table-JSON/master/PeriodicTableJSON.json"
    read -r filter <<EOF
.elements[] | [.number, .period, .name, .symbol, .source] | @tsv
EOF
    cz -f 2 -i <(hold -ept 604800 curl -sS "$url" | jq -r "$filter")
}

colorblock() {
    local use="useage: colorblock #HEXCOLOR\\nGenerate an image of a solid block of the chosen color.\\n"
    local color="$1"
    if (( $# > 1 )); then
        printf "%s\\n" "$use" >&2
        return 1
    fi
    if ! [[ "$color" =~ ^#[[:xdigit:]]{6}$ ]]; then
        printf "Argument does not look like a hexadecimal color.\\n" >&2
        return 2
    fi
    req convert || return 5
    local out="/tmp/${color###}.png"
    if ! convert -size 100x100 xc:"$color" png:"$out"; then
        return 3
    fi
    printf "%s\\n" "$out"
}

cz_color() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz color
Select a hex color by name from available sources.
EOF
    req sort || return 5
    cz -d $'\t' -e "xdg-open \$(colorblock {0})" -f 0 \
       -i <( (insulate ^_CZ_ cz -o xkcd rgb; insulate ^_CZ_ cz -o x11 rgb) | sort)
}

declare n=""
while read -r n _; do
    eval "cz_compgen_$n() { \
    { hep \"\$_CZ_HELP\" && return; } <<EOF
cz compgen $n [PREFIX]
Select from bash builtin $n completion.
EOF
cz -d '' -f 0 -i <(compgen -A $n -- \"\$1\" | sort);\
}"
done <<EOF
alias
arrayvar
binding
builtin
command
directory
disabled
enabled
export
file
function
group
helptopic
hostname
job
keyword
running
service
setopt
shopt
signal
stopped
user
variable
EOF
unset n

cz_command() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz command
Select a command and run it.
EOF
    cz -ge '{0}' -f 0 compgen command
}

cz_cowsay() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz command
Select a cowsay filter.
EOF
    cz -ge "cowsay -f {0} -W \"\$COLUMNS\"" -i <(cowsay -l | sed '1d;s/ /\n/g;')
}

cz_cups_printer() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz cups printer [FILE] [LP OPTIONS]
Select a CUPS printer to which to print FILE.
Print data from stdin by default and if file is '-'.
EOF
    req lpstat lp sed || return 5
    local inp="${1:--}"
    if [[ "$inp" == "-" && ! -t 0 ]]; then
        inp=$(hold -fx -)
    fi
    shift
    local lpopts=""
    if (($#)); then
        lpopts=$(printf "%q " "$@")
    fi
    cz -e "lp -d {1} $lpopts -- ${inp@Q}" -f 1 \
       -i <(lpstat -p | sed -e :a -e '$!N;s/\n[\t]/ /;ta' -e 'P;D')
}

cz_cups_option() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz cups option [PRINTER]
Select a CUPS printer then select an option it supports.
EOF
    req lpoptions perl || return 5
    local printer="${1:-$(insulate ^_CZ_ cz -u cups printer)}"
    cz -f "-o {0}={1}" -f 1 \
       -i <(lpoptions -p "$printer" -l \
                | perl -nE 'if (/^((.*)\/)?.*: (.*)/) { printf "%s %s\n", $2, $_ for split(/ /, $3); };')
}

cz_descendant() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz descendant [DIRECTORY]
Select from parent directories.
EOF
    local d="${1:-$PWD}"
    if ! [ -d "$d" ]; then return 2; fi
    cz -e 'cd {0}' find dir "$d"
}

cz_dict_database() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dict database [QUERY]
Select a dict server database.
EOF
    req dict sed || return 5
    local qry="${1}"
    cz -e "dict -d {0} $qry" -f 0 -i <(dict -D | sed 1d)
}

cz_dict_strategy() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dict strategy [QUERY]
Select a dict server search strategy.
EOF
    req dict sed || return 5
    local qry="${1}"
    cz -e "dict -s {0} $qry" -f 0 -i <(dict -S | sed 1d)
}

cz_dict_word() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dict word [QUERY]
Select a word from a dict server and print its definition.
EOF
    req dict || return 5
    local qry="${1}"

    cz -f 3: -e 'dict -- "{3:@P}"' \
       -i <( if [ -z "$qry" ]; then hold -ep -t 86400 -- dict -m -f -s re "";
             else dict -m -f -s re "$qry"; fi)
}

cz_dir() {
    cz find dir "$@"
}

cz_dnf_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dnf package
Select a dnf package by name then print info about it.
EOF
    req dnf sed || return 5
    cz -f 0 -e 'dnf info {0}' -i <(dnf list 2>/dev/null | sed 1,2d)
}

cz_dns() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dns HOST
Select from records associated with given host.
EOF
    req dig grep || return 5
    local host="$1"
    if [ -z "$host" ]; then
        return 3
    fi
    local recs=()
    while read -r rtype; do
        local resp="" rec=""
        if ! resp=$(dig "$rtype" "$host" +short) || [ -z "$resp" ]; then
            continue
        fi
        while read -r rec; do
            recs+=("$(printf "%s %s\\n" "$rtype" "$rec")")
        done <<< "$resp"
    done < <(insulate ^_CZ_ cz -o dns rtype | grep -v XFR)
    cz -f 1: -i <(printf "%s\\n" "${recs[@]}")
}

cz_dns_rtype() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dnf package
Select a DNS rdata type.
EOF
    local rtypes=(A AAAA AFSDB APL CAA CDNSKEY CDS CERT CNAME CSYNC DHCID DLV DNAME
                  DNSKEY DS HINFO HIP IPSECKEY KEY KX LOC MX NAPTR NS NSEC NSEC3
                  NSEC3PARAM OPENPGPKEY PTR RRSIG RP SIG SMIMEA SOA SRV SSHFP TA
                  TKEY TLSA TSIG TXT URI
                  IXFR AXFR OPT)
    cz -i <(printf "%s\\n" "${rtypes[@]}")
}

cz_dns_tld() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz dns tld
Select a DNS top-level-domain as recorded by IANA.
EOF
    req curl grep tr || return 5
    local url="https://data.iana.org/TLD/tlds-alpha-by-domain.txt"
    cz -i <(hold -ep curl -sS "$url" | grep -v '^#' | tr '[:upper:]' '[:lower:]')
}

cz_docker_container() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz docker container
Select a docker container.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker container inspect {0}' \
       -i <(docker container ls -a | sed 1d)
}

cz_docker_image() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz docker image
Select a docker image.
EOF
    req docker sed || return 5
    cz -f 2 -e 'docker image inspect {2}' \
       -i <(docker images -a | sed 1d)
}

cz_docker_ps() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz docker ps
Select a running docker container process.
EOF
    req docker sed || return 5
    cz -f 0 -e 'docker inspect {0}' \
       -i <(docker ps | sed 1d)
}

cz_env() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz env
Select an environment variable.
EOF
    req env || return 5
    cz -0 -d '=' -f 0 -e "printf '%s\\n' \"\${0}\"" \
       -i <(env -0)
}

cz_fc_font() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz fc font
Select a font file known to fontconfig.
EOF
    req fc-list || return 5
    cz -f 0 -d ':' -i <(fc-list)
}

cz_ffmpeg_format() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ffmpeg format
Select from data formats supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -formats | sed 1,4d)
}

cz_ffmpeg_encoder() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ffmpeg encoder
Select from encoders supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -encoders | sed 1,10d)
}

cz_ffmpeg_decoder() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ffmpeg decoder
Select from decoders supported by ffmpeg.
EOF
    req ffmpeg sed || return 5
    cz -f 1 -i <(ffmpeg -loglevel 0 -decoders | sed 1,10d)
}

cz_figlet() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz figlet
Select a font file usable by figlet.
EOF
    req figlet || return 5
    local fdir="${FIGLET_FONTDIR:-/usr/share/figlet}"
    cz -f 0 -ge "figlet -t -d $fdir -f {0}" \
       -i <(for f in "$fdir"/*.{flf,tlf}; do
                printf "%s %s\\n" "${f##*/}" "${f}"
            done)
}

cz_radiogarden_place() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz radiogarden place
Select a place known to radio.garden.
go install github.com/jonasrmichel/radio-garden-go/radio-garden@latest
EOF
    req radio-garden || return 5
    cz -f 0 -i <(hold -ep -t 86400 -- radio-garden places \
                | jq -r '.data.list[] | [.id, .country, .title] | @tsv')
}

cz_radiogarden_station() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz radiogarden station [PLACE-ID]
Select a station known to radio.garden near the given place.
go install github.com/jonasrmichel/radio-garden-go/radio-garden@latest
EOF
    req radio-garden || return 5
    local place="${1:-$(insulate ^_CZ cz -u radiogarden place)}"
    cz  -e 'radio-garden station stream -i {0}' -f 0 \
        -i <(radio-garden stations -i "$place" \
                 | jq -r '.data.content[0].items[] | [(.href | split("/")[-1]), .title] | @tsv')
}

cz_rofi_theme() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz rofi theme
Select a rofi theme file.
EOF
    local dir="/usr/share/rofi/themes"
    req rofi "$dir" || return 5
    cz -z rofi -e 'printf "%s\n" {0}; CZ_ROFI_THEME={0} cz rofi theme' file "$dir" '*.rasi'
}

cz_file() {
    cz find file "$@"
}

cz_find_file() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz find file [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        printf "Expected directory argument: %s\\n" "$dir" >&2
        return 3
    fi
    if type fd &>/dev/null; then
        cz -d '' -0 -e "xdg-open {0}" -f 0 -i <(fd -HIL0g -t f "*${2}*" "${1:-.}")
    elif type find &>/dev/null; then
        cz -d '' -0 -e "xdg-open {0}" -f 0 -i <(find -L "${1:-.}" -iwholename "*${2}*" -type f -print0)
    else
        printf "Either find or fd is required!\\n" >&2
        return 5
    fi
}

cz_find_dir() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz find dir [DIRECTORY] [PATTERN]
Select a file under DIRECTORY (or current working directory)
 with full path matching PATTERN.
EOF
    local dir="${1:-.}"
    if ! [ -d "$dir" ]; then
        printf "Expected directory argument: %s\\n" "$dir" >&2
        return 3
    fi
    if type fd &>/dev/null; then
        cz -d '' -0 -f '0@Q' -i <(fd -HLI0g -t d "*${2}*" "${1:-.}")
    elif type find &>/dev/null; then
        cz -d '' -0 -f '0@Q' -i <(find -L "${1:-.}" -iwholename "*${2}*" -type d -print0)
    else
        printf "Either find or fd is required!\\n" >&2
        return 5
    fi
}

cz_firefox_tab() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz firefox tab
Select an open firefox tab.
EOF
    req firefox jq lz4jsoncat || return 5
    local db=("$HOME"/.mozilla/firefox/*.default/sessionstore-backups/recovery.jsonlz4)
    if [ -z "${db[0]}" ]; then
        return 3
    fi
    cz -f 0 -i <(lz4jsoncat "${db[0]}" \
                     | jq -r '.windows[].tabs[].entries[] |  [.url,.title] | @tsv')
}

cz_flatpak_app() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak app
Select an application installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --app)
}

cz_flatpak_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak package [REMOTE]
Select a package available at the given REMOTE then install it.
EOF
    req flatpak || return 5
    local r="";
    if ! r="${1:-$(cz -f 0 flatpak remote)}"; then
        return 4
    fi
    cz -f 0 -e "flatpak install $r {0}" -i <(flatpak remote-ls "$r")
}

cz_flatpak_remote() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak remote
Select a flatpak remote repository by name.
EOF
    req flatpak || return 5
    cz -i <(flatpak remote-list)
}

cz_flatpak_runtime() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz flatpak runtime
Select a runtime installed via flatpak.
EOF
    req flatpak || return 5
    cz -f 0 -e 'flatpak info {0}' -i <(flatpak list --runtime)
}

cz_gcloud() {
    cz meta gcloud
}

cz_gcloud_auth() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud auth
Select an available google cloud identity.
EOF
    req gcloud jq || return 5
    cz -f 0 -i <(gcloud auth list --format=json | jq -r '.[] | [.account, .status] | @tsv')
}

cz_gcloud_bucket() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bucket
Select a google cloud storage bucket.
EOF
    req gsutil || return 5
    cz -i <(gsutil ls)
}

cz_gcloud_bucket_file() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bucket file [BUCKET]
Select a file from a google cloud storage bucket.
EOF
    req gsutil || return 5
    local b="${1:-$(insulate ^_CZ_ cz -u gcloud bucket)}"
    if [ -z "$b" ]; then return 2; fi
    cz -f 2 -i <(gsutil ls -lr "$b"'**' | sed '$d')
}

cz_gcloud_bq_dataset() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bq dataset [PROJECT]
Select a Google BigQuery dataset and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    cz -f 0 -i <(bq --format json --project_id "$proj" ls \
                    | jq -r '.[] | [.id, (.datasetReference | (.datasetId, .projectId)), .location] | @tsv')
}

cz_gcloud_bq_table() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud bq table [PROJECT] [DATASET]
Select a Google BigQuery table from a dataset and describe it in JSON.
EOF
    req bq jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then
        return 2
    fi
    local ds="${2:-$(insulate ^_CZ_ cz -u gcloud bq dataset "${proj@Q}")}"
    if [ -z "$ds" ]; then
        return 2
    fi
    cz -f 0 -i <(bq --format json --project_id "$proj" ls "$ds" \
                    | jq -r '.[] | [.id, (.tableReference | (.tableId, .datasetId, .projectId)), .type] | @tsv')
}

cz_gcloud_compute_address() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute address [PROJECT]
Select a Google cloud compute address and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format=json compute addresses describe --region {2} {1}" \
       -i <(gcloud --project="$proj" compute addresses list --format=json \
                | jq -r '.[] | [.address, .name, (.region), .status, .description] | @tsv')
}

cz_gcloud_compute_disk() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute disk [PROJECT]
Select a Google cloud compute disk and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project ${proj@Q} --format=json compute disks describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format=json compute disks list \
                | jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .sizeGb, .status] | @tsv')
}

cz_gcloud_compute_image() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT]
Select a Google cloud compute image and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute images describe {0} " \
       -i <(gcloud --project "$proj" --format json compute images list \
                | jq -r '.[] | [.name, .creationTimestamp, .description ] | @tsv')
}

cz_gcloud_compute_instance() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute instance [PROJECT]
Select a Google cloud compute instance and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 1 -e "gcloud --project ${proj@Q} --format json compute instances describe --zone {2} {1}" \
       -i <(gcloud --project "$proj" --format json compute instances list \
                | jq -r '.[] | [.id, .name, (.zone | split("/")[-1]), .networkInterfaces[0].networkIP // "-", .accessConfigs[0].natIP // "-", .status] | @tsv')
}

cz_gcloud_compute_instance_template() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute instance [PROJECT]
Select a Google cloud compute instance templates and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json compute instance-templates describe {0}" \
       -i <(gcloud --project "$proj" --format=json compute instance-templates list \
                | jq -r ".[] | [ .name, .creationTimestamp, .description ] | @tsv")
}

cz_gcloud_compute_machine_type() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute machine type [PROJECT] [ZONE]
Select a Google cloud compute instance type.
EOF
    req gcloud jq sort || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    local zone="${2:-$(insulate ^_CZ_ cz -u gcloud compute zone )}"
    if [ -z "$zone" ]; then return 2; fi
    cz -f 1 \
       -i <(gcloud --project="$proj" --format=json compute machine-types list --filter=zone="$zone" \
                | jq -r '.[] | [.id, .name, .description] | @tsv' | sort)
}

cz_gcloud_compute_network() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute network [PROJECT]
Select a Google cloud network and describe it in JSON.
EOF
        req gcloud jq || return 5
        local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
        if [ -z "$proj" ]; then return 2; fi
        cz -f 0 -e "gcloud --project ${proj@Q} --format json compute networks describe {0}" \
           -i <(gcloud --project "$proj" --format json compute networks list \
                    | jq -r '.[] | [.name, .id, .creationTimestamp] | @tsv')
}

cz_gcloud_compute_region() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute region
Select a Google cloud region and describe it in JSON.
EOF
        req gcloud jq || return 5
        cz -f 1 -e 'gcloud compute regions describe {1}' \
           -i <(hold -ept 86400 -- gcloud --format=json compute regions list \
                    | jq -r '.[] | [.id, .name, .description] | @tsv')
}

cz_gcloud_compute_snapshot() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute snapshot
Select a Google cloud disk snapshot and describe it in JSON.
EOF
        req gcloud jq || return 5
        local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
        if [ -z "${proj@Q}" ]; then return 2; fi
        cz -f 1 -e "gcloud --project ${proj@Q} compute snapshots describe {1}" \
           -i <(gcloud --project "$proj" --format=json compute snapshots list \
                    | jq -r '.[] | [.id, .name, .status] | @tsv')
}

cz_gcloud_compute_subnet() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud subnet [PROJECT]
Select a Google cloud subnet and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 2 -e "gcloud --project ${proj@Q} --format json compute networks subnets describe {2}" \
       -i <(gcloud --project "$proj" --format json compute networks subnets list \
                | jq -r '.[] | [(.region | split("/") | .[-1]), .name, .id, .gatewayAddress, .ipCidrRange, .purpose] | @tsv')
}

cz_gcloud_compute_zone() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute zone
Select a Google cloud zone and describe it in JSON.
EOF
        req gcloud jq || return 5
        cz -f 1 -e "gcloud compute zones describe {1}" \
           -i <(hold -ept 86400 -- gcloud --format=json compute zones list \
                    | jq -r '.[] | [.id, .name, .description] | @tsv')
}

cz_gcloud_dns_record() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud compute image [PROJECT] [ZONE]
Select a Google cloud DNS record and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    local zone="${2:-$(insulate ^_CZ_ cz -u gcloud dns zone "$proj")}"
    if [ -z "$proj" ] || [ -z "$zone" ]; then return 2; fi
    cz -f 0,1 \
       -i <(gcloud --project "$proj" --format json dns record-sets list -z "$zone" \
                | jq -r '.[] | [.type, .name, .ttl, .rrdatas[]] | @tsv')
}

cz_gcloud_dns_zone() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud dns zone [PROJECT]
Select a Google cloud DNS zone and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json dns managed-zones describe {0}" \
       -i <(gcloud --project "$proj" --format json dns managed-zones list \
                | jq -r '.[] | [.name, .dnsName, .visibility, .description] | @tsv')
}

cz_gcloud_organization() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud organization
Select a Google cloud organization and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f 1 -e 'gcloud organizations describe {1} --format=json' \
       -i <(gcloud organizations list  --format=json \
                | jq -r '.[0] | [.creationTime, .name, .displayName, .lifecycleState ] | @tsv')
}

cz_gcloud_log() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud log [PROJECT]
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud logging read 'logName : {0}' --project=${proj@Q} --limit 10 --format=json" \
       -i <(gcloud --format=json --project "$proj" logging logs list | jq -r '.[]')
}

cz_gcloud_permission() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud permission [RESOURCE]
Select a Google cloud permission and describe it in JSON.
If a resource URL argument is given only list applicable permissions.
By default list all permissions on the selected organization.
EOF
    req gcloud jq || return 5
    local url="${1}"
    if [ -z "$url" ]; then
        local org=""
        if org=$(insulate ^_CZ_ cz -u gcloud organization); then
            url="//cloudresourcemanager.googleapis.com/$org"
        else
            return 2
        fi
    fi
    cz -f 0 \
       -i <(gcloud iam list-testable-permissions "$url" --format=json \
                | jq -r '.[] | [.name, .stage, .title // "-"] | @tsv')
}

cz_gcloud_pubsub_subscription() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud pubsub subscription [PROJECT]
Select a Google pubsub subscription and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json pubsub subscriptions describe {0}" \
       -i <(gcloud --project "$proj" pubsub subscriptions list --format=json \
                | jq -r '.[] | [(.name | split("/") | .[-1]), (.topic | split("/") | .[-1]) ] | @tsv')
}

cz_gcloud_pubsub_topic() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud pubsub topic [PROJECT]
Select a Google pubsub topic and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json pubsub topics describe {0}" \
       -i <(gcloud --project "$proj" pubsub topics list --format=json \
                | jq -r '.[] | [.name | split("/") | .[-1] ] | @tsv')
}

cz_gcloud_project() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud project
Select a Google cloud project and describe it in JSON.
EOF
    req gcloud jq || return 5
    cz -f '0@C' -e 'gcloud --format json projects describe {0}' \
       -i <(gcloud --format json projects list \
                | jq -r '.[] | [.projectId, .projectNumber, .name] | @tsv')
}

cz_gcloud_role() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud role [PROJECT]
Select a Google cloud IAM role and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json iam roles describe {0}" \
       -i <(gcloud --project "$proj" --format json iam roles list \
                | jq -r '.[] | [.name, .description] | @tsv')
}

cz_gcloud_serviceaccount() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud serviceaccount [PROJECT]
Select a Google cloud service account and describe it in JSON.
EOF
    req gcloud jq || return 5
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    if [ -z "$proj" ]; then return 2; fi
    cz -f 0 -e "gcloud --project ${proj@Q} --format json iam service-accounts describe {0}" \
       -i <(gcloud --project "$proj" --format json iam service-accounts list \
                | jq -r '.[] | [.email, .displayName, .email] | @tsv')
}

cz_gcloud_sd_namespace() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud sd namespace [PROJECT] [REGION]
Select a Google cloud service directory namespace.
EOF
    local proj="${1:-$(insulate ^_CZ_ cz -u gcloud project)}"
    local region="${1:-$(insulate ^_CZ_ cz -u gcloud compute region)}"
    cz -f 0 -i <(gcloud service-directory namespaces list --project="$proj" --format=json --location="$region" \
                     | jq -r '.[].name')
}

cz_gcloud_sd_service() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud sd service [NAMESPACE]
Select a Google cloud service directory service from the given namespace.
EOF
    local ns="${1:-$(insulate ^_CZ_ cz -u gcloud sd namespace)}"
    cz -f 0 -e 'gcloud service-directory services resolve {0}' \
       -i <(gcloud service-directory services list --format=json --namespace "$ns" \
                | jq -r '.[].name')
}

cz_gcloud_sd_endpoint() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gcloud sd endpoint [SERVICE]
Select a Google cloud service directory endpoint associated with the given service.
EOF
    local svc="${1:-$(insulate ^_CZ_ cz -u gcloud sd service)}"
    cz -f 0 -e 'gcloud service-directory endpoints describe --format=json {2}' \
       -i <(gcloud service-directory endpoints list --format=json --service "$svc" \
                | jq -r '.[] | [.address, .port, .name] | @tsv')
}

cz_gh_gist() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh gist
Select a Github gist and view it.
EOF
    req gh || return 5
    cz -e 'gh gist view {0}' -f 0 -i <(gh gist list)
}

cz_gh_issue() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh issue
Select a Github issue and view it.
EOF
    req gh || return 5
    cz -e 'gh issue view {0}' -f 0 -i <(gh issue list)
}

cz_gh_pr() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gh pr
Select a Github pull request and view it.
EOF
    req gh awk || return 5
    cz -e 'gh pr view {1}' -f 2 \
       -i <(gh pr list --limit 100 | awk -F $'\t' '{ print $4, $1, $3, $2 }' )
}

cz_git() {
    cz git status "$@"
}

cz_git_config() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git config [LOCATION]
Select from git configuration items.
Given a location list only items from the matching config.
Locations: global, local, worktree, system, and all - the default
EOF
    req git || return 5
    local scope="${1:-all}" type="${2}"
    local args=()
    case "$scope" in
        'all') : ;;
        'global') args+=('--global') ;;
        'local') args+=('--local') ;;
        'worktree') args+=('--worktree') ;;
        'system') args+=('--system') ;;
        *) printf "Unknown config location: %s\\n" "$scope" >&2; return 2 ;;
    esac
    cz -d '=' -f 0 -e "git config ${args[*]} --get {0}" \
       -i <(eval git config "${args[*]}" -l)
}

cz_git_diff() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git diff [DIRECTORY] [BRANCH]
Select a file in git repo in the given directory that differs from the given
branch. If unspecified the branch will be selected interactively.
EOF
    req git || return 5
    local repo="${1:-.}"
    local branch="${2:-$(insulate ^_CZ_ cz -u -f 0 git branch "$repo")}"
    if [ -z "$branch" ]; then return 2; fi
    cz -f 0 -e "git -C '$repo' diff ${branch@Q} -- {0}" \
       -i <(git -C "$repo" diff --name-only "$branch")
}

cz_git_status() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git status [DIRECTORY]
Select a modified file in the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 1 -e "git -C '$repo' diff {1}" \
       -i <(git -C "$repo" status -sbu | grep -v ^#)
}

cz_git_branch() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git branch [DIRECTORY]
Select a branch from the git repository in DIRECTORY.
EOF
    req git sed || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" branch -avv | sed 's/^[* ] //')
}

cz_git_commit() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git commit [DIRECTORY] [FILE]
Select a commit from the history of the git repository in DIRECTORY.
Given FILE, select a commit that modified that file.
EOF
    req git || return 5
    local repo="${1:-.}"
    local file="${2:-.}"
    cz -f 0 -e "git -C $repo show {0}" \
       -i <(git -C "$repo" log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit -- "$file")
}

cz_git_file()  {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git file [DIRECTORY]
Select a file managed by the git repository in DIRECTORY.
EOF
    req git grep || return 5
    local repo="${1:-.}"
    cz -f 4: -i <(git -C "$repo" ls-tree -rl HEAD)
}

cz_git_pickaxe() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git pickaxe [DIRECTORY] [TERM]
Select a commit from the history of the git repository in DIRECTORY.
EOF
        req git || return 5
        local repo="${1:-.}"
        local term="${2:-.}"
        cz -f 0 -e "git show {0}" \
                -i <(git -C "$repo" log --pretty=format:'%h %cI %s (%ce)' --abbrev-commit -S "$term")
}

cz_git_remote() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git remote [DIRECTORY]
Select a remote repository known to the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 1 -i <(git -C "$repo" remote -v)
}

cz_git_tag() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git tag [DIRECTORY]
Select a tag from the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" tag)
}

cz_git_worktree() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz git worktree [DIRECTORY]
Select a worktree associated with the git repository in DIRECTORY.
EOF
    req git || return 5
    local repo="${1:-.}"
    cz -f 0 -i <(git -C "$repo" worktree list)
}

cz_gpg_pubkey() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gpg key
Select a gpg public key from the default keyring.
EOF
    req gpg awk sort || return 5
    local format=""
    read -r -d '' format <<EOF
/^pub/ { t=\$2; s=\$3; (\$6 != "") ? e=\$6 : e="-"; u=""; };
/^ +[0-9A-F]+/{ k=\$2; };
/^uid/ { \$1=\$2=""; u=u\$0 };
/^sub/ { print k, t, s, e, u; };
EOF
    cz -ge 'gpg -e -a -r {0}' -f 0 -i <(gpg -k | awk -F"[][[:space:]]+" "$format" | sort -u)
}

cz_gpg_seckey() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz gpg seckey
Select a gpg secret key from the default keyring.
EOF
    req gpg awk sort || return 5
    local format=""
    read -r -d '' format <<EOF
/^sec/ { t=\$2; s=\$3; (\$6 != "") ? e=\$6 : e="-"; u=""; };
/^ +[0-9A-F]+/{ k=\$2; };
/^uid/ { \$1=\$2=""; u=u\$0 };
/^ssb/ { print k, t, s, e, u; };
EOF
    cz -ge 'gpg -d -a -r {0}' -f 0 -i <(gpg -K | awk -F"[][[:space:]]+" "$format" | sort -u)
}

cz_gpg_encrypt() {
    cz -e 'gpg -e -a -r {0}' gpg pubkey
}

cz_gpg_decrypt() {
    cz -e 'gpg -d -a -r {0}' gpg seckey
}

cz_grep() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz grep PATTERN [TARGET]
Select a file and line matching grep results for PATTERN in TARGET.
If TARGET is '-' cache standard input and search that file.
If TARGET is a directory search it recursively.
If the 'rg' command is available it is used instead of grep.
EOF
    local pattern="${1}"
    if [[ -z "$pattern" ]]; then
       return 2
    fi
    local target="${2:-.}"
    if [[ "$target" == "-" ]]; then
        target=$(hold -fx -)
    fi
    local matches=""
    if type rg &>/dev/null; then
        matches=$(rg --hidden -Hn -- "$pattern" "$target")
    elif type grep &>/dev/null; then
        matches=$(grep -r -Hn -- "$pattern" "$target")
    else
        printf "Either grep or rg is required!\\n" >&2
        return 5
    fi
    cz -d ':' -f 0  -e "$EDITOR +{1} -- {0}" \
       -i <(printf "%s\\n" "$matches")
}

cz_help() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz help
Select a cz plugin and print its usage text.
EOF
    cz -e 'cz -h {0}' -i <(cz -l)
}

cz_haskell_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz haskell package
Select a haskell cabal package then show info about it.
EOF
    req cabal || return 5
    cz -e 'cabal info {0}' -f 0 \
       -i <(hold -ept 300 -- cabal list --simple-output)
}

cz_haskell_installed() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz haskell installed
Select an installed haskell cabal package then show info about it.
EOF
    req cabal || return 5
    cz -f 0 -e 'cabal info {0}' -f 0 \
       -i <(hold -ept 300 -- cabal list --installed --simple-output)
}

cz_hg_branch() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz hg branch [DIRECTORY]
Select a branch in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg -R "${1:-.}" branches)
}

cz_hg_revision() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz hg revision [DIRECTORY]
Select a revision in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 0 -i <(hg log -T '{rev} {branch} {user} {date} {desc|firstline}\n' "${1:-.}")
}

cz_hg_status() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz hg status [DIRECTORY]
Select a modified file in the hg repository in DIRECTORY.
EOF
    req hg || return 5
    cz -f 1 -i <(hg -R "${1:-.}" status)
}

cz_html_element() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz html element [HTML-FILE] [< HTML-STREAM]
Select a HTML element by xpath string and print it.
EOF
    req xmllint || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    xmllint --html --xmlout "$f" 2>/dev/null | cz xml element
}

cz_html_value() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz html value [FILE] [< STREAM]
Select a HTML element by xpath string and extract its contents.
EOF
    req xmllint || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    xmllint --html --xmlout "$f" 2>/dev/null | cz xml value
}

cz_http_status() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz http status
Select an HTTP status code.
EOF
    local url="https://www.iana.org/assignments/http-status-codes/http-status-codes-1.csv"
    cz -d, -f1 -i <(hold -ep curl -fsS "$url" | awk 'NR == 1{ }; NR != 1 { print $0; }')
}

cz_i3_bind() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 bind
Select a bindsym from the current i3 configuration.
EOF
    req i3-msg grep sort || return 5
    cz -f 2: -i <(i3-msg -t get_config  | grep ^bindsym | sort)
}

cz_i3_mark() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 mark
Select an i3 window mark then move focus to the marked window.
EOF
    req i3-msg jq || return 5
    cz -f 0 -e 'i3-msg "[con_mark={0@C}] focus"' \
       -i <(i3-msg -t get_marks | jq -r '.[]')
}

cz_i3_output() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 output
Select an i3 recognized output device.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.[] | select(.active)
    | [ .name,
        "\\(.rect.width)x\\(.rect.height)",
        "\\(.rect.x),\\(.rect.y)",
        .current_workspace // "-"
      ] | join(" ")
EOF
    cz -f 0 \
       -i <(i3-msg -t get_outputs | jq -r "$filter")
}

cz_i3_window() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 window
Select a i3 window then move focus to that window.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.. | select(.id? and .type == "con" and .nodes == [])
   | [ (.id | tostring), .output, .name] | join(" ")
EOF
    cz -f 0 -e 'i3-msg "[con_id={0@C}] focus"' \
       -i <(i3-msg -t get_tree | jq -r "$filter")
}

cz_i3_workspace() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz i3 workspace
Select an i3 workspace then switch to that workspace.
EOF
    req i3-msg jq || return 5
    local filter=""
    read -r -d '' filter <<EOF
.[] | [ (.num | tostring), .name, .output, if .urgent then "*" else "" end ] | join(" ")
EOF
    cz -f 0 -e 'i3-msg workspace {0}' \
       -i <(i3-msg -t get_workspaces | jq -r "$filter")
}

cz_info()  {
    { hep "$_CZ_HELP" && return; } <<EOF
cz info [QUERY]
Select an info page matching QUERY and open it for reading.
EOF
    req info || return 5
    cz -e 'info {0}' -i <(info -k "${1:-.}")
}

cz_ip_addr4() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -4 addr)
}

cz_ip_addr6() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 interface configured on the system.
EOF
    req ip || return 5
    cz -f 2 -i <(ip -br -6 addr)
}

cz_ip_route4() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr4
Select an IPv4 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -4 route)
}

cz_ip_route6() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ip addr6
Select an IPv6 route configured on the system.
EOF
    req ip || return 5
    cz -f 0 -i <(ip -6 route)
}

cz_ispell() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ispell < MISPELLED > FIXED
Select options for mispelled words in the input text.
Print text with updated to replace words with selections.
EOF
    req ispell || return 5
    # parse ispell spellcheck output
    mapfile -t lines
    local line="" index=0 fix=""
    while read -r symbol rest; do
        line="${lines[$index]}"
        case "$symbol" in
            '') # next
                (( index++ ))
                continue
                ;;
            '?') # guess
                : ;;
            '&') # miss
                read -r bad _ _ sug   <<< "$rest"
                IFS=', ' read -r -a fixes <<< "$sug"
                fix=$(printf "%s\\n" "$bad" "${fixes[@]}" | cz)
                if [ -n "$fix" ]; then
                    lines["$index"]="${line/$bad/$fix}"
                fi
                ;;
            '#') # no guess
                continue
                ;;
            '*') # okay
                continue
                ;;
            '+') # root
                continue
                ;;
        esac
    done < <(printf "%s\\n" "${lines[@]}" | ispell -a)
    printf "%s\\n" "${lines[@]}"
}

cz_jq() {
    cz jq json "$@"
}

cz_jq_json() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz jq json [JSON-FILE] [< JSON-STREAM]
Select from jq path strings for each scalar within the input file or stream
 then use that path to extract the JSON element.
EOF
    req jq || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    read -r -d '' filter <<EOF
. as \$r
| path(..) | . as \$p
| \$r | getpath(\$p) as \$v
| select(\$v | scalars) |
[
 ("." + (\$p | map("[\\(tojson)]") | join(""))),
 (\$v)
] | @tsv
EOF
    cz -d $'\t' -f 0 -e "jq -r {0} ${f@Q}" < <(jq -r "$filter" "$f")
}

cz_jq_yaml() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz jq yaml [YAML-FILE] [< YAML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the YAML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    local y
    if ! y=$(perl -MYAML -MJSON -E 'say encode_json(Load(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq json <<< "$y"
}

cz_jq_toml() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz jq toml [TOML-FILE] [< TOML-STREAM]
Select from jq path strings for each element of the input file or stream
 then use that path to extract the TOML element.
EOF
    req jq perl || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    local t
    if ! t=$(perl -MTOML -MJSON -E 'say encode_json(from_toml(do{local $/;<>}))' < "$f"); then
        return 5
    fi
    cz jq scalar <<< "$t"
}

cz_kill() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz kill [PID]
Select a running process then select a signal and send it to the selected process.
EOF
    local pid
    if ! pid="${1:-$(cz process)}"; then return 2; fi
    cz -e "kill -s {0} $pid" signal
}

cz_lastpass() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz lastpass
Select the ID of a LastPass entry then look up the password component.
EOF
    req lpass || return 5
    local lpmenu=()
    local pat='^(.*[^/]) \[id: ([[:digit:]]+)\]$'
    while read -r item; do
        if [[ "$item" =~ $pat ]]; then
            lpmenu+=("${BASH_REMATCH[2]} ${BASH_REMATCH[1]}")
        fi
    done < <(lpass ls)
    cz -e "lpass show --password {0}" < <(printf "%s\\n" "${lpmenu[@]}")
}

cz_line() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz line [FILE] [< STREAM]
Select a line number from the input file or stream.
EOF
    req sed || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -e "sed -n {0}p '$f'" -f 0 < <(sed '=' "$f" | sed '/./N;s/\n/ /')
}

cz_locate() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz locate [GLOB ...]
Select a file from the locate database matching the given glob strings.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 "${@:-$PWD}")
}

cz_locate_regex() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz locate regex [PATTERN ...]
Select a file from the locate database matching the given regular expressions.
EOF
    req locate || return 5
    cz -0 -i <(locate -i -0 -r "${@:-.}")
}

cz_man() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz man [QUERY]
Select a manual page matching the given query and open it for reading.
EOF
    req man sed || return 5
    cz -f 0 -e 'man {0}' -i <(man -k "${1:-.}" | sed 's/ (/./;s/)//')
}

cz_mimetype() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mimetype
Select a mimetype and related file extensions.
EOF
    req grep /etc/mime.types || return 5
    cz -f 0 -i <(grep -v -e '^#' -e '^$' /etc/mime.types)
}

cz_mount() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mount
Select a mountpoint.
EOF
    req mount || return 5
    cz -f 2 -i <(mount)
}

# generate MPD tag related functions
for t in artist album title track name genre date composer performer comment disc filename; do
    eval "
cz_mpd_tag_$t() {
    { hep \"\$_CZ_HELP\" && return; } <<EOF
cz mpd $t
Select from available mpd database $t tags.
EOF
    req mpc || return 5
    cz -d '' -f 0 -i <(mpc list $t)
}"
done
unset t

cz_mpd_output() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd output and toggle it between enabled and disabled.
EOF
    req grep mpc || return 5
    cz -e "mpc toggleoutput {1}" -i <(mpc outputs | grep -v '^[[:space:]]')
}

cz_mpd_playlist() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd output
Select an mpd playlist then load it replacing the current playlist.
EOF
    req mpc || return 5
    cz -e "mpc clear && mpc load {0} && mpc play" -i <(mpc lsplaylists)
}

cz_mpd_find() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd find [TYPE] [QUERY]
Select an mpd tag of the given kind then select for songs matching that tag.
EOF
    req mpc || return 5
    local kind="${1:-$(insulate ^_CZ_ cz -u mpd type)}"
    if [ -z "$kind" ]; then return 2; fi
    local query="${2:-$(insulate ^_CZ_ cz -u mpd tag "$kind")}"
    if [ -z "$query" ]; then return 2; fi
    cz -d '' -f 0 -i <(mpc search "$kind" "$query")
}

cz_mpd_seek() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd seek
Select a percentage of the current song then seek to that position.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc seek {0}" \
       -i <(printf "%s%%\\n" {100..0..5})
}

cz_mpd_track() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd track
Select a track number from the current mpd playlist then play that track.
EOF
    req mpc || return 5
    cz -f 0 -e "mpc play {0}" \
       -i <(hold -ept 30 -- mpc -f '%position% [%artist% - %album% - %title%] --  %file%' playlist)
}

cz_mpd_type() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mpd type
Select an mpd tag type.
EOF
    req mpc || return 5
    cz argv artist album title track name genre date composer performer comment disc filename
}

cz_mtg_set() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mtg set
Select an MTG set by name using data from scryfall.com.
EOF
    req curl sort || return 5
    local url=""
    if ! sets=$(hold -pe -n scryfallsets -t 86400 -- curl -sS https://api.scryfall.com/sets \
                    | jq -r '.data[] | [.released_at, .code, .name ] | @tsv'); then
        return 2
    fi
    cz -d $'\t' -f 1 -i <(sort -u <<< "${sets[@]}")
}

cz_mtg_card() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz mtg card
Select an MTG card by name using data from scryfall.com.
EOF
    req curl sort || return 5
    local url=""
    if ! url=$(hold -pe -n scryfallbulk -t 86400 -- curl -sS https://api.scryfall.com/bulk-data \
                   | jq -r '.data[] | select(.type == "oracle_cards") | .download_uri'); then
        return 2
    fi
    local data="" menu=""
    if ! data=$(hold -e -n scryfalldata -t $((86400 * 7)) curl -sS "$url"); then
        return 2
    fi
    local filter='.[] | [.set, (.scryfall_uri | split("?"))[0], .name] | @tsv'
    if ! menu=$(hold -g -t 43200 || hold -f <(jq -r "$filter" "$data" | sort -u)); then
        return 2
    fi
    cz -d $'\t' -e 'xdg-open {1}' -f 2 -i "$menu"
}

cz_notmuch() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz notmuch QUERY
Select a message matcing the given query of a notmuch mail index.
EOF
    req getent || return 5
    cz -e 'notmuch show {0}' -f 0 -i <(notmuch search "$@")
}

cz_nss_group() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss group
Select a system group.
EOF
    req getent || return 5
    cz -f 0 -d : -i <(getent group)
}

cz_nss_host() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss host
Select a host from the system host name database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent hosts)
}

cz_nss_network() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss network
Select a network from the system network database.
EOF
    req getent || return 5
    cz -f 0 -i <(getent networks)
}

cz_nss_passwd() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss passwd
Select a system user from the system user database.
EOF
    req getent || return 5
    cz -f 0 -d ':' -i <(getent passwd)
}

cz_nss_protocol() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss protocol
Select a protocol from the system protocol database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent protocols)
}

cz_nss_service() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz nss service
Select a service from the system service database.
EOF
    req getent || return 5
    cz -f 1 -i <(getent services)
}

cz_rfc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz rfc
Select an internet RFC and open it for reading.
EOF
    read -r -d '' filter <<EOF
BEGIN { my (\$x, \$n); };
if (/^[[:digit:]].*/) { \$n++; say \$x if \$x; \$x = join " ", @F[0..\$#F]; } else { if (\$n) { s/^\\s+//; \$x .= \$_ }; };
END { say \$x if \$x; };
EOF
    cz -e 'xdg-open https://www.rfc-editor.org/rfc/rfc{0@C}.txt' -f 0 \
       -i <(hold -ep curl -sS https://www.rfc-editor.org/rfc-index.txt | perl -lanE "$filter")
}

cz_ruby_gem() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ruby gem
Select an installed ruby gem package by name.
EOF
    req gem ruby || return 5
    cz -f 0 -e 'gem info {0}' -i <(gem query --local)
}

cz_pandoc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pandoc [FILE]
Select a pandoc output format then convert the given file into that format.
If the file argument is omitted input is read from stdin.
EOF
    req pandoc head || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -f 0 -e "pandoc -t {0} -o - ${f@Q}" -i <(pandoc --list-output-formats)
}

cz_pass() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pass
Select an entry from a pass directory and print its contents.
EOF
    req pass find sed head || return 5
    local pdir="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
    cz -f 0 -e 'pass show {0} | head -n1' \
       -i <(find "$pdir" -type f -name '*.gpg' | sed "s#\\.gpg##; s#$pdir##")
}

cz_pci() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pci
Select a PCI device.
EOF
    req lspci || return 5
    cz -f 0 -i <(lspci)
}

cz_perl_module() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz perl module
Select an installed perl module.
EOF
    req perl || return 5
    cz -e 'perldoc {0}' -f 0 -i <(perl -MExtUtils::Installed  -E 'say for ExtUtils::Installed->new->modules')
}

cz_perl_doc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz perl module
Select a perl internal document.
EOF
    req perl || return 5
    cz -e 'perldoc {0}' -f 0 -i <(perldoc perl | sed -n '/-/d;/^[ ]*perl/{ s/^[ ]*//; p};')
}

cz_pokemon() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pokemon
Select a pokemon by name or ID.
EOF
    req curl jq || return 5
    local url="https://raw.githubusercontent.com/fanzeyi/pokemon.json/master/pokedex.json"
    read -r -d '' filter <<EOF
.[] | [.id, (.name.english | sub(" "; "_")), (.type | join(","))] | @tsv
EOF
    cz -f 1 -i <(hold -ep curl -sS "$url" | jq -r "$filter")
}

cz_process() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz process
Select a system process by PID.
EOF
    req ps || return 5
    local cols index table
    mapfile table < <(ps ux)
    read -r -a cols <<< "${table[0]}"
    for ((index=1; index <= "${#cols[@]}"; index++)) ; do
        if [[ "${cols[$index]}" =~ ^(pid|PID)$ ]]; then break; fi
    done
    cz -f "$index" <<< "${table[@]:1}"
}

cz_pulseaudio_sink() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio sink
Select a pulseaudio sink and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-sink-mute {0} toggle' -i <(pactl list short sinks)
}

cz_pulseaudio_sink_volume() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio sink volume
Select a pulseaudio sink and a percentage to set its volume.
EOF
    req pactl || return 5
    local sink
    if ! sink=$(cz -u pulseaudio sink); then return 2; fi
    cz -f 0 -e "pactl set-sink-volume $sink {0}" -i <(printf "%s%%\\n" {100..0..5})
}

cz_pulseaudio_input() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio sink volume
Select a pulseaudio sink input.
EOF
    req pactl || return 5
    cz -f 0 -e 'cz -e "pactl move sink-input {0} {{0}}" pulseaudio sink' -i <(pactl list short sink-inputs)
}

cz_pulseaudio_source() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pulseaudio source
Select a pulseaudio source and toggle its mute state.
EOF
    req pactl || return 5
    cz -f 0 -e 'pactl set-source-mute {0} toggle' -i <(pactl list short sources)
}

cz_pwgen() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pwgen [LENGTH]
Select a generated password of given length.
EOF
    req pwgen || return 5
    cz -f 0 -i <(pwgen -1 -s "${1:-20}" 50)
}

cz_pydoc() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz pydoc
Select a python document and open it for reading.
EOF
    req pydoc || return 5
    cz -f 0 -e "pydoc {0}" < <(hold -ept 86400 -- pydoc -k .)
}

cz_python_package() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz python installed
Select an installed python package and show info about it.
EOF
    req pip || return 5
    cz -f 0 -e "pip show {0}" < <(pip list)
}

cz_raku_module() {
        { hep "$_CZ_HELP" && return; } <<EOF
cz raku installed
Select a generated password of given length.
EOF
    req sed zef || return 5
    cz -f 0 -i <(zef list -i 2>/dev/null | sed 's/:ver/ /')
}

cz_screen_session() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz screen session
Select a screen session and attach to it.
EOF
    req screen || return 5
    cz -f 0 -e 'screen -rd {0}' -i <(screen -ls | grep pts)
}

cz_signal() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz signal
Select a system signal.
EOF
    local name line signals
    declare -a signals
    for x in {1..64}; do
        name=$(kill -l "$x")
        if [ -z "$name" ]; then continue; fi
        line=$(printf "%02d %s\\n" "$x" "$name")
        signals+=("$line")
    done
    cz -f 0 < <(printf "%s\\n" "${signals[@]}")
}

cz_ssh() {
    cz ssh host "$@"
}

cz_ssh_host() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ssh host [COMMAND]
Select a host from SSH configuration then connect to that host.
EOF
    req ssh sed || return 5
    cz -f 0 -e "ssh -t {0} -- $*" -i <(sed -E -n 's/^\s*Host\s+(.*)\s*/\1/ip' < "$HOME/.ssh/config")
}

cz_ssh_key() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz ssh key
Select a key available to the running ssh-agent.
EOF
    req ssh-add || return 5
    cz -f 2 -i < <(ssh-add -l)
}

cz_stream() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz stream
Select a standard stream.
EOF
    cz -f 0 <<EOF
0 /dev/stdin
1 /dev/stdout
2 /dev/stderr
EOF
}

cz_surfraw() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz surfraw [QUERY ...]
Select a surfraw elvi then run it with the given query.
EOF
    req surfraw || return 5
    cz -f 0 -e "surfraw {0} $*" < <(surfraw -elvi | sed 1d)
}

cz_sysctl() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz sysctl
Select a kernel parameter.
EOF
    req sysctl || return 5
    cz -f 0 -i <(sysctl -a 2>/dev/null)
}

cz_systemd_unit() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz systemd unit [user|system] [TYPE]
Select a systemd system unit then check its status.
EOF
    req systemctl || return 5
    local user=""
    case "$1" in
        system) user=""; shift ;;
        user) user="yes"; shift ;;
    esac
    local type="$1"
    cz -f 0 -e 'systemctl status {0}' \
       -i <(eval systemctl list-units "${user:+--user}" "${type:+--type=$type}" -l -a --plain --no-legend)
}

# generate systemd unit type related functions
for c in user system; do
    for t in automount device mount path scope service slice socket swap target timer; do
        eval "
cz_systemd_${c}_${t}() {
    { hep \"\$_CZ_HELP\" && return; } <<EOF
cz mpd $t
Select from ${c}-level systemd ${t} units.
EOF
    req mpc || return 5
    cz systemd unit ${c} ${t}
}"
    done
done
unset t c


cz_systemd_file() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz systemd file [user|system] [TYPE]
Select a systemd system unit file then check its status.
EOF
    req systemctl || return 5
    local user=""
    case "$1" in
        system) user=""; shift ;;
        user) user="yes"; shift ;;
    esac
    local type="$1"
    cz -f 0 -e 'systemctl status {0}' \
       -i <(eval systemctl list-unit-files "${user:+--user}" "${type:+--type=$type}" --plain --no-legend)
}

cz_systemd_type() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz systemd type
Select a type of systemd unit.
EOF
    req sed systemctl || return 5
    cz -e 'systemctl list-units --type={0}' -f 0 \
       -i <(systemctl -t help | sed 1d)
}

cz_tar() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tar ARCHIVE
Select a file from a tar archive.
EOF
    req tar || return 5
    local tb="$1"
    cz -e "tar -x -f '$tb' -- {0}" -f 0 -d '' \
       -i <(tar -t -f "$tb")
}

cz_task() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz task [FILTER]
Select a taskwarrior task matching the given filter.
EOF
    req sed task || return 5
    cz -f 0 -i <(task list "$@" | sed '1,3d;$d;/^$/d;')
}

cz_terraform_module() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform module [DIRECTORY]
Select a terraform module call defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.module_calls | to_entries[]
  | ["module\\(.key)",
     .value.source,
     .value.pos.filename,
     .value.pos.line] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{3@C} -- {2}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_output() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform output [DIRECTORY]
Select a terraform output variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.outputs | to_entries[]
 | [.key,
    .value.pos.filename,
    .value.pos.line] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{2@C} -- {1}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_provider() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform output [DIRECTORY]
Select a terraform output variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.provider_configs | to_entries[]
 | [.key,
    .value.name,
    .value.alias] | @tsv
EOF
    cz -d $'\t' -f 0 \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_resource() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform resource [DIRECTORY]
Select a terraform resource defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}"  filter=""
    read -r -d '' filter <<EOF
.managed_resources | to_entries[]
 | [.value.provider.name,
    .key,
    .value.pos.filename,
    .value.pos.line] | @tsv
EOF
    cz  -d $'\t' -f 1 -e "$EDITOR +{3@C} -- {2}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_terraform_variable() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz terraform variable [DIRECTORY]
Select a terraform input variable defined in the given directory.
EOF
    req jq terraform-config-inspect || return 5
    local dir="${1:-.}" filter=""
    read -r -d '' filter <<EOF
.variables | to_entries[]
 | [.key,
    .value.pos.filename,
    .value.pos.line,
    .value.description] | @tsv
EOF
    cz -d $'\t' -f 0 -e "$EDITOR +{2@C} -- {1}" \
       -i <(terraform-config-inspect "$dir" --json | jq -r "$filter")
}

cz_timezone() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz timezone
Select a timezone and print the current time in that region.
EOF
    local p="/usr/share/zoneinfo/posix"
    if req date timedatectl 2>/dev/null; then
        cz -f 0 -e 'TZ={0} date' \
           -i <(timedatectl list-timezones)
    elif req date "$p" sort 2>/dev/null; then
        cz -f 0 -e 'TZ={0} fate' \
           -i <(for x in "$p"/*/*; do printf "%s\\n" "${x##"$p"/}"; done | sort)
    else
        req systemd "$p"
    fi
}

cz_tmux_command() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux command
Select a tmux command.
EOF
    req tmux || return 5
    cz -f 0 -i <(tmux list-commands)
}

cz_tmux_key() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux key
Select a tmux key binding.
EOF
    req tmux || return 5
    cz -i <(tmux list-keys)
}

cz_tmux_pane() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux pane
Select a pane in the current tmux session and give it focus.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux select-pane -t {0}' -i <(tmux list-panes)
}

cz_tmux_session() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux session
Select a tmux session then attach to it.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux attach-session -t {0}' -i <(tmux list-sessions)
}

cz_tmux_window() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz tmux window
Select a tmux window then switch to it.
EOF
    req tmux || return 5
    cz -d ':' -f 0 -e 'tmux select-window -t {0}' -i <(tmux list-windows)
}

cz_unicode() {
    cz unicode character "$@"
}

cz_unicode_character() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode character [SECTION]
Select a unicode character from given character block or script.
Interactively select a block if a section is not given.
EOF
    req perl || return 5
    declare -a parts
    if (($#)); then
        parts=("$@")
    else
        parts=("$(_CZ_MODE="" _CZ_FIELDS="" cz -p unicode block)")
    fi
    if [ -z "${parts[*]}" ]; then return 2; fi
    read -d '' -r util <<EOF
use strict;
use warnings;
use open ":std", ":encoding(UTF-8)";
use Unicode::UCD qw/charinfo charscript charscripts  charblock charblocks/;
my (\$blocks,\$scripts) = (charblocks(),charscripts());
for (@ARGV) {
    my \$section = \$blocks->{\$_} || \$scripts->{\$_};
    exit 1 unless(\$section);
    for my \$range (\$section->@*) {
        for (grep { defined } map { charinfo(\$_) } (\$range->[0] .. \$range->[1])) {
            say join ":", chr hex \$_->{code}, \$_->{code}, \$_->{name};
        }
    }
}
EOF
    cz -d ':' -e "printf \$'\\U{1@C}'" -f 0  \
       -i <(perl -E "$util" "${parts[@]}")
}

cz_unicode_block() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode block
Select a unicode block by name.
EOF
    req perl || return 5
    cz -d '' -f 0 -i <(perl -MUnicode::UCD=charblocks -E 'say for sort keys %{charblocks()}')
}

cz_unicode_script() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode script
Select a unicode script by name.
EOF
    req perl || return 5
    cz -d '' -f 0 -i <(perl -MUnicode::UCD=charscripts -E 'say for sort keys %{charscripts()}')
}

cz_unicode_symbol() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz unicode symbol
Select a unicode character by name from symboloc blocks.
EOF
    req perl || return 5
    local blocks=()
    mapfile -t blocks <<EOF
Alchemical Symbols
Ancient Symbols
Arrows
Block Elements
Box Drawing
Chess Symbols
Currency Symbols
Dingbats
Domino Tiles
Emoticons
Geometric Shapes
Geometric Shapes Extended
Ideographic Symbols and Punctuation
Letterlike Symbols
Mathematical Alphanumeric Symbols
Miscellaneous Mathematical Symbols-A
Miscellaneous Mathematical Symbols-B
Miscellaneous Symbols
Miscellaneous Symbols and Arrows
Miscellaneous Symbols and Pictographs
Miscellaneous Technical
Musical Symbols
Supplemental Symbols and Pictographs
Symbols and Pictographs Extended-A
Symbols for Legacy Computing
Transport and Map Symbols
Yijing Hexagram Symbols
EOF

    cz -d ':' -e "printf \$'\\U{1@C}'" -f 0 -i \
       <(hold -gp -t 604800 || \
             hold -fpx <(insulate ^_CZ_ cz -o unicode character "${blocks[@]}"))
}

cz_uri() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz uri [FILE] [< STREAM]
Select a URI extracted from the input text.
URIs are extracted with xurls or urifind.
EOF
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    if type urifind &>/dev/null; then
        cz -e 'xdg-open {0}' < <(urifind -su < "$f")
    elif type xurls &>/dev/null; then
        cz -e 'xdg-open {0}' < <(xurls -r < "$f")
    else
        req urifind xurls || return 5
    fi
}

cz_usb() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz usb
Select a USB device.
EOF
    req lsusb || return 5
    cz -e 'lsusb -v -d {5}' -f 5 -i <(lsusb)
}

cz_v4l_device() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz v4l device
Select a video4linux device.
EOF
    req v4l2-ctl || return 5
    cz -d$'\t' -f 1 -i <(v4l2-ctl --list-devices | awk '/:$/{n=$0};/^\t\//{ print n"\t"$0 };')
}

cz_wal_theme() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz wal theme
EOF
    req sed sort wal || return 5
    cz -f 0 -e 'wal -f {0}' -i <(wal --theme | sed '/^ - /!d;/^ - /s/ - //;' | sort -u)
}

cz_word() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz word [FILE] [< STREAM]
Select a word from the given file or stream.
EOF
    req grep sort || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz < <(grep -Eo '([[:alnum:]_-])+' "$f" | sort -u)
}

whence() {
    read -d '' -r use <<EOF
whence [COMMAND...] [< COMMANDS]
Print the files that define the given commands.
EOF
    local opt OPTIND OPTARG
    while getopts ":h" opt; do
        case "$opt" in
            h) printf "%s\\n" "$use" >&2; return 0 ;;
            ?) printf "%s\\n" "$use" >&2; return 1 ;;
        esac
    done
    shift $((OPTIND - 1))

    local commands=("$@")
    if ! [ -t 0 ]; then
        mapfile -t lines
        commands+=("${lines[@]}")
    fi

    for ((idx=0; idx<="${#commands[@]}"; idx++)); do
        local that="${commands[$idx]}"
        local kind=""
        if ! kind=$(type -t -- "$that"); then
            continue
        fi
        local where=""
        case "$kind" in
            'function')
                shopt -s extdebug
                read -r _ _ where < <(declare -F -- "$that")
                shopt -u extdebug
                ;;
            'file')
                where=$(type -P "$that")
                ;;
            *)
                continue
                ;;
        esac
        printf "%s %s\\n" "$that" "$where"
    done
}

cz_whence() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz whence [COMMANDS...]
Select from commands by the path that defines them.
EOF
    if (("$#")) && [[ -n "$*" ]];  then
        cz -f 1 -i <(whence "$@")
    else
        cz -f 1 -i < <(hold -gp -t 86400 || hold -fpx <(compgen -c | whence))
    fi
}

cz_x11_rgb() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz x11 rgb
Select a color by name from the X11 flat file database.
EOF
    local rgb="/etc/X11/rgb.txt"
    req "$rgb" perl sort || return 5
    read -r -d '' tweak <<EOF
next if /^!/;
printf "#%02x%02x%02x\\t%s\\n", @F[0..2], join(" ", @F[3..\$#F])
EOF
    cz -d $'\t' -f 1 \
       -i <(hold -pe -- perl -lanE "$tweak" "$rgb" | sort)
}

cz_x11_window() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz x11 window
Select an X11 window.
EOF
    req sort xwininfo || return 5
    local menu=()
    while IFS= read -r l; do
        if [[ "$l" =~ ^[[:space:]]+?(0x[[:alnum:]]+)[[:space:]](.*) ]]; then
            menu+=("${BASH_REMATCH[1]} ${BASH_REMATCH[2]}")
        fi
    done < <(xwininfo -children -root)
    cz -f 0 -i <(printf "%s\\n" "${menu[@]}" | sort)
}

xclip_brief() {
    local mod="" buf="" lns=""
    for mod in clipboard primary secondary; do
        buf=$(xclip -o -selection "$mod" 2>/dev/null)
        mapfile -t lns <<< "$buf"
        printf "%09s %s %s:%s\\n" "$mod" "${#buf}" "${#lns[@]}" "${lns[0]}"
    done
}

cz_xclip_in() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xclip in
Select a xclip buffer and write the input stream to it.
EOF
    req xclip || return 5
    cz -ge 'xclip -selection {0} -i' -i <(xclip_brief)
}

cz_xclip_out() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xclip out
Select a xclip buffer and print its contents.
EOF
    req xclip || return 5
    cz -e 'xclip -selection {0} -o' -i <(xclip_brief)
}

cz_xinput_device() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xinput device
Select an X11 device and print its name.
EOF
    req xinput sort || return 5
    mapfile -t lines < <(while read -r id; do
                             printf "%s:%s\\n" "$id" "$(xinput list --name-only "$id")";
                         done < <(xinput list --id-only) | sort -nk1)
    cz -d ':' -f 1 -i <(printf "%s\\n" "${lines[@]}")
}

cz_xinput_prop() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xinput prop [DEVICE]
Select a property associated with the given X11 device.
EOF
    req xinput sed || return 5
    local dev="${1:-$(insulate ^_CZ_ cz -u -f 0 xinput device)}"
    cz -d ':' -f 1 \
       -i <(xinput list-props "$dev" \
                | sed -n '/^[[:space:]]/!d; s/[[:space:]]*//; s/ ([0-9]*)//; p;')
}

cz_xkcd_rgb() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xkcd rgb
Select a hex color by name from XKCD's public flat file database.
See https://xkcd.com/color/rgb.txt.
EOF
    req curl perl sort || return 5
    local url="${RGB_URL:-https://xkcd.com/color/rgb.txt}"
    read -r -d '' tweak <<EOF
next if /^#/;
printf "%s\\t%s\\n", \$F[-1], join(" ", @F[0..\$#F-1])
EOF
    cz -d $'\t' -f 1 -i <(hold -ep -- curl -sS "$url" | perl -lanE "$tweak" | sort)
}

cz_xml_element() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xml element [FILE] [< STREAM]
Select a XML element by xpath string and print it.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -d '' -f 0 -e "xmlstarlet sel -B -t -c {0} ${f@Q}" < <(xmlstarlet el -v "$f")
}

cz_xml_value() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xml value [FILE] [< STREAM]
Select a XML element by xpath string and extract its contents.
EOF
    req xmlstarlet || return 5
    local f=""
    if ! f=$(hold -fx "${1:--}"); then
        return 4
    fi
    cz -d '' -f 0 -e "xmlstarlet sel -B -t -v {0} ${f@Q}" < <(xmlstarlet el -v "$f")
}

cz_xrandr_monitor() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xrandr monitor
Select a X11 monitor.
EOF
    req xrandr sed || return 5
    cz -d: -f 1 -i <(xrandr --listmonitors | sed '1d')
}

cz_xrandr_provider() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xrandr provider
Select a X11 provider.
EOF
    req xrandr sed || return 5
    cz -f 0 -i <(xrandr --listproviders | sed '1d')
}

cz_xrdb_resource() {
    { hep "$_CZ_HELP" && return; } <<EOF
cz xrandr provider
Select a X11 resource.
EOF
    req xrdb || return 5
    cz -d : -f 0 -i <(xrdb -query)
}

###

# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then cz "$@"; fi
